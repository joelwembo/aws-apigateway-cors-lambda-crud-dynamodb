"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addMetadataAssetsToManifest = void 0;
// eslint-disable-next-line max-len
const path = require("path");
const cxschema = require("@aws-cdk/cloud-assembly-schema");
const cxapi = require("@aws-cdk/cx-api");
const chalk = require("chalk");
const logging_1 = require("./logging");
/**
 * Take the metadata assets from the given stack and add them to the given asset manifest
 *
 * Returns the CloudFormation parameters that need to be sent to the template to
 * pass Asset coordinates.
 */
// eslint-disable-next-line max-len
async function addMetadataAssetsToManifest(stack, assetManifest, envResources, reuse) {
    reuse = reuse || [];
    const assets = stack.assets;
    if (assets.length === 0) {
        return {};
    }
    const toolkitInfo = await envResources.lookupToolkit();
    if (!toolkitInfo.found) {
        // eslint-disable-next-line max-len
        throw new Error(`This stack uses assets, so the toolkit stack must be deployed to the environment (Run "${chalk.blue('cdk bootstrap ' + stack.environment.name)}")`);
    }
    const params = {};
    for (const asset of assets) {
        // FIXME: Should have excluded by construct path here instead of by unique ID, preferably using
        // minimatch so we can support globs. Maybe take up during artifact refactoring.
        const reuseAsset = reuse.indexOf(asset.id) > -1;
        if (reuseAsset) {
            (0, logging_1.debug)(`Reusing asset ${asset.id}: ${JSON.stringify(asset)}`);
            continue;
        }
        (0, logging_1.debug)(`Preparing asset ${asset.id}: ${JSON.stringify(asset)}`);
        if (!stack.assembly) {
            throw new Error('Unexpected: stack assembly is required in order to find assets in assembly directory');
        }
        Object.assign(params, await prepareAsset(asset, assetManifest, envResources, toolkitInfo));
    }
    return params;
}
exports.addMetadataAssetsToManifest = addMetadataAssetsToManifest;
// eslint-disable-next-line max-len
async function prepareAsset(asset, assetManifest, envResources, toolkitInfo) {
    switch (asset.packaging) {
        case 'zip':
        case 'file':
            return prepareFileAsset(asset, assetManifest, toolkitInfo, asset.packaging === 'zip' ? cxschema.FileAssetPackaging.ZIP_DIRECTORY : cxschema.FileAssetPackaging.FILE);
        case 'container-image':
            return prepareDockerImageAsset(asset, assetManifest, envResources);
        default:
            // eslint-disable-next-line max-len
            throw new Error(`Unsupported packaging type: ${asset.packaging}. You might need to upgrade your aws-cdk toolkit to support this asset type.`);
    }
}
function prepareFileAsset(asset, assetManifest, toolkitInfo, packaging) {
    const extension = packaging === cxschema.FileAssetPackaging.ZIP_DIRECTORY ? '.zip' : path.extname(asset.path);
    const baseName = `${asset.sourceHash}${extension}`;
    // Simplify key: assets/abcdef/abcdef.zip is kinda silly and unnecessary, so if they're the same just pick one component.
    const s3Prefix = asset.id === asset.sourceHash ? 'assets/' : `assets/${asset.id}/`;
    const key = `${s3Prefix}${baseName}`;
    const s3url = `s3://${toolkitInfo.bucketName}/${key}`;
    (0, logging_1.debug)(`Storing asset ${asset.path} at ${s3url}`);
    assetManifest.addFileAsset(asset.sourceHash, {
        path: asset.path,
        packaging,
    }, {
        bucketName: toolkitInfo.bucketName,
        objectKey: key,
    });
    return {
        [asset.s3BucketParameter]: toolkitInfo.bucketName,
        [asset.s3KeyParameter]: `${s3Prefix}${cxapi.ASSET_PREFIX_SEPARATOR}${baseName}`,
        [asset.artifactHashParameter]: asset.sourceHash,
    };
}
async function prepareDockerImageAsset(asset, assetManifest, envResources) {
    // Pre-1.21.0, repositoryName can be specified by the user or can be left out, in which case we make
    // a per-asset repository which will get adopted and cleaned up along with the stack.
    // Post-1.21.0, repositoryName will always be specified and it will be a shared repository between
    // all assets, and asset will have imageTag specified as well. Validate the combination.
    if (!asset.imageNameParameter && (!asset.repositoryName || !asset.imageTag)) {
        throw new Error('Invalid Docker image asset configuration: "repositoryName" and "imageTag" are required when "imageNameParameter" is left out');
    }
    const repositoryName = asset.repositoryName ?? 'cdk/' + asset.id.replace(/[:/]/g, '-').toLowerCase();
    // Make sure the repository exists, since the 'cdk-assets' tool will not create it for us.
    const { repositoryUri } = await envResources.prepareEcrRepository(repositoryName);
    const imageTag = asset.imageTag ?? asset.sourceHash;
    assetManifest.addDockerImageAsset(asset.sourceHash, {
        directory: asset.path,
        dockerBuildArgs: asset.buildArgs,
        dockerBuildSsh: asset.buildSsh,
        dockerBuildTarget: asset.target,
        dockerFile: asset.file,
        networkMode: asset.networkMode,
        platform: asset.platform,
        dockerOutputs: asset.outputs,
    }, {
        repositoryName,
        imageTag,
    });
    if (!asset.imageNameParameter) {
        return {};
    }
    return { [asset.imageNameParameter]: `${repositoryUri}:${imageTag}` };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXNzZXRzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYXNzZXRzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLG1DQUFtQztBQUNuQyw2QkFBNkI7QUFDN0IsMkRBQTJEO0FBQzNELHlDQUF5QztBQUN6QywrQkFBK0I7QUFHL0IsdUNBQWtDO0FBR2xDOzs7OztHQUtHO0FBQ0gsbUNBQW1DO0FBQzVCLEtBQUssVUFBVSwyQkFBMkIsQ0FBQyxLQUF3QyxFQUFFLGFBQW1DLEVBQUUsWUFBa0MsRUFBRSxLQUFnQjtJQUNuTCxLQUFLLEdBQUcsS0FBSyxJQUFJLEVBQUUsQ0FBQztJQUNwQixNQUFNLE1BQU0sR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDO0lBRTVCLElBQUksTUFBTSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7UUFDdkIsT0FBTyxFQUFFLENBQUM7S0FDWDtJQUVELE1BQU0sV0FBVyxHQUFHLE1BQU0sWUFBWSxDQUFDLGFBQWEsRUFBRSxDQUFDO0lBQ3ZELElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxFQUFFO1FBQ3RCLG1DQUFtQztRQUNuQyxNQUFNLElBQUksS0FBSyxDQUFDLDBGQUEwRixLQUFLLENBQUMsSUFBSSxDQUFDLGdCQUFnQixHQUFHLEtBQUssQ0FBQyxXQUFZLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQ3ZLO0lBRUQsTUFBTSxNQUFNLEdBQTJCLEVBQUUsQ0FBQztJQUUxQyxLQUFLLE1BQU0sS0FBSyxJQUFJLE1BQU0sRUFBRTtRQUMxQiwrRkFBK0Y7UUFDL0YsZ0ZBQWdGO1FBQ2hGLE1BQU0sVUFBVSxHQUFHLEtBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBRWhELElBQUksVUFBVSxFQUFFO1lBQ2QsSUFBQSxlQUFLLEVBQUMsaUJBQWlCLEtBQUssQ0FBQyxFQUFFLEtBQUssSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMs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QUMsa0JBQWtCLEVBQUU7UUFBRSxPQUFPLEVBQUUsQ0FBQztLQUFFO0lBQzdDLE9BQU8sRUFBRSxDQUFDLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxFQUFFLEdBQUcsYUFBYSxJQUFJLFFBQVEsRUFBRSxFQUFFLENBQUM7QUFDeEUsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0ICogYXMgY3hzY2hlbWEgZnJvbSAnQGF3cy1jZGsvY2xvdWQtYXNzZW1ibHktc2NoZW1hJztcbmltcG9ydCAqIGFzIGN4YXBpIGZyb20gJ0Bhd3MtY2RrL2N4LWFwaSc7XG5pbXBvcnQgKiBhcyBjaGFsayBmcm9tICdjaGFsayc7XG5pbXBvcnQgeyBFbnZpcm9ubWVudFJlc291cmNlcyB9IGZyb20gJy4vYXBpL2Vudmlyb25tZW50LXJlc291cmNlcyc7XG5pbXBvcnQgeyBUb29sa2l0SW5mbyB9IGZyb20gJy4vYXBpL3Rvb2xraXQtaW5mbyc7XG5pbXBvcnQgeyBkZWJ1ZyB9IGZyb20gJy4vbG9nZ2luZyc7XG5pbXBvcnQgeyBBc3NldE1hbmlmZXN0QnVpbGRlciB9IGZyb20gJy4vdXRpbC9hc3NldC1tYW5pZmVzdC1idWlsZGVyJztcblxuLyoqXG4gKiBUYWtlIHRoZSBtZXRhZGF0YSBhc3NldHMgZnJvbSB0aGUgZ2l2ZW4gc3RhY2sgYW5kIGFkZCB0aGVtIHRvIHRoZSBnaXZlbiBhc3NldCBtYW5pZmVzdFxuICpcbiAqIFJldHVybnMgdGhlIENsb3VkRm9ybWF0aW9uIHBhcmFtZXRlcnMgdGhhdCBuZWVkIHRvIGJlIHNlbnQgdG8gdGhlIHRlbXBsYXRlIHRvXG4gKiBwYXNzIEFzc2V0IGNvb3JkaW5hdGVzLlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFkZE1ldGFkYXRhQXNzZXRzVG9NYW5pZmVzdChzdGFjazogY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0LCBhc3NldE1hbmlmZXN0OiBBc3NldE1hbmlmZXN0QnVpbGRlciwgZW52UmVzb3VyY2VzOiBFbnZpcm9ubWVudFJlc291cmNlcywgcmV1c2U/OiBzdHJpbmdbXSk6IFByb21pc2U8UmVjb3JkPHN0cmluZywgc3RyaW5nPj4ge1xuICByZXVzZSA9IHJldXNlIHx8IFtdO1xuICBjb25zdCBhc3NldHMgPSBzdGFjay5hc3NldHM7XG5cbiAgaWYgKGFzc2V0cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICBjb25zdCB0b29sa2l0SW5mbyA9IGF3YWl0IGVudlJlc291cmNlcy5sb29rdXBUb29sa2l0KCk7XG4gIGlmICghdG9vbGtpdEluZm8uZm91bmQpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICAgIHRocm93IG5ldyBFcnJvcihgVGhpcyBzdGFjayB1c2VzIGFzc2V0cywgc28gdGhlIHRvb2xraXQgc3RhY2sgbXVzdCBiZSBkZXBsb3llZCB0byB0aGUgZW52aXJvbm1lbnQgKFJ1biBcIiR7Y2hhbGsuYmx1ZSgnY2RrIGJvb3RzdHJhcCAnICsgc3RhY2suZW52aXJvbm1lbnQhLm5hbWUpfVwiKWApO1xuICB9XG5cbiAgY29uc3QgcGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG5cbiAgZm9yIChjb25zdCBhc3NldCBvZiBhc3NldHMpIHtcbiAgICAvLyBGSVhNRTogU2hvdWxkIGhhdmUgZXhjbHVkZWQgYnkgY29uc3RydWN0IHBhdGggaGVyZSBpbnN0ZWFkIG9mIGJ5IHVuaXF1ZSBJRCwgcHJlZmVyYWJseSB1c2luZ1xuICAgIC8vIG1pbmltYXRjaCBzbyB3ZSBjYW4gc3VwcG9ydCBnbG9icy4gTWF5YmUgdGFrZSB1cCBkdXJpbmcgYXJ0aWZhY3QgcmVmYWN0b3JpbmcuXG4gICAgY29uc3QgcmV1c2VBc3NldCA9IHJldXNlLmluZGV4T2YoYXNzZXQuaWQpID4gLTE7XG5cbiAgICBpZiAocmV1c2VBc3NldCkge1xuICAgICAgZGVidWcoYFJldXNpbmcgYXNzZXQgJHthc3NldC5pZH06ICR7SlNPTi5zdHJpbmdpZnkoYXNzZXQpfWApO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgZGVidWcoYFByZXBhcmluZyBhc3NldCAke2Fzc2V0LmlkfTogJHtKU09OLnN0cmluZ2lmeShhc3NldCl9YCk7XG4gICAgaWYgKCFzdGFjay5hc3NlbWJseSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkOiBzdGFjayBhc3NlbWJseSBpcyByZXF1aXJlZCBpbiBvcmRlciB0byBmaW5kIGFzc2V0cyBpbiBhc3NlbWJseSBkaXJlY3RvcnknKTtcbiAgICB9XG5cbiAgICBPYmplY3QuYXNzaWduKHBhcmFtcywgYXdhaXQgcHJlcGFyZUFzc2V0KGFzc2V0LCBhc3NldE1hbmlmZXN0LCBlbnZSZXNvdXJjZXMsIHRvb2xraXRJbmZvKSk7XG4gIH1cblxuICByZXR1cm4gcGFyYW1zO1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuYXN5bmMgZnVuY3Rpb24gcHJlcGFyZUFzc2V0KGFzc2V0OiBjeHNjaGVtYS5Bc3NldE1ldGFkYXRhRW50cnksIGFzc2V0TWFuaWZlc3Q6IEFzc2V0TWFuaWZlc3RCdWlsZGVyLCBlbnZSZXNvdXJjZXM6IEVudmlyb25tZW50UmVzb3VyY2VzLCB0b29sa2l0SW5mbzogVG9vbGtpdEluZm8pOiBQcm9taXNlPFJlY29yZDxzdHJpbmcsIHN0cmluZz4+IHtcbiAgc3dpdGNoIChhc3NldC5wYWNrYWdpbmcpIHtcbiAgICBjYXNlICd6aXAnOlxuICAgIGNhc2UgJ2ZpbGUnOlxuICAgICAgcmV0dXJuIHByZXBhcmVGaWxlQXNzZXQoXG4gICAgICAgIGFzc2V0LFxuICAgICAgICBhc3NldE1hbmlmZXN0LFxuICAgICAgICB0b29sa2l0SW5mbyxcbiAgICAgICAgYXNzZXQucGFja2FnaW5nID09PSAnemlwJyA/IGN4c2NoZW1hLkZpbGVBc3NldFBhY2thZ2luZy5aSVBfRElSRUNUT1JZIDogY3hzY2hlbWEuRmlsZUFzc2V0UGFja2FnaW5nLkZJTEUpO1xuICAgIGNhc2UgJ2NvbnRhaW5lci1pbWFnZSc6XG4gICAgICByZXR1cm4gcHJlcGFyZURvY2tlckltYWdlQXNzZXQoYXNzZXQsIGFzc2V0TWFuaWZlc3QsIGVudlJlc291cmNlcyk7XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHBhY2thZ2luZyB0eXBlOiAkeyhhc3NldCBhcyBhbnkpLnBhY2thZ2luZ30uIFlvdSBtaWdodCBuZWVkIHRvIHVwZ3JhZGUgeW91ciBhd3MtY2RrIHRvb2xraXQgdG8gc3VwcG9ydCB0aGlzIGFzc2V0IHR5cGUuYCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJlcGFyZUZpbGVBc3NldChcbiAgYXNzZXQ6IGN4c2NoZW1hLkZpbGVBc3NldE1ldGFkYXRhRW50cnksXG4gIGFzc2V0TWFuaWZlc3Q6IEFzc2V0TWFuaWZlc3RCdWlsZGVyLFxuICB0b29sa2l0SW5mbzogVG9vbGtpdEluZm8sXG4gIHBhY2thZ2luZzogY3hzY2hlbWEuRmlsZUFzc2V0UGFja2FnaW5nKTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB7XG5cbiAgY29uc3QgZXh0ZW5zaW9uID0gcGFja2FnaW5nID09PSBjeHNjaGVtYS5GaWxlQXNzZXRQYWNrYWdpbmcuWklQX0RJUkVDVE9SWSA/ICcuemlwJyA6IHBhdGguZXh0bmFtZShhc3NldC5wYXRoKTtcbiAgY29uc3QgYmFzZU5hbWUgPSBgJHthc3NldC5zb3VyY2VIYXNofSR7ZXh0ZW5zaW9ufWA7XG4gIC8vIFNpbXBsaWZ5IGtleTogYXNzZXRzL2FiY2RlZi9hYmNkZWYuemlwIGlzIGtpbmRhIHNpbGx5IGFuZCB1bm5lY2Vzc2FyeSwgc28gaWYgdGhleSdyZSB0aGUgc2FtZSBqdXN0IHBpY2sgb25lIGNvbXBvbmVudC5cbiAgY29uc3QgczNQcmVmaXggPSBhc3NldC5pZCA9PT0gYXNzZXQuc291cmNlSGFzaCA/ICdhc3NldHMvJyA6IGBhc3NldHMvJHthc3NldC5pZH0vYDtcbiAgY29uc3Qga2V5ID0gYCR7czNQcmVmaXh9JHtiYXNlTmFtZX1gO1xuICBjb25zdCBzM3VybCA9IGBzMzovLyR7dG9vbGtpdEluZm8uYnVja2V0TmFtZX0vJHtrZXl9YDtcblxuICBkZWJ1ZyhgU3RvcmluZyBhc3NldCAke2Fzc2V0LnBhdGh9IGF0ICR7czN1cmx9YCk7XG5cbiAgYXNzZXRNYW5pZmVzdC5hZGRGaWxlQXNzZXQoYXNzZXQuc291cmNlSGFzaCwge1xuICAgIHBhdGg6IGFzc2V0LnBhdGgsXG4gICAgcGFja2FnaW5nLFxuICB9LCB7XG4gICAgYnVja2V0TmFtZTogdG9vbGtpdEluZm8uYnVja2V0TmFtZSxcbiAgICBvYmplY3RLZXk6IGtleSxcbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICBbYXNzZXQuczNCdWNrZXRQYXJhbWV0ZXJdOiB0b29sa2l0SW5mby5idWNrZXROYW1lLFxuICAgIFthc3NldC5zM0tleVBhcmFtZXRlcl06IGAke3MzUHJlZml4fSR7Y3hhcGkuQVNTRVRfUFJFRklYX1NFUEFSQVRPUn0ke2Jhc2VOYW1lfWAsXG4gICAgW2Fzc2V0LmFydGlmYWN0SGFzaFBhcmFtZXRlcl06IGFzc2V0LnNvdXJjZUhhc2gsXG4gIH07XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHByZXBhcmVEb2NrZXJJbWFnZUFzc2V0KFxuICBhc3NldDogY3hzY2hlbWEuQ29udGFpbmVySW1hZ2VBc3NldE1ldGFkYXRhRW50cnksXG4gIGFzc2V0TWFuaWZlc3Q6IEFzc2V0TWFuaWZlc3RCdWlsZGVyLFxuICBlbnZSZXNvdXJjZXM6IEVudmlyb25tZW50UmVzb3VyY2VzKTogUHJvbWlzZTxSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+PiB7XG5cbiAgLy8gUHJlLTEuMjEuMCwgcmVwb3NpdG9yeU5hbWUgY2FuIGJlIHNwZWNpZmllZCBieSB0aGUgdXNlciBvciBjYW4gYmUgbGVmdCBvdXQsIGluIHdoaWNoIGNhc2Ugd2UgbWFrZVxuICAvLyBhIHBlci1hc3NldCByZXBvc2l0b3J5IHdoaWNoIHdpbGwgZ2V0IGFkb3B0ZWQgYW5kIGNsZWFuZWQgdXAgYWxvbmcgd2l0aCB0aGUgc3RhY2suXG4gIC8vIFBvc3QtMS4yMS4wLCByZXBvc2l0b3J5TmFtZSB3aWxsIGFsd2F5cyBiZSBzcGVjaWZpZWQgYW5kIGl0IHdpbGwgYmUgYSBzaGFyZWQgcmVwb3NpdG9yeSBiZXR3ZWVuXG4gIC8vIGFsbCBhc3NldHMsIGFuZCBhc3NldCB3aWxsIGhhdmUgaW1hZ2VUYWcgc3BlY2lmaWVkIGFzIHdlbGwuIFZhbGlkYXRlIHRoZSBjb21iaW5hdGlvbi5cbiAgaWYgKCFhc3NldC5pbWFnZU5hbWVQYXJhbWV0ZXIgJiYgKCFhc3NldC5yZXBvc2l0b3J5TmFtZSB8fCAhYXNzZXQuaW1hZ2VUYWcpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIERvY2tlciBpbWFnZSBhc3NldCBjb25maWd1cmF0aW9uOiBcInJlcG9zaXRvcnlOYW1lXCIgYW5kIFwiaW1hZ2VUYWdcIiBhcmUgcmVxdWlyZWQgd2hlbiBcImltYWdlTmFtZVBhcmFtZXRlclwiIGlzIGxlZnQgb3V0Jyk7XG4gIH1cblxuICBjb25zdCByZXBvc2l0b3J5TmFtZSA9IGFzc2V0LnJlcG9zaXRvcnlOYW1lID8/ICdjZGsvJyArIGFzc2V0LmlkLnJlcGxhY2UoL1s6L10vZywgJy0nKS50b0xvd2VyQ2FzZSgpO1xuXG4gIC8vIE1ha2Ugc3VyZSB0aGUgcmVwb3NpdG9yeSBleGlzdHMsIHNpbmNlIHRoZSAnY2RrLWFzc2V0cycgdG9vbCB3aWxsIG5vdCBjcmVhdGUgaXQgZm9yIHVzLlxuICBjb25zdCB7IHJlcG9zaXRvcnlVcmkgfSA9IGF3YWl0IGVudlJlc291cmNlcy5wcmVwYXJlRWNyUmVwb3NpdG9yeShyZXBvc2l0b3J5TmFtZSk7XG4gIGNvbnN0IGltYWdlVGFnID0gYXNzZXQuaW1hZ2VUYWcgPz8gYXNzZXQuc291cmNlSGFzaDtcblxuICBhc3NldE1hbmlmZXN0LmFkZERvY2tlckltYWdlQXNzZXQoYXNzZXQuc291cmNlSGFzaCwge1xuICAgIGRpcmVjdG9yeTogYXNzZXQucGF0aCxcbiAgICBkb2NrZXJCdWlsZEFyZ3M6IGFzc2V0LmJ1aWxkQXJncyxcbiAgICBkb2NrZXJCdWlsZFNzaDogYXNzZXQuYnVpbGRTc2gsXG4gICAgZG9ja2VyQnVpbGRUYXJnZXQ6IGFzc2V0LnRhcmdldCxcbiAgICBkb2NrZXJGaWxlOiBhc3NldC5maWxlLFxuICAgIG5ldHdvcmtNb2RlOiBhc3NldC5uZXR3b3JrTW9kZSxcbiAgICBwbGF0Zm9ybTogYXNzZXQucGxhdGZvcm0sXG4gICAgZG9ja2VyT3V0cHV0czogYXNzZXQub3V0cHV0cyxcbiAgfSwge1xuICAgIHJlcG9zaXRvcnlOYW1lLFxuICAgIGltYWdlVGFnLFxuICB9KTtcblxuICBpZiAoIWFzc2V0LmltYWdlTmFtZVBhcmFtZXRlcikgeyByZXR1cm4ge307IH1cbiAgcmV0dXJuIHsgW2Fzc2V0LmltYWdlTmFtZVBhcmFtZXRlcl06IGAke3JlcG9zaXRvcnlVcml9OiR7aW1hZ2VUYWd9YCB9O1xufVxuIl19