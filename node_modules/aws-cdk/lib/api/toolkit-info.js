"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ToolkitInfo = exports.DEFAULT_TOOLKIT_STACK_NAME = void 0;
const chalk = require("chalk");
const bootstrap_props_1 = require("./bootstrap/bootstrap-props");
const cloudformation_1 = require("./util/cloudformation");
const logging_1 = require("../logging");
exports.DEFAULT_TOOLKIT_STACK_NAME = 'CDKToolkit';
/**
 * Information on the Bootstrap stack of the environment we're deploying to.
 *
 * This class serves to:
 *
 * - Inspect the bootstrap stack, and return various properties of it for successful
 *   asset deployment (in case of legacy-synthesized stacks).
 * - Validate the version of the target environment, and nothing else (in case of
 *   default-synthesized stacks).
 *
 * An object of this type might represent a bootstrap stack that could not be found.
 * This is not an issue unless any members are used that require the bootstrap stack
 * to have been found, in which case an error is thrown (default-synthesized stacks
 * should never run into this as they don't need information from the bootstrap
 * stack, all information is already encoded into the Cloud Assembly Manifest).
 *
 * Nevertheless, an instance of this class exists to serve as a cache for SSM
 * parameter lookups (otherwise, the "bootstrap stack version" parameter would
 * need to be read repeatedly).
 *
 * Called "ToolkitInfo" for historical reasons.
 *
 */
class ToolkitInfo {
    static determineName(overrideName) {
        return overrideName ?? exports.DEFAULT_TOOLKIT_STACK_NAME;
    }
    static async lookup(environment, sdk, stackName) {
        const cfn = sdk.cloudFormation();
        stackName = ToolkitInfo.determineName(stackName);
        try {
            const stack = await (0, cloudformation_1.stabilizeStack)(cfn, stackName);
            if (!stack) {
                (0, logging_1.debug)('The environment %s doesn\'t have the CDK toolkit stack (%s) installed. Use %s to setup your environment for use with the toolkit.', environment.name, stackName, chalk.blue(`cdk bootstrap "${environment.name}"`));
                return ToolkitInfo.bootstrapStackNotFoundInfo(stackName);
            }
            if (stack.stackStatus.isCreationFailure) {
                // Treat a "failed to create" bootstrap stack as an absent one.
                (0, logging_1.debug)('The environment %s has a CDK toolkit stack (%s) that failed to create. Use %s to try provisioning it again.', environment.name, stackName, chalk.blue(`cdk bootstrap "${environment.name}"`));
                return ToolkitInfo.bootstrapStackNotFoundInfo(stackName);
            }
            return new ExistingToolkitInfo(stack);
        }
        catch (e) {
            return ToolkitInfo.bootstrapStackLookupError(stackName, e);
        }
    }
    static fromStack(stack) {
        return new ExistingToolkitInfo(stack);
    }
    static bootstrapStackNotFoundInfo(stackName) {
        return new BootstrapStackNotFoundInfo(stackName, 'This deployment requires a bootstrap stack with a known name; pass \'--toolkit-stack-name\' or switch to using the \'DefaultStackSynthesizer\' (see https://docs.aws.amazon.com/cdk/latest/guide/bootstrapping.html)');
    }
    static bootstrapStackLookupError(stackName, e) {
        return new BootstrapStackNotFoundInfo(stackName, `This deployment requires a bootstrap stack with a known name, but during its lookup the following error occurred: ${e}; pass \'--toolkit-stack-name\' or switch to using the \'DefaultStackSynthesizer\' (see https://docs.aws.amazon.com/cdk/latest/guide/bootstrapping.html)`);
    }
    constructor() {
    }
}
exports.ToolkitInfo = ToolkitInfo;
/**
 * Returned when a bootstrap stack is found
 */
class ExistingToolkitInfo extends ToolkitInfo {
    constructor(bootstrapStack) {
        super();
        this.bootstrapStack = bootstrapStack;
        this.found = true;
    }
    get bucketUrl() {
        return `https://${this.requireOutput(bootstrap_props_1.BUCKET_DOMAIN_NAME_OUTPUT)}`;
    }
    get bucketName() {
        return this.requireOutput(bootstrap_props_1.BUCKET_NAME_OUTPUT);
    }
    get version() {
        return parseInt(this.bootstrapStack.outputs[bootstrap_props_1.BOOTSTRAP_VERSION_OUTPUT] ?? '0', 10);
    }
    get variant() {
        return this.bootstrapStack.parameters[bootstrap_props_1.BOOTSTRAP_VARIANT_PARAMETER] ?? bootstrap_props_1.DEFAULT_BOOTSTRAP_VARIANT;
    }
    get parameters() {
        return this.bootstrapStack.parameters ?? {};
    }
    get terminationProtection() {
        return this.bootstrapStack.terminationProtection ?? false;
    }
    get stackName() {
        return this.bootstrapStack.stackName;
    }
    /**
     * Prepare an ECR repository for uploading to using Docker
     *
     */
    requireOutput(output) {
        if (!(output in this.bootstrapStack.outputs)) {
            throw new Error(`The CDK toolkit stack (${this.bootstrapStack.stackName}) does not have an output named ${output}. Use 'cdk bootstrap' to correct this.`);
        }
        return this.bootstrapStack.outputs[output];
    }
}
/**
 * Returned when a bootstrap stack could not be found
 *
 * This is not an error in principle, UNTIL one of the members is called that requires
 * the bootstrap stack to have been found, in which case the lookup error is still thrown
 * belatedly.
 *
 * The errors below serve as a last stop-gap message--normally calling code should have
 * checked `toolkit.found` and produced an appropriate error message.
 */
class BootstrapStackNotFoundInfo extends ToolkitInfo {
    constructor(stackName, errorMessage) {
        super();
        this.stackName = stackName;
        this.errorMessage = errorMessage;
        this.found = false;
    }
    get bootstrapStack() {
        throw new Error(this.errorMessage);
    }
    get bucketUrl() {
        throw new Error(this.errorMessage);
    }
    get bucketName() {
        throw new Error(this.errorMessage);
    }
    get version() {
        throw new Error(this.errorMessage);
    }
    get variant() {
        throw new Error(this.errorMessage);
    }
    prepareEcrRepository() {
        throw new Error(this.errorMessage);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9vbGtpdC1pbmZvLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsidG9vbGtpdC1pbmZvLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUNBLCtCQUErQjtBQUUvQixpRUFBOEs7QUFDOUssMERBQTRFO0FBQzVFLHdDQUFtQztBQUV0QixRQUFBLDBCQUEwQixHQUFHLFlBQVksQ0FBQztBQUV2RDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXNCRztBQUNILE1BQXNCLFdBQVc7SUFDeEIsTUFBTSxDQUFDLGFBQWEsQ0FBQyxZQUFxQjtRQUMvQyxPQUFPLFlBQVksSUFBSSxrQ0FBMEIsQ0FBQztJQUNwRCxDQUFDO0lBRU0sTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsV0FBOEIsRUFBRSxHQUFTLEVBQUUsU0FBNkI7UUFDakcsTUFBTSxHQUFHLEdBQUcsR0FBRyxDQUFDLGNBQWMsRUFBRSxDQUFDO1FBQ2pDLFNBQVMsR0FBRyxXQUFXLENBQUMsYUFBYSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ2pELElBQUk7WUFDRixNQUFNLEtBQUssR0FBRyxNQUFNLElBQUEsK0JBQWMsRUFBQyxHQUFHLEVBQUUsU0FBUyxDQUFDLENBQUM7WUFDbkQsSUFBSSxDQUFDLEtBQUssRUFBRTtnQkFDVixJQUFBLGVBQUssRUFBQyxtSUFBbUksRUFDdkksV0FBVyxDQUFDLElBQUksRUFBRSxTQUFTLEVBQUUsS0FBSyxDQUFDLElBQUksQ0FBQyxrQkFBa0IsV0FBVyxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQztnQkFDbEYsT0FBTyxXQUFXLENBQUMsMEJBQTBCLENBQUMsU0FBUyxDQUFDLENBQUM7YUFDMUQ7WUFDRCxJQUFJLEtBQUssQ0FBQyxXQUFXLENBQUMsaUJBQWlCLEVBQUU7Z0JBQ3ZDLCtEQUErRDtnQkFDL0QsSUFBQSxlQUFLLEVBQUMsNkdBQTZHLEVBQ2pILFdBQVcsQ0FBQyxJQUFJLEVBQUUsU0FBUyxFQUFFLEtBQUssQ0FBQyxJQUFJLENB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QUssQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7SUFDckMsQ0FBQztJQUVELElBQVcsU0FBUztRQUNsQixNQUFNLElBQUksS0FBSyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztJQUNyQyxDQUFDO0lBRUQsSUFBVyxVQUFVO1FBQ25CLE1BQU0sSUFBSSxLQUFLLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO0lBQ3JDLENBQUM7SUFFRCxJQUFXLE9BQU87UUFDaEIsTUFBTSxJQUFJLEtBQUssQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7SUFDckMsQ0FBQztJQUVELElBQVcsT0FBTztRQUNoQixNQUFNLElBQUksS0FBSyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztJQUNyQyxDQUFDO0lBRU0sb0JBQW9CO1FBQ3pCLE1BQU0sSUFBSSxLQUFLLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO0lBQ3JDLENBQUM7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGN4YXBpIGZyb20gJ0Bhd3MtY2RrL2N4LWFwaSc7XG5pbXBvcnQgKiBhcyBjaGFsayBmcm9tICdjaGFsayc7XG5pbXBvcnQgeyBJU0RLIH0gZnJvbSAnLi9hd3MtYXV0aCc7XG5pbXBvcnQgeyBCT09UU1RSQVBfVkVSU0lPTl9PVVRQVVQsIEJVQ0tFVF9ET01BSU5fTkFNRV9PVVRQVVQsIEJVQ0tFVF9OQU1FX09VVFBVVCwgQk9PVFNUUkFQX1ZBUklBTlRfUEFSQU1FVEVSLCBERUZBVUxUX0JPT1RTVFJBUF9WQVJJQU5UIH0gZnJvbSAnLi9ib290c3RyYXAvYm9vdHN0cmFwLXByb3BzJztcbmltcG9ydCB7IHN0YWJpbGl6ZVN0YWNrLCBDbG91ZEZvcm1hdGlvblN0YWNrIH0gZnJvbSAnLi91dGlsL2Nsb3VkZm9ybWF0aW9uJztcbmltcG9ydCB7IGRlYnVnIH0gZnJvbSAnLi4vbG9nZ2luZyc7XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX1RPT0xLSVRfU1RBQ0tfTkFNRSA9ICdDREtUb29sa2l0JztcblxuLyoqXG4gKiBJbmZvcm1hdGlvbiBvbiB0aGUgQm9vdHN0cmFwIHN0YWNrIG9mIHRoZSBlbnZpcm9ubWVudCB3ZSdyZSBkZXBsb3lpbmcgdG8uXG4gKlxuICogVGhpcyBjbGFzcyBzZXJ2ZXMgdG86XG4gKlxuICogLSBJbnNwZWN0IHRoZSBib290c3RyYXAgc3RhY2ssIGFuZCByZXR1cm4gdmFyaW91cyBwcm9wZXJ0aWVzIG9mIGl0IGZvciBzdWNjZXNzZnVsXG4gKiAgIGFzc2V0IGRlcGxveW1lbnQgKGluIGNhc2Ugb2YgbGVnYWN5LXN5bnRoZXNpemVkIHN0YWNrcykuXG4gKiAtIFZhbGlkYXRlIHRoZSB2ZXJzaW9uIG9mIHRoZSB0YXJnZXQgZW52aXJvbm1lbnQsIGFuZCBub3RoaW5nIGVsc2UgKGluIGNhc2Ugb2ZcbiAqICAgZGVmYXVsdC1zeW50aGVzaXplZCBzdGFja3MpLlxuICpcbiAqIEFuIG9iamVjdCBvZiB0aGlzIHR5cGUgbWlnaHQgcmVwcmVzZW50IGEgYm9vdHN0cmFwIHN0YWNrIHRoYXQgY291bGQgbm90IGJlIGZvdW5kLlxuICogVGhpcyBpcyBub3QgYW4gaXNzdWUgdW5sZXNzIGFueSBtZW1iZXJzIGFyZSB1c2VkIHRoYXQgcmVxdWlyZSB0aGUgYm9vdHN0cmFwIHN0YWNrXG4gKiB0byBoYXZlIGJlZW4gZm91bmQsIGluIHdoaWNoIGNhc2UgYW4gZXJyb3IgaXMgdGhyb3duIChkZWZhdWx0LXN5bnRoZXNpemVkIHN0YWNrc1xuICogc2hvdWxkIG5ldmVyIHJ1biBpbnRvIHRoaXMgYXMgdGhleSBkb24ndCBuZWVkIGluZm9ybWF0aW9uIGZyb20gdGhlIGJvb3RzdHJhcFxuICogc3RhY2ssIGFsbCBpbmZvcm1hdGlvbiBpcyBhbHJlYWR5IGVuY29kZWQgaW50byB0aGUgQ2xvdWQgQXNzZW1ibHkgTWFuaWZlc3QpLlxuICpcbiAqIE5ldmVydGhlbGVzcywgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcyBleGlzdHMgdG8gc2VydmUgYXMgYSBjYWNoZSBmb3IgU1NNXG4gKiBwYXJhbWV0ZXIgbG9va3VwcyAob3RoZXJ3aXNlLCB0aGUgXCJib290c3RyYXAgc3RhY2sgdmVyc2lvblwiIHBhcmFtZXRlciB3b3VsZFxuICogbmVlZCB0byBiZSByZWFkIHJlcGVhdGVkbHkpLlxuICpcbiAqIENhbGxlZCBcIlRvb2xraXRJbmZvXCIgZm9yIGhpc3RvcmljYWwgcmVhc29ucy5cbiAqXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBUb29sa2l0SW5mbyB7XG4gIHB1YmxpYyBzdGF0aWMgZGV0ZXJtaW5lTmFtZShvdmVycmlkZU5hbWU/OiBzdHJpbmcpIHtcbiAgICByZXR1cm4gb3ZlcnJpZGVOYW1lID8/IERFRkFVTFRfVE9PTEtJVF9TVEFDS19OQU1FO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBhc3luYyBsb29rdXAoZW52aXJvbm1lbnQ6IGN4YXBpLkVudmlyb25tZW50LCBzZGs6IElTREssIHN0YWNrTmFtZTogc3RyaW5nIHwgdW5kZWZpbmVkKTogUHJvbWlzZTxUb29sa2l0SW5mbz4ge1xuICAgIGNvbnN0IGNmbiA9IHNkay5jbG91ZEZvcm1hdGlvbigpO1xuICAgIHN0YWNrTmFtZSA9IFRvb2xraXRJbmZvLmRldGVybWluZU5hbWUoc3RhY2tOYW1lKTtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RhY2sgPSBhd2FpdCBzdGFiaWxpemVTdGFjayhjZm4sIHN0YWNrTmFtZSk7XG4gICAgICBpZiAoIXN0YWNrKSB7XG4gICAgICAgIGRlYnVnKCdUaGUgZW52aXJvbm1lbnQgJXMgZG9lc25cXCd0IGhhdmUgdGhlIENESyB0b29sa2l0IHN0YWNrICglcykgaW5zdGFsbGVkLiBVc2UgJXMgdG8gc2V0dXAgeW91ciBlbnZpcm9ubWVudCBmb3IgdXNlIHdpdGggdGhlIHRvb2xraXQuJyxcbiAgICAgICAgICBlbnZpcm9ubWVudC5uYW1lLCBzdGFja05hbWUsIGNoYWxrLmJsdWUoYGNkayBib290c3RyYXAgXCIke2Vudmlyb25tZW50Lm5hbWV9XCJgKSk7XG4gICAgICAgIHJldHVybiBUb29sa2l0SW5mby5ib290c3RyYXBTdGFja05vdEZvdW5kSW5mbyhzdGFja05hbWUpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YWNrLnN0YWNrU3RhdHVzLmlzQ3JlYXRpb25GYWlsdXJlKSB7XG4gICAgICAgIC8vIFRyZWF0IGEgXCJmYWlsZWQgdG8gY3JlYXRlXCIgYm9vdHN0cmFwIHN0YWNrIGFzIGFuIGFic2VudCBvbmUuXG4gICAgICAgIGRlYnVnKCdUaGUgZW52aXJvbm1lbnQgJXMgaGFzIGEgQ0RLIHRvb2xraXQgc3RhY2sgKCVzKSB0aGF0IGZhaWxlZCB0byBjcmVhdGUuIFVzZSAlcyB0byB0cnkgcHJvdmlzaW9uaW5nIGl0IGFnYWluLicsXG4gICAgICAgICAgZW52aXJvbm1lbnQubmFtZSwgc3RhY2tOYW1lLCBjaGFsay5ibHVlKGBjZGsgYm9vdHN0cmFwIFwiJHtlbnZpcm9ubWVudC5uYW1lfVwiYCkpO1xuICAgICAgICByZXR1cm4gVG9vbGtpdEluZm8uYm9vdHN0cmFwU3RhY2tOb3RGb3VuZEluZm8oc3RhY2tOYW1lKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBFeGlzdGluZ1Rvb2xraXRJbmZvKHN0YWNrKTtcbiAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgIHJldHVybiBUb29sa2l0SW5mby5ib290c3RyYXBTdGFja0xvb2t1cEVycm9yKHN0YWNrTmFtZSwgZSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHN0YXRpYyBmcm9tU3RhY2soc3RhY2s6IENsb3VkRm9ybWF0aW9uU3RhY2spOiBUb29sa2l0SW5mbyB7XG4gICAgcmV0dXJuIG5ldyBFeGlzdGluZ1Rvb2xraXRJbmZvKHN0YWNrKTtcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgYm9vdHN0cmFwU3RhY2tOb3RGb3VuZEluZm8oc3RhY2tOYW1lOiBzdHJpbmcpOiBUb29sa2l0SW5mbyB7XG4gICAgcmV0dXJuIG5ldyBCb290c3RyYXBTdGFja05vdEZvdW5kSW5mbyhzdGFja05hbWUsICdUaGlzIGRlcGxveW1lbnQgcmVxdWlyZXMgYSBib290c3RyYXAgc3RhY2sgd2l0aCBhIGtub3duIG5hbWU7IHBhc3MgXFwnLS10b29sa2l0LXN0YWNrLW5hbWVcXCcgb3Igc3dpdGNoIHRvIHVzaW5nIHRoZSBcXCdEZWZhdWx0U3RhY2tTeW50aGVzaXplclxcJyAoc2VlIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9jZGsvbGF0ZXN0L2d1aWRlL2Jvb3RzdHJhcHBpbmcuaHRtbCknKTtcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgYm9vdHN0cmFwU3RhY2tMb29rdXBFcnJvcihzdGFja05hbWU6IHN0cmluZywgZTogRXJyb3IpOiBUb29sa2l0SW5mbyB7XG4gICAgcmV0dXJuIG5ldyBCb290c3RyYXBTdGFja05vdEZvdW5kSW5mbyhzdGFja05hbWUsIGBUaGlzIGRlcGxveW1lbnQgcmVxdWlyZXMgYSBib290c3RyYXAgc3RhY2sgd2l0aCBhIGtub3duIG5hbWUsIGJ1dCBkdXJpbmcgaXRzIGxvb2t1cCB0aGUgZm9sbG93aW5nIGVycm9yIG9jY3VycmVkOiAke2V9OyBwYXNzIFxcJy0tdG9vbGtpdC1zdGFjay1uYW1lXFwnIG9yIHN3aXRjaCB0byB1c2luZyB0aGUgXFwnRGVmYXVsdFN0YWNrU3ludGhlc2l6ZXJcXCcgKHNlZSBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vY2RrL2xhdGVzdC9ndWlkZS9ib290c3RyYXBwaW5nLmh0bWwpYCk7XG4gIH1cblxuICBwdWJsaWMgYWJzdHJhY3QgcmVhZG9ubHkgZm91bmQ6IGJvb2xlYW47XG4gIHB1YmxpYyBhYnN0cmFjdCByZWFkb25seSBidWNrZXRVcmw6IHN0cmluZztcbiAgcHVibGljIGFic3RyYWN0IHJlYWRvbmx5IGJ1Y2tldE5hbWU6IHN0cmluZztcbiAgcHVibGljIGFic3RyYWN0IHJlYWRvbmx5IHZlcnNpb246IG51bWJlcjtcbiAgcHVibGljIGFic3RyYWN0IHJlYWRvbmx5IHZhcmlhbnQ6IHN0cmluZztcbiAgcHVibGljIGFic3RyYWN0IHJlYWRvbmx5IGJvb3RzdHJhcFN0YWNrOiBDbG91ZEZvcm1hdGlvblN0YWNrO1xuICBwdWJsaWMgYWJzdHJhY3QgcmVhZG9ubHkgc3RhY2tOYW1lOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5lZCB3aGVuIGEgYm9vdHN0cmFwIHN0YWNrIGlzIGZvdW5kXG4gKi9cbmNsYXNzIEV4aXN0aW5nVG9vbGtpdEluZm8gZXh0ZW5kcyBUb29sa2l0SW5mbyB7XG4gIHB1YmxpYyByZWFkb25seSBmb3VuZCA9IHRydWU7XG5cbiAgY29uc3RydWN0b3IocHVibGljIHJlYWRvbmx5IGJvb3RzdHJhcFN0YWNrOiBDbG91ZEZvcm1hdGlvblN0YWNrKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgYnVja2V0VXJsKCkge1xuICAgIHJldHVybiBgaHR0cHM6Ly8ke3RoaXMucmVxdWlyZU91dHB1dChCVUNLRVRfRE9NQUlOX05BTUVfT1VUUFVUKX1gO1xuICB9XG5cbiAgcHVibGljIGdldCBidWNrZXROYW1lKCkge1xuICAgIHJldHVybiB0aGlzLnJlcXVpcmVPdXRwdXQoQlVDS0VUX05BTUVfT1VUUFVUKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgdmVyc2lvbigpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodGhpcy5ib290c3RyYXBTdGFjay5vdXRwdXRzW0JPT1RTVFJBUF9WRVJTSU9OX09VVFBVVF0gPz8gJzAnLCAxMCk7XG4gIH1cblxuICBwdWJsaWMgZ2V0IHZhcmlhbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYm9vdHN0cmFwU3RhY2sucGFyYW1ldGVyc1tCT09UU1RSQVBfVkFSSUFOVF9QQVJBTUVURVJdID8/IERFRkFVTFRfQk9PVFNUUkFQX1ZBUklBTlQ7XG4gIH1cblxuICBwdWJsaWMgZ2V0IHBhcmFtZXRlcnMoKTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB7XG4gICAgcmV0dXJuIHRoaXMuYm9vdHN0cmFwU3RhY2sucGFyYW1ldGVycyA/PyB7fTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgdGVybWluYXRpb25Qcm90ZWN0aW9uKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmJvb3RzdHJhcFN0YWNrLnRlcm1pbmF0aW9uUHJvdGVjdGlvbiA/PyBmYWxzZTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgc3RhY2tOYW1lKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuYm9vdHN0cmFwU3RhY2suc3RhY2tOYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIFByZXBhcmUgYW4gRUNSIHJlcG9zaXRvcnkgZm9yIHVwbG9hZGluZyB0byB1c2luZyBEb2NrZXJcbiAgICpcbiAgICovXG4gIHByaXZhdGUgcmVxdWlyZU91dHB1dChvdXRwdXQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgaWYgKCEob3V0cHV0IGluIHRoaXMuYm9vdHN0cmFwU3RhY2sub3V0cHV0cykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIENESyB0b29sa2l0IHN0YWNrICgke3RoaXMuYm9vdHN0cmFwU3RhY2suc3RhY2tOYW1lfSkgZG9lcyBub3QgaGF2ZSBhbiBvdXRwdXQgbmFtZWQgJHtvdXRwdXR9LiBVc2UgJ2NkayBib290c3RyYXAnIHRvIGNvcnJlY3QgdGhpcy5gKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYm9vdHN0cmFwU3RhY2sub3V0cHV0c1tvdXRwdXRdO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJuZWQgd2hlbiBhIGJvb3RzdHJhcCBzdGFjayBjb3VsZCBub3QgYmUgZm91bmRcbiAqXG4gKiBUaGlzIGlzIG5vdCBhbiBlcnJvciBpbiBwcmluY2lwbGUsIFVOVElMIG9uZSBvZiB0aGUgbWVtYmVycyBpcyBjYWxsZWQgdGhhdCByZXF1aXJlc1xuICogdGhlIGJvb3RzdHJhcCBzdGFjayB0byBoYXZlIGJlZW4gZm91bmQsIGluIHdoaWNoIGNhc2UgdGhlIGxvb2t1cCBlcnJvciBpcyBzdGlsbCB0aHJvd25cbiAqIGJlbGF0ZWRseS5cbiAqXG4gKiBUaGUgZXJyb3JzIGJlbG93IHNlcnZlIGFzIGEgbGFzdCBzdG9wLWdhcCBtZXNzYWdlLS1ub3JtYWxseSBjYWxsaW5nIGNvZGUgc2hvdWxkIGhhdmVcbiAqIGNoZWNrZWQgYHRvb2xraXQuZm91bmRgIGFuZCBwcm9kdWNlZCBhbiBhcHByb3ByaWF0ZSBlcnJvciBtZXNzYWdlLlxuICovXG5jbGFzcyBCb290c3RyYXBTdGFja05vdEZvdW5kSW5mbyBleHRlbmRzIFRvb2xraXRJbmZvIHtcbiAgcHVibGljIHJlYWRvbmx5IGZvdW5kID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IocHVibGljIHJlYWRvbmx5IHN0YWNrTmFtZTogc3RyaW5nLCBwcml2YXRlIHJlYWRvbmx5IGVycm9yTWVzc2FnZTogc3RyaW5nKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgYm9vdHN0cmFwU3RhY2soKTogQ2xvdWRGb3JtYXRpb25TdGFjayB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHRoaXMuZXJyb3JNZXNzYWdlKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgYnVja2V0VXJsKCk6IHN0cmluZyB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHRoaXMuZXJyb3JNZXNzYWdlKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgYnVja2V0TmFtZSgpOiBzdHJpbmcge1xuICAgIHRocm93IG5ldyBFcnJvcih0aGlzLmVycm9yTWVzc2FnZSk7XG4gIH1cblxuICBwdWJsaWMgZ2V0IHZlcnNpb24oKTogbnVtYmVyIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy5lcnJvck1lc3NhZ2UpO1xuICB9XG5cbiAgcHVibGljIGdldCB2YXJpYW50KCk6IHN0cmluZyB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHRoaXMuZXJyb3JNZXNzYWdlKTtcbiAgfVxuXG4gIHB1YmxpYyBwcmVwYXJlRWNyUmVwb3NpdG9yeSgpOiBQcm9taXNlPEVjclJlcG9zaXRvcnlJbmZvPiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHRoaXMuZXJyb3JNZXNzYWdlKTtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVjclJlcG9zaXRvcnlJbmZvIHtcbiAgcmVwb3NpdG9yeVVyaTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVjckNyZWRlbnRpYWxzIHtcbiAgdXNlcm5hbWU6IHN0cmluZztcbiAgcGFzc3dvcmQ6IHN0cmluZztcbiAgZW5kcG9pbnQ6IHN0cmluZztcbn1cbiJdfQ==