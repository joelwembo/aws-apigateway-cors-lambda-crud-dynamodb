"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tryHotswapDeployment = void 0;
const cfn_diff = require("@aws-cdk/cloudformation-diff");
const chalk = require("chalk");
const aws_auth_1 = require("./aws-auth");
const evaluate_cloudformation_template_1 = require("./evaluate-cloudformation-template");
const appsync_mapping_templates_1 = require("./hotswap/appsync-mapping-templates");
const code_build_projects_1 = require("./hotswap/code-build-projects");
const common_1 = require("./hotswap/common");
const ecs_services_1 = require("./hotswap/ecs-services");
const lambda_functions_1 = require("./hotswap/lambda-functions");
const s3_bucket_deployments_1 = require("./hotswap/s3-bucket-deployments");
const stepfunctions_state_machines_1 = require("./hotswap/stepfunctions-state-machines");
const nested_stack_helpers_1 = require("./nested-stack-helpers");
const logging_1 = require("../logging");
const RESOURCE_DETECTORS = {
    // Lambda
    'AWS::Lambda::Function': lambda_functions_1.isHotswappableLambdaFunctionChange,
    'AWS::Lambda::Version': lambda_functions_1.isHotswappableLambdaFunctionChange,
    'AWS::Lambda::Alias': lambda_functions_1.isHotswappableLambdaFunctionChange,
    // AppSync
    'AWS::AppSync::Resolver': appsync_mapping_templates_1.isHotswappableAppSyncChange,
    'AWS::AppSync::FunctionConfiguration': appsync_mapping_templates_1.isHotswappableAppSyncChange,
    'AWS::AppSync::GraphQLSchema': appsync_mapping_templates_1.isHotswappableAppSyncChange,
    'AWS::AppSync::ApiKey': appsync_mapping_templates_1.isHotswappableAppSyncChange,
    'AWS::ECS::TaskDefinition': ecs_services_1.isHotswappableEcsServiceChange,
    'AWS::CodeBuild::Project': code_build_projects_1.isHotswappableCodeBuildProjectChange,
    'AWS::StepFunctions::StateMachine': stepfunctions_state_machines_1.isHotswappableStateMachineChange,
    'Custom::CDKBucketDeployment': s3_bucket_deployments_1.isHotswappableS3BucketDeploymentChange,
    'AWS::IAM::Policy': async (logicalId, change, evaluateCfnTemplate) => {
        // If the policy is for a S3BucketDeploymentChange, we can ignore the change
        if (await (0, s3_bucket_deployments_1.skipChangeForS3DeployCustomResourcePolicy)(logicalId, change, evaluateCfnTemplate)) {
            return [];
        }
        return (0, common_1.reportNonHotswappableResource)(change, 'This resource type is not supported for hotswap deployments');
    },
    'AWS::CDK::Metadata': async () => [],
};
/**
 * Perform a hotswap deployment,
 * short-circuiting CloudFormation if possible.
 * If it's not possible to short-circuit the deployment
 * (because the CDK Stack contains changes that cannot be deployed without CloudFormation),
 * returns `undefined`.
 */
async function tryHotswapDeployment(sdkProvider, assetParams, cloudFormationStack, stackArtifact, hotswapMode) {
    // resolve the environment, so we can substitute things like AWS::Region in CFN expressions
    const resolvedEnv = await sdkProvider.resolveEnvironment(stackArtifact.environment);
    // create a new SDK using the CLI credentials, because the default one will not work for new-style synthesis -
    // it assumes the bootstrap deploy Role, which doesn't have permissions to update Lambda functions
    const sdk = (await sdkProvider.forEnvironment(resolvedEnv, aws_auth_1.Mode.ForWriting)).sdk;
    const currentTemplate = await (0, nested_stack_helpers_1.loadCurrentTemplateWithNestedStacks)(stackArtifact, sdk);
    const evaluateCfnTemplate = new evaluate_cloudformation_template_1.EvaluateCloudFormationTemplate({
        stackName: stackArtifact.stackName,
        template: stackArtifact.template,
        parameters: assetParams,
        account: resolvedEnv.account,
        region: resolvedEnv.region,
        partition: (await sdk.currentAccount()).partition,
        urlSuffix: (region) => sdk.getEndpointSuffix(region),
        sdk,
        nestedStackNames: currentTemplate.nestedStackNames,
    });
    const stackChanges = cfn_diff.fullDiff(currentTemplate.deployedTemplate, stackArtifact.template);
    const { hotswappableChanges, nonHotswappableChanges } = await classifyResourceChanges(stackChanges, evaluateCfnTemplate, sdk, currentTemplate.nestedStackNames);
    logNonHotswappableChanges(nonHotswappableChanges, hotswapMode);
    // preserve classic hotswap behavior
    if (hotswapMode === common_1.HotswapMode.FALL_BACK) {
        if (nonHotswappableChanges.length > 0) {
            return undefined;
        }
    }
    // apply the short-circuitable changes
    await applyAllHotswappableChanges(sdk, hotswappableChanges);
    return { noOp: hotswappableChanges.length === 0, stackArn: cloudFormationStack.stackId, outputs: cloudFormationStack.outputs };
}
exports.tryHotswapDeployment = tryHotswapDeployment;
/**
 * Classifies all changes to all resources as either hotswappable or not.
 * Metadata changes are excluded from the list of (non)hotswappable resources.
 */
async function classifyResourceChanges(stackChanges, evaluateCfnTemplate, sdk, nestedStackNames) {
    const resourceDifferences = getStackResourceDifferences(stackChanges);
    const promises = [];
    const hotswappableResources = new Array();
    const nonHotswappableResources = new Array();
    for (const logicalId of Object.keys(stackChanges.outputs.changes)) {
        nonHotswappableResources.push({
            hotswappable: false,
            reason: 'output was changed',
            logicalId,
            rejectedChanges: [],
            resourceType: 'Stack Output',
        });
    }
    // gather the results of the detector functions
    for (const [logicalId, change] of Object.entries(resourceDifferences)) {
        if (change.newValue?.Type === 'AWS::CloudFormation::Stack' && change.oldValue?.Type === 'AWS::CloudFormation::Stack') {
            const nestedHotswappableResources = await findNestedHotswappableChanges(logicalId, change, nestedStackNames, evaluateCfnTemplate, sdk);
            hotswappableResources.push(...nestedHotswappableResources.hotswappableChanges);
            nonHotswappableResources.push(...nestedHotswappableResources.nonHotswappableChanges);
            continue;
        }
        const hotswappableChangeCandidate = isCandidateForHotswapping(change, logicalId);
        // we don't need to run this through the detector functions, we can already judge this
        if ('hotswappable' in hotswappableChangeCandidate) {
            if (!hotswappableChangeCandidate.hotswappable) {
                nonHotswappableResources.push(hotswappableChangeCandidate);
            }
            continue;
        }
        const resourceType = hotswappableChangeCandidate.newValue.Type;
        if (resourceType in RESOURCE_DETECTORS) {
            // run detector functions lazily to prevent unhandled promise rejections
            promises.push(() => RESOURCE_DETECTORS[resourceType](logicalId, hotswappableChangeCandidate, evaluateCfnTemplate));
        }
        else {
            (0, common_1.reportNonHotswappableChange)(nonHotswappableResources, hotswappableChangeCandidate, undefined, 'This resource type is not supported for hotswap deployments');
        }
    }
    // resolve all detector results
    const changesDetectionResults = [];
    for (const detectorResultPromises of promises) {
        const hotswapDetectionResults = await Promise.all(await detectorResultPromises());
        changesDetectionResults.push(hotswapDetectionResults);
    }
    for (const resourceDetectionResults of changesDetectionResults) {
        for (const propertyResult of resourceDetectionResults) {
            propertyResult.hotswappable ?
                hotswappableResources.push(propertyResult) :
                nonHotswappableResources.push(propertyResult);
        }
    }
    return {
        hotswappableChanges: hotswappableResources,
        nonHotswappableChanges: nonHotswappableResources,
    };
}
/**
 * Returns all changes to resources in the given Stack.
 *
 * @param stackChanges the collection of all changes to a given Stack
 */
function getStackResourceDifferences(stackChanges) {
    // we need to collapse logical ID rename changes into one change,
    // as they are represented in stackChanges as a pair of two changes: one addition and one removal
    const allResourceChanges = stackChanges.resources.changes;
    const allRemovalChanges = filterDict(allResourceChanges, resChange => resChange.isRemoval);
    const allNonRemovalChanges = filterDict(allResourceChanges, resChange => !resChange.isRemoval);
    for (const [logId, nonRemovalChange] of Object.entries(allNonRemovalChanges)) {
        if (nonRemovalChange.isAddition) {
            const addChange = nonRemovalChange;
            // search for an identical removal change
            const identicalRemovalChange = Object.entries(allRemovalChanges).find(([_, remChange]) => {
                return changesAreForSameResource(remChange, addChange);
            });
            // if we found one, then this means this is a rename change
            if (identicalRemovalChange) {
                const [removedLogId, removedResourceChange] = identicalRemovalChange;
                allNonRemovalChanges[logId] = makeRenameDifference(removedResourceChange, addChange);
                // delete the removal change that forms the rename pair
                delete allRemovalChanges[removedLogId];
            }
        }
    }
    // the final result are all of the remaining removal changes,
    // plus all of the non-removal changes
    // (we saved the rename changes in that object already)
    return {
        ...allRemovalChanges,
        ...allNonRemovalChanges,
    };
}
/** Filters an object with string keys based on whether the callback returns 'true' for the given value in the object. */
function filterDict(dict, func) {
    return Object.entries(dict).reduce((acc, [key, t]) => {
        if (func(t)) {
            acc[key] = t;
        }
        return acc;
    }, {});
}
/** Finds any hotswappable changes in all nested stacks. */
async function findNestedHotswappableChanges(logicalId, change, nestedStackNames, evaluateCfnTemplate, sdk) {
    const nestedStackName = nestedStackNames[logicalId].nestedStackPhysicalName;
    if (!nestedStackName) {
        return {
            hotswappableChanges: [],
            nonHotswappableChanges: [{
                    hotswappable: false,
                    logicalId,
                    reason: `physical name for AWS::CloudFormation::Stack '${logicalId}' could not be found in CloudFormation, so this is a newly created nested stack and cannot be hotswapped`,
                    rejectedChanges: [],
                    resourceType: 'AWS::CloudFormation::Stack',
                }],
        };
    }
    const evaluateNestedCfnTemplate = await evaluateCfnTemplate.createNestedEvaluateCloudFormationTemplate(nestedStackName, change.newValue?.Properties?.NestedTemplate, change.newValue?.Properties?.Parameters);
    const nestedDiff = cfn_diff.fullDiff(change.oldValue?.Properties?.NestedTemplate, change.newValue?.Properties?.NestedTemplate);
    return classifyResourceChanges(nestedDiff, evaluateNestedCfnTemplate, sdk, nestedStackNames[logicalId].nestedChildStackNames);
}
/** Returns 'true' if a pair of changes is for the same resource. */
function changesAreForSameResource(oldChange, newChange) {
    return oldChange.oldResourceType === newChange.newResourceType &&
        // this isn't great, but I don't want to bring in something like underscore just for this comparison
        JSON.stringify(oldChange.oldProperties) === JSON.stringify(newChange.newProperties);
}
function makeRenameDifference(remChange, addChange) {
    return new cfn_diff.ResourceDifference(
    // we have to fill in the old value, because otherwise this will be classified as a non-hotswappable change
    remChange.oldValue, addChange.newValue, {
        resourceType: {
            oldType: remChange.oldResourceType,
            newType: addChange.newResourceType,
        },
        propertyDiffs: addChange.propertyDiffs,
        otherDiffs: addChange.otherDiffs,
    });
}
/**
 * Returns a `HotswappableChangeCandidate` if the change is hotswappable
 * Returns an empty `HotswappableChange` if the change is to CDK::Metadata
 * Returns a `NonHotswappableChange` if the change is not hotswappable
 */
function isCandidateForHotswapping(change, logicalId) {
    // a resource has been removed OR a resource has been added; we can't short-circuit that change
    if (!change.oldValue) {
        return {
            hotswappable: false,
            resourceType: change.newValue.Type,
            logicalId,
            rejectedChanges: [],
            reason: `resource '${logicalId}' was created by this deployment`,
        };
    }
    else if (!change.newValue) {
        return {
            hotswappable: false,
            resourceType: change.oldValue.Type,
            logicalId,
            rejectedChanges: [],
            reason: `resource '${logicalId}' was destroyed by this deployment`,
        };
    }
    // a resource has had its type changed
    if (change.newValue?.Type !== change.oldValue?.Type) {
        return {
            hotswappable: false,
            resourceType: change.newValue?.Type,
            logicalId,
            rejectedChanges: [],
            reason: `resource '${logicalId}' had its type changed from '${change.oldValue?.Type}' to '${change.newValue?.Type}'`,
        };
    }
    return {
        logicalId,
        oldValue: change.oldValue,
        newValue: change.newValue,
        propertyUpdates: change.propertyUpdates,
    };
}
async function applyAllHotswappableChanges(sdk, hotswappableChanges) {
    if (hotswappableChanges.length > 0) {
        (0, logging_1.print)(`\n${common_1.ICON} hotswapping resources:`);
    }
    return Promise.all(hotswappableChanges.map(hotswapOperation => {
        return applyHotswappableChange(sdk, hotswapOperation);
    }));
}
async function applyHotswappableChange(sdk, hotswapOperation) {
    // note the type of service that was successfully hotswapped in the User-Agent
    const customUserAgent = `cdk-hotswap/success-${hotswapOperation.service}`;
    sdk.appendCustomUserAgent(customUserAgent);
    for (const name of hotswapOperation.resourceNames) {
        (0, logging_1.print)(`   ${common_1.ICON} %s`, chalk.bold(name));
    }
    // if the SDK call fails, an error will be thrown by the SDK
    // and will prevent the green 'hotswapped!' text from being displayed
    await hotswapOperation.apply(sdk);
    for (const name of hotswapOperation.resourceNames) {
        (0, logging_1.print)(`${common_1.ICON} %s %s`, chalk.bold(name), chalk.green('hotswapped!'));
    }
    sdk.removeCustomUserAgent(customUserAgent);
}
function logNonHotswappableChanges(nonHotswappableChanges, hotswapMode) {
    if (nonHotswappableChanges.length === 0) {
        return;
    }
    /**
     * EKS Services can have a task definition that doesn't refer to the task definition being updated.
     * We have to log this as a non-hotswappable change to the task definition, but when we do,
     * we wind up hotswapping the task definition and logging it as a non-hotswappable change.
     *
     * This logic prevents us from logging that change as non-hotswappable when we hotswap it.
     */
    if (hotswapMode === common_1.HotswapMode.HOTSWAP_ONLY) {
        nonHotswappableChanges = nonHotswappableChanges.filter((change) => change.hotswapOnlyVisible === true);
        if (nonHotswappableChanges.length === 0) {
            return;
        }
    }
    if (hotswapMode === common_1.HotswapMode.HOTSWAP_ONLY) {
        (0, logging_1.print)('\n%s %s', chalk.red('⚠️'), chalk.red('The following non-hotswappable changes were found. To reconcile these using CloudFormation, specify --hotswap-fallback'));
    }
    else {
        (0, logging_1.print)('\n%s %s', chalk.red('⚠️'), chalk.red('The following non-hotswappable changes were found:'));
    }
    for (const change of nonHotswappableChanges) {
        change.rejectedChanges.length > 0 ?
            (0, logging_1.print)('    logicalID: %s, type: %s, rejected changes: %s, reason: %s', chalk.bold(change.logicalId), chalk.bold(change.resourceType), chalk.bold(change.rejectedChanges), chalk.red(change.reason)) :
            (0, logging_1.print)('    logicalID: %s, type: %s, reason: %s', chalk.bold(change.logicalId), chalk.bold(change.resourceType), chalk.red(change.reason));
    }
    (0, logging_1.print)(''); // newline
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaG90c3dhcC1kZXBsb3ltZW50cy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImhvdHN3YXAtZGVwbG95bWVudHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEseURBQXlEO0FBRXpELCtCQUErQjtBQUMvQix5Q0FBcUQ7QUFFckQseUZBQW9GO0FBQ3BGLG1GQUFrRjtBQUNsRix1RUFBcUY7QUFDckYsNkNBQXlPO0FBQ3pPLHlEQUF3RTtBQUN4RSxpRUFBZ0Y7QUFDaEYsMkVBQW9JO0FBQ3BJLHlGQUEwRjtBQUMxRixpRUFBK0Y7QUFFL0Ysd0NBQW1DO0FBTW5DLE1BQU0sa0JBQWtCLEdBQXVDO0lBQzdELFNBQVM7SUFDVCx1QkFBdUIsRUFBRSxxREFBa0M7SUFDM0Qsc0JBQXNCLEVBQUUscURBQWtDO0lBQzFELG9CQUFvQixFQUFFLHFEQUFrQztJQUV4RCxVQUFVO0lBQ1Ysd0JBQXdCLEVBQUUsdURBQTJCO0lBQ3JELHFDQUFxQyxFQUFFLHVEQUEyQjtJQUNsRSw2QkFBNkIsRUFBRSx1REFBMkI7SUFDMUQsc0JBQXNCLEVBQUUsdURBQTJCO0lBRW5ELDBCQUEwQixFQUFFLDZDQUE4QjtJQUMxRCx5QkFBeUIsRUFBRSwwREFBb0M7SUFDL0Qsa0NBQWtDLEVBQUUsK0RBQWdDO0lBQ3BFLDZCQUE2QixFQUFFLDhEQUFzQztJQUNyRSxrQkFBa0IsRUFBRSxLQUFLLEVBQ3ZCLFNBQWlCLEVBQUUsTUFBbUMsRUFBRSxtQkFBbUQsRUFDN0UsRUFBRTtRQUNoQyw0RUFBNEU7UUFDNUUsSUFBSSxNQUFNLElBQUEsaUVBQXlDLEVBQUMsU0FBUyxFQUFFLE1BQU0sRUFBRSxtQkFBbUIsQ0FBQyxFQUFFO1lBQzNGLE9BQU8sRUFBRSxDQUFDO1NBQ1g7UUFFRCxPQUFPLElBQUEsc0NBQTZCLEVBQUMsTUFBTSxFQUFFLDZEQUE2RCxDQUFDLENBQUM7SUFDOUcsQ0FBQztJQUVELG9CQUFvQixFQUFFLEtBQUssSUFBSSxFQUFFLENBQUMsRUFBRTtDQUNy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LGVBQUssRUFBQyxTQUFTLEVBQUUsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxLQUFLLENBQUMsR0FBRyxDQUFDLG9EQUFvRCxDQUFDLENBQUMsQ0FBQztLQUNwRztJQUVELEtBQUssTUFBTSxNQUFNLElBQUksc0JBQXNCLEVBQUU7UUFDM0MsTUFBTSxDQUFDLGVBQWUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDakMsSUFBQSxlQUFLLEVBQUMsK0RBQStELEVBQUUsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLEVBQUUsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLEVBQUUsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsZUFBZSxDQUFDLEVBQUUsS0FBSyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3JNLElBQUEsZUFBSyxFQUFDLHlDQUF5QyxFQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxFQUFFLEtBQUssQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7S0FDN0k7SUFFRCxJQUFBLGVBQUssRUFBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLFVBQVU7QUFDdkIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGNmbl9kaWZmIGZyb20gJ0Bhd3MtY2RrL2Nsb3VkZm9ybWF0aW9uLWRpZmYnO1xuaW1wb3J0ICogYXMgY3hhcGkgZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCAqIGFzIGNoYWxrIGZyb20gJ2NoYWxrJztcbmltcG9ydCB7IElTREssIE1vZGUsIFNka1Byb3ZpZGVyIH0gZnJvbSAnLi9hd3MtYXV0aCc7XG5pbXBvcnQgeyBEZXBsb3lTdGFja1Jlc3VsdCB9IGZyb20gJy4vZGVwbG95LXN0YWNrJztcbmltcG9ydCB7IEV2YWx1YXRlQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZSB9IGZyb20gJy4vZXZhbHVhdGUtY2xvdWRmb3JtYXRpb24tdGVtcGxhdGUnO1xuaW1wb3J0IHsgaXNIb3Rzd2FwcGFibGVBcHBTeW5jQ2hhbmdlIH0gZnJvbSAnLi9ob3Rzd2FwL2FwcHN5bmMtbWFwcGluZy10ZW1wbGF0ZXMnO1xuaW1wb3J0IHsgaXNIb3Rzd2FwcGFibGVDb2RlQnVpbGRQcm9qZWN0Q2hhbmdlIH0gZnJvbSAnLi9ob3Rzd2FwL2NvZGUtYnVpbGQtcHJvamVjdHMnO1xuaW1wb3J0IHsgSUNPTiwgQ2hhbmdlSG90c3dhcFJlc3VsdCwgSG90c3dhcE1vZGUsIEhvdHN3YXBwYWJsZUNoYW5nZSwgTm9uSG90c3dhcHBhYmxlQ2hhbmdlLCBIb3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUsIENsYXNzaWZpZWRSZXNvdXJjZUNoYW5nZXMsIHJlcG9ydE5vbkhvdHN3YXBwYWJsZUNoYW5nZSwgcmVwb3J0Tm9uSG90c3dhcHBhYmxlUmVzb3VyY2UgfSBmcm9tICcuL2hvdHN3YXAvY29tbW9uJztcbmltcG9ydCB7IGlzSG90c3dhcHBhYmxlRWNzU2VydmljZUNoYW5nZSB9IGZyb20gJy4vaG90c3dhcC9lY3Mtc2VydmljZXMnO1xuaW1wb3J0IHsgaXNIb3Rzd2FwcGFibGVMYW1iZGFGdW5jdGlvbkNoYW5nZSB9IGZyb20gJy4vaG90c3dhcC9sYW1iZGEtZnVuY3Rpb25zJztcbmltcG9ydCB7IHNraXBDaGFuZ2VGb3JTM0RlcGxveUN1c3RvbVJlc291cmNlUG9saWN5LCBpc0hvdHN3YXBwYWJsZVMzQnVja2V0RGVwbG95bWVudENoYW5nZSB9IGZyb20gJy4vaG90c3dhcC9zMy1idWNrZXQtZGVwbG95bWVudHMnO1xuaW1wb3J0IHsgaXNIb3Rzd2FwcGFibGVTdGF0ZU1hY2hpbmVDaGFuZ2UgfSBmcm9tICcuL2hvdHN3YXAvc3RlcGZ1bmN0aW9ucy1zdGF0ZS1tYWNoaW5lcyc7XG5pbXBvcnQgeyBsb2FkQ3VycmVudFRlbXBsYXRlV2l0aE5lc3RlZFN0YWNrcywgTmVzdGVkU3RhY2tOYW1lcyB9IGZyb20gJy4vbmVzdGVkLXN0YWNrLWhlbHBlcnMnO1xuaW1wb3J0IHsgQ2xvdWRGb3JtYXRpb25TdGFjayB9IGZyb20gJy4vdXRpbC9jbG91ZGZvcm1hdGlvbic7XG5pbXBvcnQgeyBwcmludCB9IGZyb20gJy4uL2xvZ2dpbmcnO1xuXG50eXBlIEhvdHN3YXBEZXRlY3RvciA9IChcbiAgbG9naWNhbElkOiBzdHJpbmcsIGNoYW5nZTogSG90c3dhcHBhYmxlQ2hhbmdlQ2FuZGlkYXRlLCBldmFsdWF0ZUNmblRlbXBsYXRlOiBFdmFsdWF0ZUNsb3VkRm9ybWF0aW9uVGVtcGxhdGVcbikgPT4gUHJvbWlzZTxDaGFuZ2VIb3Rzd2FwUmVzdWx0PjtcblxuY29uc3QgUkVTT1VSQ0VfREVURUNUT1JTOiB7IFtrZXk6IHN0cmluZ106IEhvdHN3YXBEZXRlY3RvciB9ID0ge1xuICAvLyBMYW1iZGFcbiAgJ0FXUzo6TGFtYmRhOjpGdW5jdGlvbic6IGlzSG90c3dhcHBhYmxlTGFtYmRhRnVuY3Rpb25DaGFuZ2UsXG4gICdBV1M6OkxhbWJkYTo6VmVyc2lvbic6IGlzSG90c3dhcHBhYmxlTGFtYmRhRnVuY3Rpb25DaGFuZ2UsXG4gICdBV1M6OkxhbWJkYTo6QWxpYXMnOiBpc0hvdHN3YXBwYWJsZUxhbWJkYUZ1bmN0aW9uQ2hhbmdlLFxuXG4gIC8vIEFwcFN5bmNcbiAgJ0FXUzo6QXBwU3luYzo6UmVzb2x2ZXInOiBpc0hvdHN3YXBwYWJsZUFwcFN5bmNDaGFuZ2UsXG4gICdBV1M6OkFwcFN5bmM6OkZ1bmN0aW9uQ29uZmlndXJhdGlvbic6IGlzSG90c3dhcHBhYmxlQXBwU3luY0NoYW5nZSxcbiAgJ0FXUzo6QXBwU3luYzo6R3JhcGhRTFNjaGVtYSc6IGlzSG90c3dhcHBhYmxlQXBwU3luY0NoYW5nZSxcbiAgJ0FXUzo6QXBwU3luYzo6QXBpS2V5JzogaXNIb3Rzd2FwcGFibGVBcHBTeW5jQ2hhbmdlLFxuXG4gICdBV1M6OkVDUzo6VGFza0RlZmluaXRpb24nOiBpc0hvdHN3YXBwYWJsZUVjc1NlcnZpY2VDaGFuZ2UsXG4gICdBV1M6OkNvZGVCdWlsZDo6UHJvamVjdCc6IGlzSG90c3dhcHBhYmxlQ29kZUJ1aWxkUHJvamVjdENoYW5nZSxcbiAgJ0FXUzo6U3RlcEZ1bmN0aW9uczo6U3RhdGVNYWNoaW5lJzogaXNIb3Rzd2FwcGFibGVTdGF0ZU1hY2hpbmVDaGFuZ2UsXG4gICdDdXN0b206OkNES0J1Y2tldERlcGxveW1lbnQnOiBpc0hvdHN3YXBwYWJsZVMzQnVja2V0RGVwbG95bWVudENoYW5nZSxcbiAgJ0FXUzo6SUFNOjpQb2xpY3knOiBhc3luYyAoXG4gICAgbG9naWNhbElkOiBzdHJpbmcsIGNoYW5nZTogSG90c3dhcHBhYmxlQ2hhbmdlQ2FuZGlkYXRlLCBldmFsdWF0ZUNmblRlbXBsYXRlOiBFdmFsdWF0ZUNsb3VkRm9ybWF0aW9uVGVtcGxhdGUsXG4gICk6IFByb21pc2U8Q2hhbmdlSG90c3dhcFJlc3VsdD4gPT4ge1xuICAgIC8vIElmIHRoZSBwb2xpY3kgaXMgZm9yIGEgUzNCdWNrZXREZXBsb3ltZW50Q2hhbmdlLCB3ZSBjYW4gaWdub3JlIHRoZSBjaGFuZ2VcbiAgICBpZiAoYXdhaXQgc2tpcENoYW5nZUZvclMzRGVwbG95Q3VzdG9tUmVzb3VyY2VQb2xpY3kobG9naWNhbElkLCBjaGFuZ2UsIGV2YWx1YXRlQ2ZuVGVtcGxhdGUpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcG9ydE5vbkhvdHN3YXBwYWJsZVJlc291cmNlKGNoYW5nZSwgJ1RoaXMgcmVzb3VyY2UgdHlwZSBpcyBub3Qgc3VwcG9ydGVkIGZvciBob3Rzd2FwIGRlcGxveW1lbnRzJyk7XG4gIH0sXG5cbiAgJ0FXUzo6Q0RLOjpNZXRhZGF0YSc6IGFzeW5jICgpID0+IFtdLFxufTtcblxuLyoqXG4gKiBQZXJmb3JtIGEgaG90c3dhcCBkZXBsb3ltZW50LFxuICogc2hvcnQtY2lyY3VpdGluZyBDbG91ZEZvcm1hdGlvbiBpZiBwb3NzaWJsZS5cbiAqIElmIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHNob3J0LWNpcmN1aXQgdGhlIGRlcGxveW1lbnRcbiAqIChiZWNhdXNlIHRoZSBDREsgU3RhY2sgY29udGFpbnMgY2hhbmdlcyB0aGF0IGNhbm5vdCBiZSBkZXBsb3llZCB3aXRob3V0IENsb3VkRm9ybWF0aW9uKSxcbiAqIHJldHVybnMgYHVuZGVmaW5lZGAuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB0cnlIb3Rzd2FwRGVwbG95bWVudChcbiAgc2RrUHJvdmlkZXI6IFNka1Byb3ZpZGVyLCBhc3NldFBhcmFtczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSxcbiAgY2xvdWRGb3JtYXRpb25TdGFjazogQ2xvdWRGb3JtYXRpb25TdGFjaywgc3RhY2tBcnRpZmFjdDogY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0LFxuICBob3Rzd2FwTW9kZTogSG90c3dhcE1vZGUsXG4pOiBQcm9taXNlPERlcGxveVN0YWNrUmVzdWx0IHwgdW5kZWZpbmVkPiB7XG4gIC8vIHJlc29sdmUgdGhlIGVudmlyb25tZW50LCBzbyB3ZSBjYW4gc3Vic3RpdHV0ZSB0aGluZ3MgbGlrZSBBV1M6OlJlZ2lvbiBpbiBDRk4gZXhwcmVzc2lvbnNcbiAgY29uc3QgcmVzb2x2ZWRFbnYgPSBhd2FpdCBzZGtQcm92aWRlci5yZXNvbHZlRW52aXJvbm1lbnQoc3RhY2tBcnRpZmFjdC5lbnZpcm9ubWVudCk7XG4gIC8vIGNyZWF0ZSBhIG5ldyBTREsgdXNpbmcgdGhlIENMSSBjcmVkZW50aWFscywgYmVjYXVzZSB0aGUgZGVmYXVsdCBvbmUgd2lsbCBub3Qgd29yayBmb3IgbmV3LXN0eWxlIHN5bnRoZXNpcyAtXG4gIC8vIGl0IGFzc3VtZXMgdGhlIGJvb3RzdHJhcCBkZXBsb3kgUm9sZSwgd2hpY2ggZG9lc24ndCBoYXZlIHBlcm1pc3Npb25zIHRvIHVwZGF0ZSBMYW1iZGEgZnVuY3Rpb25zXG4gIGNvbnN0IHNkayA9IChhd2FpdCBzZGtQcm92aWRlci5mb3JFbnZpcm9ubWVudChyZXNvbHZlZEVudiwgTW9kZS5Gb3JXcml0aW5nKSkuc2RrO1xuXG4gIGNvbnN0IGN1cnJlbnRUZW1wbGF0ZSA9IGF3YWl0IGxvYWRDdXJyZW50VGVtcGxhdGVXaXRoTmVzdGVkU3RhY2tzKHN0YWNrQXJ0aWZhY3QsIHNkayk7XG5cbiAgY29uc3QgZXZhbHVhdGVDZm5UZW1wbGF0ZSA9IG5ldyBFdmFsdWF0ZUNsb3VkRm9ybWF0aW9uVGVtcGxhdGUoe1xuICAgIHN0YWNrTmFtZTogc3RhY2tBcnRpZmFjdC5zdGFja05hbWUsXG4gICAgdGVtcGxhdGU6IHN0YWNrQXJ0aWZhY3QudGVtcGxhdGUsXG4gICAgcGFyYW1ldGVyczogYXNzZXRQYXJhbXMsXG4gICAgYWNjb3VudDogcmVzb2x2ZWRFbnYuYWNjb3VudCxcbiAgICByZWdpb246IHJlc29sdmVkRW52LnJlZ2lvbixcbiAgICBwYXJ0aXRpb246IChhd2FpdCBzZGsuY3VycmVudEFjY291bnQoKSkucGFydGl0aW9uLFxuICAgIHVybFN1ZmZpeDogKHJlZ2lvbikgPT4gc2RrLmdldEVuZHBvaW50U3VmZml4KHJlZ2lvbiksXG4gICAgc2RrLFxuICAgIG5lc3RlZFN0YWNrTmFtZXM6IGN1cnJlbnRUZW1wbGF0ZS5uZXN0ZWRTdGFja05hbWVzLFxuICB9KTtcblxuICBjb25zdCBzdGFja0NoYW5nZXMgPSBjZm5fZGlmZi5mdWxsRGlmZihjdXJyZW50VGVtcGxhdGUuZGVwbG95ZWRUZW1wbGF0ZSwgc3RhY2tBcnRpZmFjdC50ZW1wbGF0ZSk7XG4gIGNvbnN0IHsgaG90c3dhcHBhYmxlQ2hhbmdlcywgbm9uSG90c3dhcHBhYmxlQ2hhbmdlcyB9ID0gYXdhaXQgY2xhc3NpZnlSZXNvdXJjZUNoYW5nZXMoXG4gICAgc3RhY2tDaGFuZ2VzLCBldmFsdWF0ZUNmblRlbXBsYXRlLCBzZGssIGN1cnJlbnRUZW1wbGF0ZS5uZXN0ZWRTdGFja05hbWVzLFxuICApO1xuXG4gIGxvZ05vbkhvdHN3YXBwYWJsZUNoYW5nZXMobm9uSG90c3dhcHBhYmxlQ2hhbmdlcywgaG90c3dhcE1vZGUpO1xuXG4gIC8vIHByZXNlcnZlIGNsYXNzaWMgaG90c3dhcCBiZWhhdmlvclxuICBpZiAoaG90c3dhcE1vZGUgPT09IEhvdHN3YXBNb2RlLkZBTExfQkFDSykge1xuICAgIGlmIChub25Ib3Rzd2FwcGFibGVDaGFuZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgLy8gYXBwbHkgdGhlIHNob3J0LWNpcmN1aXRhYmxlIGNoYW5nZXNcbiAgYXdhaXQgYXBwbHlBbGxIb3Rzd2FwcGFibGVDaGFuZ2VzKHNkaywgaG90c3dhcHBhYmxlQ2hhbmdlcyk7XG5cbiAgcmV0dXJuIHsgbm9PcDogaG90c3dhcHBhYmxlQ2hhbmdlcy5sZW5ndGggPT09IDAsIHN0YWNrQXJuOiBjbG91ZEZvcm1hdGlvblN0YWNrLnN0YWNrSWQsIG91dHB1dHM6IGNsb3VkRm9ybWF0aW9uU3RhY2sub3V0cHV0cyB9O1xufVxuXG4vKipcbiAqIENsYXNzaWZpZXMgYWxsIGNoYW5nZXMgdG8gYWxsIHJlc291cmNlcyBhcyBlaXRoZXIgaG90c3dhcHBhYmxlIG9yIG5vdC5cbiAqIE1ldGFkYXRhIGNoYW5nZXMgYXJlIGV4Y2x1ZGVkIGZyb20gdGhlIGxpc3Qgb2YgKG5vbilob3Rzd2FwcGFibGUgcmVzb3VyY2VzLlxuICovXG5hc3luYyBmdW5jdGlvbiBjbGFzc2lmeVJlc291cmNlQ2hhbmdlcyhcbiAgc3RhY2tDaGFuZ2VzOiBjZm5fZGlmZi5UZW1wbGF0ZURpZmYsXG4gIGV2YWx1YXRlQ2ZuVGVtcGxhdGU6IEV2YWx1YXRlQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZSxcbiAgc2RrOiBJU0RLLFxuICBuZXN0ZWRTdGFja05hbWVzOiB7IFtuZXN0ZWRTdGFja05hbWU6IHN0cmluZ106IE5lc3RlZFN0YWNrTmFtZXMgfSxcbik6IFByb21pc2U8Q2xhc3NpZmllZFJlc291cmNlQ2hhbmdlcz4ge1xuICBjb25zdCByZXNvdXJjZURpZmZlcmVuY2VzID0gZ2V0U3RhY2tSZXNvdXJjZURpZmZlcmVuY2VzKHN0YWNrQ2hhbmdlcyk7XG5cbiAgY29uc3QgcHJvbWlzZXM6IEFycmF5PCgpID0+IFByb21pc2U8Q2hhbmdlSG90c3dhcFJlc3VsdD4+ID0gW107XG4gIGNvbnN0IGhvdHN3YXBwYWJsZVJlc291cmNlcyA9IG5ldyBBcnJheTxIb3Rzd2FwcGFibGVDaGFuZ2U+KCk7XG4gIGNvbnN0IG5vbkhvdHN3YXBwYWJsZVJlc291cmNlcyA9IG5ldyBBcnJheTxOb25Ib3Rzd2FwcGFibGVDaGFuZ2U+KCk7XG4gIGZvciAoY29uc3QgbG9naWNhbElkIG9mIE9iamVjdC5rZXlzKHN0YWNrQ2hhbmdlcy5vdXRwdXRzLmNoYW5nZXMpKSB7XG4gICAgbm9uSG90c3dhcHBhYmxlUmVzb3VyY2VzLnB1c2goe1xuICAgICAgaG90c3dhcHBhYmxlOiBmYWxzZSxcbiAgICAgIHJlYXNvbjogJ291dHB1dCB3YXMgY2hhbmdlZCcsXG4gICAgICBsb2dpY2FsSWQsXG4gICAgICByZWplY3RlZENoYW5nZXM6IFtdLFxuICAgICAgcmVzb3VyY2VUeXBlOiAnU3RhY2sgT3V0cHV0JyxcbiAgICB9KTtcbiAgfVxuICAvLyBnYXRoZXIgdGhlIHJlc3VsdHMgb2YgdGhlIGRldGVjdG9yIGZ1bmN0aW9uc1xuICBmb3IgKGNvbnN0IFtsb2dpY2FsSWQsIGNoYW5nZV0gb2YgT2JqZWN0LmVudHJpZXMocmVzb3VyY2VEaWZmZXJlbmNlcykpIHtcbiAgICBpZiAoY2hhbmdlLm5ld1ZhbHVlPy5UeXBlID09PSAnQVdTOjpDbG91ZEZvcm1hdGlvbjo6U3RhY2snICYmIGNoYW5nZS5vbGRWYWx1ZT8uVHlwZSA9PT0gJ0FXUzo6Q2xvdWRGb3JtYXRpb246OlN0YWNrJykge1xuICAgICAgY29uc3QgbmVzdGVkSG90c3dhcHBhYmxlUmVzb3VyY2VzID0gYXdhaXQgZmluZE5lc3RlZEhvdHN3YXBwYWJsZUNoYW5nZXMobG9naWNhbElkLCBjaGFuZ2UsIG5lc3RlZFN0YWNrTmFtZXMsIGV2YWx1YXRlQ2ZuVGVtcGxhdGUsIHNkayk7XG4gICAgICBob3Rzd2FwcGFibGVSZXNvdXJjZXMucHVzaCguLi5uZXN0ZWRIb3Rzd2FwcGFibGVSZXNvdXJjZXMuaG90c3dhcHBhYmxlQ2hhbmdlcyk7XG4gICAgICBub25Ib3Rzd2FwcGFibGVSZXNvdXJjZXMucHVzaCguLi5uZXN0ZWRIb3Rzd2FwcGFibGVSZXNvdXJjZXMubm9uSG90c3dhcHBhYmxlQ2hhbmdlcyk7XG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IGhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZSA9IGlzQ2FuZGlkYXRlRm9ySG90c3dhcHBpbmcoY2hhbmdlLCBsb2dpY2FsSWQpO1xuICAgIC8vIHdlIGRvbid0IG5lZWQgdG8gcnVuIHRoaXMgdGhyb3VnaCB0aGUgZGV0ZWN0b3IgZnVuY3Rpb25zLCB3ZSBjYW4gYWxyZWFkeSBqdWRnZSB0aGlzXG4gICAgaWYgKCdob3Rzd2FwcGFibGUnIGluIGhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZSkge1xuICAgICAgaWYgKCFob3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUuaG90c3dhcHBhYmxlKSB7XG4gICAgICAgIG5vbkhvdHN3YXBwYWJsZVJlc291cmNlcy5wdXNoKGhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc291cmNlVHlwZTogc3RyaW5nID0gaG90c3dhcHBhYmxlQ2hhbmdlQ2FuZGlkYXRlLm5ld1ZhbHVlLlR5cGU7XG4gICAgaWYgKHJlc291cmNlVHlwZSBpbiBSRVNPVVJDRV9ERVRFQ1RPUlMpIHtcbiAgICAgIC8vIHJ1biBkZXRlY3RvciBmdW5jdGlvbnMgbGF6aWx5IHRvIHByZXZlbnQgdW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uc1xuICAgICAgcHJvbWlzZXMucHVzaCgoKSA9PiBSRVNPVVJDRV9ERVRFQ1RPUlNbcmVzb3VyY2VUeXBlXShsb2dpY2FsSWQsIGhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZSwgZXZhbHVhdGVDZm5UZW1wbGF0ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXBvcnROb25Ib3Rzd2FwcGFibGVDaGFuZ2Uobm9uSG90c3dhcHBhYmxlUmVzb3VyY2VzLCBob3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUsIHVuZGVmaW5lZCwgJ1RoaXMgcmVzb3VyY2UgdHlwZSBpcyBub3Qgc3VwcG9ydGVkIGZvciBob3Rzd2FwIGRlcGxveW1lbnRzJyk7XG4gICAgfVxuICB9XG5cbiAgLy8gcmVzb2x2ZSBhbGwgZGV0ZWN0b3IgcmVzdWx0c1xuICBjb25zdCBjaGFuZ2VzRGV0ZWN0aW9uUmVzdWx0czogQXJyYXk8Q2hhbmdlSG90c3dhcFJlc3VsdD4gPSBbXTtcbiAgZm9yIChjb25zdCBkZXRlY3RvclJlc3VsdFByb21pc2VzIG9mIHByb21pc2VzKSB7XG4gICAgY29uc3QgaG90c3dhcERldGVjdGlvblJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChhd2FpdCBkZXRlY3RvclJlc3VsdFByb21pc2VzKCkpO1xuICAgIGNoYW5nZXNEZXRlY3Rpb25SZXN1bHRzLnB1c2goaG90c3dhcERldGVjdGlvblJlc3VsdHMpO1xuICB9XG5cbiAgZm9yIChjb25zdCByZXNvdXJjZURldGVjdGlvblJlc3VsdHMgb2YgY2hhbmdlc0RldGVjdGlvblJlc3VsdHMpIHtcbiAgICBmb3IgKGNvbnN0IHByb3BlcnR5UmVzdWx0IG9mIHJlc291cmNlRGV0ZWN0aW9uUmVzdWx0cykge1xuICAgICAgcHJvcGVydHlSZXN1bHQuaG90c3dhcHBhYmxlID9cbiAgICAgICAgaG90c3dhcHBhYmxlUmVzb3VyY2VzLnB1c2gocHJvcGVydHlSZXN1bHQpIDpcbiAgICAgICAgbm9uSG90c3dhcHBhYmxlUmVzb3VyY2VzLnB1c2gocHJvcGVydHlSZXN1bHQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgaG90c3dhcHBhYmxlQ2hhbmdlczogaG90c3dhcHBhYmxlUmVzb3VyY2VzLFxuICAgIG5vbkhvdHN3YXBwYWJsZUNoYW5nZXM6IG5vbkhvdHN3YXBwYWJsZVJlc291cmNlcyxcbiAgfTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFsbCBjaGFuZ2VzIHRvIHJlc291cmNlcyBpbiB0aGUgZ2l2ZW4gU3RhY2suXG4gKlxuICogQHBhcmFtIHN0YWNrQ2hhbmdlcyB0aGUgY29sbGVjdGlvbiBvZiBhbGwgY2hhbmdlcyB0byBhIGdpdmVuIFN0YWNrXG4gKi9cbmZ1bmN0aW9uIGdldFN0YWNrUmVzb3VyY2VEaWZmZXJlbmNlcyhzdGFja0NoYW5nZXM6IGNmbl9kaWZmLlRlbXBsYXRlRGlmZik6IHsgW2xvZ2ljYWxJZDogc3RyaW5nXTogY2ZuX2RpZmYuUmVzb3VyY2VEaWZmZXJlbmNlIH0ge1xuICAvLyB3ZSBuZWVkIHRvIGNvbGxhcHNlIGxvZ2ljYWwgSUQgcmVuYW1lIGNoYW5nZXMgaW50byBvbmUgY2hhbmdlLFxuICAvLyBhcyB0aGV5IGFyZSByZXByZXNlbnRlZCBpbiBzdGFja0NoYW5nZXMgYXMgYSBwYWlyIG9mIHR3byBjaGFuZ2VzOiBvbmUgYWRkaXRpb24gYW5kIG9uZSByZW1vdmFsXG4gIGNvbnN0IGFsbFJlc291cmNlQ2hhbmdlczogeyBbbG9nSWQ6IHN0cmluZ106IGNmbl9kaWZmLlJlc291cmNlRGlmZmVyZW5jZSB9ID0gc3RhY2tDaGFuZ2VzLnJlc291cmNlcy5jaGFuZ2VzO1xuICBjb25zdCBhbGxSZW1vdmFsQ2hhbmdlcyA9IGZpbHRlckRpY3QoYWxsUmVzb3VyY2VDaGFuZ2VzLCByZXNDaGFuZ2UgPT4gcmVzQ2hhbmdlLmlzUmVtb3ZhbCk7XG4gIGNvbnN0IGFsbE5vblJlbW92YWxDaGFuZ2VzID0gZmlsdGVyRGljdChhbGxSZXNvdXJjZUNoYW5nZXMsIHJlc0NoYW5nZSA9PiAhcmVzQ2hhbmdlLmlzUmVtb3ZhbCk7XG4gIGZvciAoY29uc3QgW2xvZ0lkLCBub25SZW1vdmFsQ2hhbmdlXSBvZiBPYmplY3QuZW50cmllcyhhbGxOb25SZW1vdmFsQ2hhbmdlcykpIHtcbiAgICBpZiAobm9uUmVtb3ZhbENoYW5nZS5pc0FkZGl0aW9uKSB7XG4gICAgICBjb25zdCBhZGRDaGFuZ2UgPSBub25SZW1vdmFsQ2hhbmdlO1xuICAgICAgLy8gc2VhcmNoIGZvciBhbiBpZGVudGljYWwgcmVtb3ZhbCBjaGFuZ2VcbiAgICAgIGNvbnN0IGlkZW50aWNhbFJlbW92YWxDaGFuZ2UgPSBPYmplY3QuZW50cmllcyhhbGxSZW1vdmFsQ2hhbmdlcykuZmluZCgoW18sIHJlbUNoYW5nZV0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNoYW5nZXNBcmVGb3JTYW1lUmVzb3VyY2UocmVtQ2hhbmdlLCBhZGRDaGFuZ2UpO1xuICAgICAgfSk7XG4gICAgICAvLyBpZiB3ZSBmb3VuZCBvbmUsIHRoZW4gdGhpcyBtZWFucyB0aGlzIGlzIGEgcmVuYW1lIGNoYW5nZVxuICAgICAgaWYgKGlkZW50aWNhbFJlbW92YWxDaGFuZ2UpIHtcbiAgICAgICAgY29uc3QgW3JlbW92ZWRMb2dJZCwgcmVtb3ZlZFJlc291cmNlQ2hhbmdlXSA9IGlkZW50aWNhbFJlbW92YWxDaGFuZ2U7XG4gICAgICAgIGFsbE5vblJlbW92YWxDaGFuZ2VzW2xvZ0lkXSA9IG1ha2VSZW5hbWVEaWZmZXJlbmNlKHJlbW92ZWRSZXNvdXJjZUNoYW5nZSwgYWRkQ2hhbmdlKTtcbiAgICAgICAgLy8gZGVsZXRlIHRoZSByZW1vdmFsIGNoYW5nZSB0aGF0IGZvcm1zIHRoZSByZW5hbWUgcGFpclxuICAgICAgICBkZWxldGUgYWxsUmVtb3ZhbENoYW5nZXNbcmVtb3ZlZExvZ0lkXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBhcmUgYWxsIG9mIHRoZSByZW1haW5pbmcgcmVtb3ZhbCBjaGFuZ2VzLFxuICAvLyBwbHVzIGFsbCBvZiB0aGUgbm9uLXJlbW92YWwgY2hhbmdlc1xuICAvLyAod2Ugc2F2ZWQgdGhlIHJlbmFtZSBjaGFuZ2VzIGluIHRoYXQgb2JqZWN0IGFscmVhZHkpXG4gIHJldHVybiB7XG4gICAgLi4uYWxsUmVtb3ZhbENoYW5nZXMsXG4gICAgLi4uYWxsTm9uUmVtb3ZhbENoYW5nZXMsXG4gIH07XG59XG5cbi8qKiBGaWx0ZXJzIGFuIG9iamVjdCB3aXRoIHN0cmluZyBrZXlzIGJhc2VkIG9uIHdoZXRoZXIgdGhlIGNhbGxiYWNrIHJldHVybnMgJ3RydWUnIGZvciB0aGUgZ2l2ZW4gdmFsdWUgaW4gdGhlIG9iamVjdC4gKi9cbmZ1bmN0aW9uIGZpbHRlckRpY3Q8VD4oZGljdDogeyBba2V5OiBzdHJpbmddOiBUIH0sIGZ1bmM6ICh0OiBUKSA9PiBib29sZWFuKTogeyBba2V5OiBzdHJpbmddOiBUIH0ge1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMoZGljdCkucmVkdWNlKChhY2MsIFtrZXksIHRdKSA9PiB7XG4gICAgaWYgKGZ1bmModCkpIHtcbiAgICAgIGFjY1trZXldID0gdDtcbiAgICB9XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30gYXMgeyBba2V5OiBzdHJpbmddOiBUIH0pO1xufVxuXG4vKiogRmluZHMgYW55IGhvdHN3YXBwYWJsZSBjaGFuZ2VzIGluIGFsbCBuZXN0ZWQgc3RhY2tzLiAqL1xuYXN5bmMgZnVuY3Rpb24gZmluZE5lc3RlZEhvdHN3YXBwYWJsZUNoYW5nZXMoXG4gIGxvZ2ljYWxJZDogc3RyaW5nLFxuICBjaGFuZ2U6IGNmbl9kaWZmLlJlc291cmNlRGlmZmVyZW5jZSxcbiAgbmVzdGVkU3RhY2tOYW1lczogeyBbbmVzdGVkU3RhY2tOYW1lOiBzdHJpbmddOiBOZXN0ZWRTdGFja05hbWVzIH0sXG4gIGV2YWx1YXRlQ2ZuVGVtcGxhdGU6IEV2YWx1YXRlQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZSxcbiAgc2RrOiBJU0RLLFxuKTogUHJvbWlzZTxDbGFzc2lmaWVkUmVzb3VyY2VDaGFuZ2VzPiB7XG4gIGNvbnN0IG5lc3RlZFN0YWNrTmFtZSA9IG5lc3RlZFN0YWNrTmFtZXNbbG9naWNhbElkXS5uZXN0ZWRTdGFja1BoeXNpY2FsTmFtZTtcbiAgaWYgKCFuZXN0ZWRTdGFja05hbWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaG90c3dhcHBhYmxlQ2hhbmdlczogW10sXG4gICAgICBub25Ib3Rzd2FwcGFibGVDaGFuZ2VzOiBbe1xuICAgICAgICBob3Rzd2FwcGFibGU6IGZhbHNlLFxuICAgICAgICBsb2dpY2FsSWQsXG4gICAgICAgIHJlYXNvbjogYHBoeXNpY2FsIG5hbWUgZm9yIEFXUzo6Q2xvdWRGb3JtYXRpb246OlN0YWNrICcke2xvZ2ljYWxJZH0nIGNvdWxkIG5vdCBiZSBmb3VuZCBpbiBDbG91ZEZvcm1hdGlvbiwgc28gdGhpcyBpcyBhIG5ld2x5IGNyZWF0ZWQgbmVzdGVkIHN0YWNrIGFuZCBjYW5ub3QgYmUgaG90c3dhcHBlZGAsXG4gICAgICAgIHJlamVjdGVkQ2hhbmdlczogW10sXG4gICAgICAgIHJlc291cmNlVHlwZTogJ0FXUzo6Q2xvdWRGb3JtYXRpb246OlN0YWNrJyxcbiAgICAgIH1dLFxuICAgIH07XG4gIH1cblxuICBjb25zdCBldmFsdWF0ZU5lc3RlZENmblRlbXBsYXRlID0gYXdhaXQgZXZhbHVhdGVDZm5UZW1wbGF0ZS5jcmVhdGVOZXN0ZWRFdmFsdWF0ZUNsb3VkRm9ybWF0aW9uVGVtcGxhdGUoXG4gICAgbmVzdGVkU3RhY2tOYW1lLCBjaGFuZ2UubmV3VmFsdWU/LlByb3BlcnRpZXM/Lk5lc3RlZFRlbXBsYXRlLCBjaGFuZ2UubmV3VmFsdWU/LlByb3BlcnRpZXM/LlBhcmFtZXRlcnMsXG4gICk7XG5cbiAgY29uc3QgbmVzdGVkRGlmZiA9IGNmbl9kaWZmLmZ1bGxEaWZmKFxuICAgIGNoYW5nZS5vbGRWYWx1ZT8uUHJvcGVydGllcz8uTmVzdGVkVGVtcGxhdGUsIGNoYW5nZS5uZXdWYWx1ZT8uUHJvcGVydGllcz8uTmVzdGVkVGVtcGxhdGUsXG4gICk7XG5cbiAgcmV0dXJuIGNsYXNzaWZ5UmVzb3VyY2VDaGFuZ2VzKG5lc3RlZERpZmYsIGV2YWx1YXRlTmVzdGVkQ2ZuVGVtcGxhdGUsIHNkaywgbmVzdGVkU3RhY2tOYW1lc1tsb2dpY2FsSWRdLm5lc3RlZENoaWxkU3RhY2tOYW1lcyk7XG59XG5cbi8qKiBSZXR1cm5zICd0cnVlJyBpZiBhIHBhaXIgb2YgY2hhbmdlcyBpcyBmb3IgdGhlIHNhbWUgcmVzb3VyY2UuICovXG5mdW5jdGlvbiBjaGFuZ2VzQXJlRm9yU2FtZVJlc291cmNlKG9sZENoYW5nZTogY2ZuX2RpZmYuUmVzb3VyY2VEaWZmZXJlbmNlLCBuZXdDaGFuZ2U6IGNmbl9kaWZmLlJlc291cmNlRGlmZmVyZW5jZSk6IGJvb2xlYW4ge1xuICByZXR1cm4gb2xkQ2hhbmdlLm9sZFJlc291cmNlVHlwZSA9PT0gbmV3Q2hhbmdlLm5ld1Jlc291cmNlVHlwZSAmJlxuICAgIC8vIHRoaXMgaXNuJ3QgZ3JlYXQsIGJ1dCBJIGRvbid0IHdhbnQgdG8gYnJpbmcgaW4gc29tZXRoaW5nIGxpa2UgdW5kZXJzY29yZSBqdXN0IGZvciB0aGlzIGNvbXBhcmlzb25cbiAgICBKU09OLnN0cmluZ2lmeShvbGRDaGFuZ2Uub2xkUHJvcGVydGllcykgPT09IEpTT04uc3RyaW5naWZ5KG5ld0NoYW5nZS5uZXdQcm9wZXJ0aWVzKTtcbn1cblxuZnVuY3Rpb24gbWFrZVJlbmFtZURpZmZlcmVuY2UoXG4gIHJlbUNoYW5nZTogY2ZuX2RpZmYuUmVzb3VyY2VEaWZmZXJlbmNlLFxuICBhZGRDaGFuZ2U6IGNmbl9kaWZmLlJlc291cmNlRGlmZmVyZW5jZSxcbik6IGNmbl9kaWZmLlJlc291cmNlRGlmZmVyZW5jZSB7XG4gIHJldHVybiBuZXcgY2ZuX2RpZmYuUmVzb3VyY2VEaWZmZXJlbmNlKFxuICAgIC8vIHdlIGhhdmUgdG8gZmlsbCBpbiB0aGUgb2xkIHZhbHVlLCBiZWNhdXNlIG90aGVyd2lzZSB0aGlzIHdpbGwgYmUgY2xhc3NpZmllZCBhcyBhIG5vbi1ob3Rzd2FwcGFibGUgY2hhbmdlXG4gICAgcmVtQ2hhbmdlLm9sZFZhbHVlLFxuICAgIGFkZENoYW5nZS5uZXdWYWx1ZSxcbiAgICB7XG4gICAgICByZXNvdXJjZVR5cGU6IHtcbiAgICAgICAgb2xkVHlwZTogcmVtQ2hhbmdlLm9sZFJlc291cmNlVHlwZSxcbiAgICAgICAgbmV3VHlwZTogYWRkQ2hhbmdlLm5ld1Jlc291cmNlVHlwZSxcbiAgICAgIH0sXG4gICAgICBwcm9wZXJ0eURpZmZzOiAoYWRkQ2hhbmdlIGFzIGFueSkucHJvcGVydHlEaWZmcyxcbiAgICAgIG90aGVyRGlmZnM6IChhZGRDaGFuZ2UgYXMgYW55KS5vdGhlckRpZmZzLFxuICAgIH0sXG4gICk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGBIb3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGVgIGlmIHRoZSBjaGFuZ2UgaXMgaG90c3dhcHBhYmxlXG4gKiBSZXR1cm5zIGFuIGVtcHR5IGBIb3Rzd2FwcGFibGVDaGFuZ2VgIGlmIHRoZSBjaGFuZ2UgaXMgdG8gQ0RLOjpNZXRhZGF0YVxuICogUmV0dXJucyBhIGBOb25Ib3Rzd2FwcGFibGVDaGFuZ2VgIGlmIHRoZSBjaGFuZ2UgaXMgbm90IGhvdHN3YXBwYWJsZVxuICovXG5mdW5jdGlvbiBpc0NhbmRpZGF0ZUZvckhvdHN3YXBwaW5nKFxuICBjaGFuZ2U6IGNmbl9kaWZmLlJlc291cmNlRGlmZmVyZW5jZSwgbG9naWNhbElkOiBzdHJpbmcsXG4pOiBIb3Rzd2FwcGFibGVDaGFuZ2UgfCBOb25Ib3Rzd2FwcGFibGVDaGFuZ2UgfCBIb3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUge1xuICAvLyBhIHJlc291cmNlIGhhcyBiZWVuIHJlbW92ZWQgT1IgYSByZXNvdXJjZSBoYXMgYmVlbiBhZGRlZDsgd2UgY2FuJ3Qgc2hvcnQtY2lyY3VpdCB0aGF0IGNoYW5nZVxuICBpZiAoIWNoYW5nZS5vbGRWYWx1ZSkge1xuICAgIHJldHVybiB7XG4gICAgICBob3Rzd2FwcGFibGU6IGZhbHNlLFxuICAgICAgcmVzb3VyY2VUeXBlOiBjaGFuZ2UubmV3VmFsdWUhLlR5cGUsXG4gICAgICBsb2dpY2FsSWQsXG4gICAgICByZWplY3RlZENoYW5nZXM6IFtdLFxuICAgICAgcmVhc29uOiBgcmVzb3VyY2UgJyR7bG9naWNhbElkfScgd2FzIGNyZWF0ZWQgYnkgdGhpcyBkZXBsb3ltZW50YCxcbiAgICB9O1xuICB9IGVsc2UgaWYgKCFjaGFuZ2UubmV3VmFsdWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaG90c3dhcHBhYmxlOiBmYWxzZSxcbiAgICAgIHJlc291cmNlVHlwZTogY2hhbmdlLm9sZFZhbHVlIS5UeXBlLFxuICAgICAgbG9naWNhbElkLFxuICAgICAgcmVqZWN0ZWRDaGFuZ2VzOiBbXSxcbiAgICAgIHJlYXNvbjogYHJlc291cmNlICcke2xvZ2ljYWxJZH0nIHdhcyBkZXN0cm95ZWQgYnkgdGhpcyBkZXBsb3ltZW50YCxcbiAgICB9O1xuICB9XG5cbiAgLy8gYSByZXNvdXJjZSBoYXMgaGFkIGl0cyB0eXBlIGNoYW5nZWRcbiAgaWYgKGNoYW5nZS5uZXdWYWx1ZT8uVHlwZSAhPT0gY2hhbmdlLm9sZFZhbHVlPy5UeXBlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhvdHN3YXBwYWJsZTogZmFsc2UsXG4gICAgICByZXNvdXJjZVR5cGU6IGNoYW5nZS5uZXdWYWx1ZT8uVHlwZSxcbiAgICAgIGxvZ2ljYWxJZCxcbiAgICAgIHJlamVjdGVkQ2hhbmdlczogW10sXG4gICAgICByZWFzb246IGByZXNvdXJjZSAnJHtsb2dpY2FsSWR9JyBoYWQgaXRzIHR5cGUgY2hhbmdlZCBmcm9tICcke2NoYW5nZS5vbGRWYWx1ZT8uVHlwZX0nIHRvICcke2NoYW5nZS5uZXdWYWx1ZT8uVHlwZX0nYCxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBsb2dpY2FsSWQsXG4gICAgb2xkVmFsdWU6IGNoYW5nZS5vbGRWYWx1ZSxcbiAgICBuZXdWYWx1ZTogY2hhbmdlLm5ld1ZhbHVlLFxuICAgIHByb3BlcnR5VXBkYXRlczogY2hhbmdlLnByb3BlcnR5VXBkYXRlcyxcbiAgfTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gYXBwbHlBbGxIb3Rzd2FwcGFibGVDaGFuZ2VzKHNkazogSVNESywgaG90c3dhcHBhYmxlQ2hhbmdlczogSG90c3dhcHBhYmxlQ2hhbmdlW10pOiBQcm9taXNlPHZvaWRbXT4ge1xuICBpZiAoaG90c3dhcHBhYmxlQ2hhbmdlcy5sZW5ndGggPiAwKSB7XG4gICAgcHJpbnQoYFxcbiR7SUNPTn0gaG90c3dhcHBpbmcgcmVzb3VyY2VzOmApO1xuICB9XG4gIHJldHVybiBQcm9taXNlLmFsbChob3Rzd2FwcGFibGVDaGFuZ2VzLm1hcChob3Rzd2FwT3BlcmF0aW9uID0+IHtcbiAgICByZXR1cm4gYXBwbHlIb3Rzd2FwcGFibGVDaGFuZ2Uoc2RrLCBob3Rzd2FwT3BlcmF0aW9uKTtcbiAgfSkpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBhcHBseUhvdHN3YXBwYWJsZUNoYW5nZShzZGs6IElTREssIGhvdHN3YXBPcGVyYXRpb246IEhvdHN3YXBwYWJsZUNoYW5nZSk6IFByb21pc2U8dm9pZD4ge1xuICAvLyBub3RlIHRoZSB0eXBlIG9mIHNlcnZpY2UgdGhhdCB3YXMgc3VjY2Vzc2Z1bGx5IGhvdHN3YXBwZWQgaW4gdGhlIFVzZXItQWdlbnRcbiAgY29uc3QgY3VzdG9tVXNlckFnZW50ID0gYGNkay1ob3Rzd2FwL3N1Y2Nlc3MtJHtob3Rzd2FwT3BlcmF0aW9uLnNlcnZpY2V9YDtcbiAgc2RrLmFwcGVuZEN1c3RvbVVzZXJBZ2VudChjdXN0b21Vc2VyQWdlbnQpO1xuXG4gIGZvciAoY29uc3QgbmFtZSBvZiBob3Rzd2FwT3BlcmF0aW9uLnJlc291cmNlTmFtZXMpIHtcbiAgICBwcmludChgICAgJHtJQ09OfSAlc2AsIGNoYWxrLmJvbGQobmFtZSkpO1xuICB9XG5cbiAgLy8gaWYgdGhlIFNESyBjYWxsIGZhaWxzLCBhbiBlcnJvciB3aWxsIGJlIHRocm93biBieSB0aGUgU0RLXG4gIC8vIGFuZCB3aWxsIHByZXZlbnQgdGhlIGdyZWVuICdob3Rzd2FwcGVkIScgdGV4dCBmcm9tIGJlaW5nIGRpc3BsYXllZFxuICBhd2FpdCBob3Rzd2FwT3BlcmF0aW9uLmFwcGx5KHNkayk7XG5cbiAgZm9yIChjb25zdCBuYW1lIG9mIGhvdHN3YXBPcGVyYXRpb24ucmVzb3VyY2VOYW1lcykge1xuICAgIHByaW50KGAke0lDT059ICVzICVzYCwgY2hhbGsuYm9sZChuYW1lKSwgY2hhbGsuZ3JlZW4oJ2hvdHN3YXBwZWQhJykpO1xuICB9XG5cbiAgc2RrLnJlbW92ZUN1c3RvbVVzZXJBZ2VudChjdXN0b21Vc2VyQWdlbnQpO1xufVxuXG5mdW5jdGlvbiBsb2dOb25Ib3Rzd2FwcGFibGVDaGFuZ2VzKG5vbkhvdHN3YXBwYWJsZUNoYW5nZXM6IE5vbkhvdHN3YXBwYWJsZUNoYW5nZVtdLCBob3Rzd2FwTW9kZTogSG90c3dhcE1vZGUpOiB2b2lkIHtcbiAgaWYgKG5vbkhvdHN3YXBwYWJsZUNoYW5nZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8qKlxuICAgKiBFS1MgU2VydmljZXMgY2FuIGhhdmUgYSB0YXNrIGRlZmluaXRpb24gdGhhdCBkb2Vzbid0IHJlZmVyIHRvIHRoZSB0YXNrIGRlZmluaXRpb24gYmVpbmcgdXBkYXRlZC5cbiAgICogV2UgaGF2ZSB0byBsb2cgdGhpcyBhcyBhIG5vbi1ob3Rzd2FwcGFibGUgY2hhbmdlIHRvIHRoZSB0YXNrIGRlZmluaXRpb24sIGJ1dCB3aGVuIHdlIGRvLFxuICAgKiB3ZSB3aW5kIHVwIGhvdHN3YXBwaW5nIHRoZSB0YXNrIGRlZmluaXRpb24gYW5kIGxvZ2dpbmcgaXQgYXMgYSBub24taG90c3dhcHBhYmxlIGNoYW5nZS5cbiAgICpcbiAgICogVGhpcyBsb2dpYyBwcmV2ZW50cyB1cyBmcm9tIGxvZ2dpbmcgdGhhdCBjaGFuZ2UgYXMgbm9uLWhvdHN3YXBwYWJsZSB3aGVuIHdlIGhvdHN3YXAgaXQuXG4gICAqL1xuICBpZiAoaG90c3dhcE1vZGUgPT09IEhvdHN3YXBNb2RlLkhPVFNXQVBfT05MWSkge1xuICAgIG5vbkhvdHN3YXBwYWJsZUNoYW5nZXMgPSBub25Ib3Rzd2FwcGFibGVDaGFuZ2VzLmZpbHRlcigoY2hhbmdlKSA9PiBjaGFuZ2UuaG90c3dhcE9ubHlWaXNpYmxlID09PSB0cnVlKTtcblxuICAgIGlmIChub25Ib3Rzd2FwcGFibGVDaGFuZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBpZiAoaG90c3dhcE1vZGUgPT09IEhvdHN3YXBNb2RlLkhPVFNXQVBfT05MWSkge1xuICAgIHByaW50KCdcXG4lcyAlcycsIGNoYWxrLnJlZCgn4pqg77iPJyksIGNoYWxrLnJlZCgnVGhlIGZvbGxvd2luZyBub24taG90c3dhcHBhYmxlIGNoYW5nZXMgd2VyZSBmb3VuZC4gVG8gcmVjb25jaWxlIHRoZXNlIHVzaW5nIENsb3VkRm9ybWF0aW9uLCBzcGVjaWZ5IC0taG90c3dhcC1mYWxsYmFjaycpKTtcbiAgfSBlbHNlIHtcbiAgICBwcmludCgnXFxuJXMgJXMnLCBjaGFsay5yZWQoJ+KaoO+4jycpLCBjaGFsay5yZWQoJ1RoZSBmb2xsb3dpbmcgbm9uLWhvdHN3YXBwYWJsZSBjaGFuZ2VzIHdlcmUgZm91bmQ6JykpO1xuICB9XG5cbiAgZm9yIChjb25zdCBjaGFuZ2Ugb2Ygbm9uSG90c3dhcHBhYmxlQ2hhbmdlcykge1xuICAgIGNoYW5nZS5yZWplY3RlZENoYW5nZXMubGVuZ3RoID4gMCA/XG4gICAgICBwcmludCgnICAgIGxvZ2ljYWxJRDogJXMsIHR5cGU6ICVzLCByZWplY3RlZCBjaGFuZ2VzOiAlcywgcmVhc29uOiAlcycsIGNoYWxrLmJvbGQoY2hhbmdlLmxvZ2ljYWxJZCksIGNoYWxrLmJvbGQoY2hhbmdlLnJlc291cmNlVHlwZSksIGNoYWxrLmJvbGQoY2hhbmdlLnJlamVjdGVkQ2hhbmdlcyksIGNoYWxrLnJlZChjaGFuZ2UucmVhc29uKSkgOlxuICAgICAgcHJpbnQoJyAgICBsb2dpY2FsSUQ6ICVzLCB0eXBlOiAlcywgcmVhc29uOiAlcycsIGNoYWxrLmJvbGQoY2hhbmdlLmxvZ2ljYWxJZCksIGNoYWxrLmJvbGQoY2hhbmdlLnJlc291cmNlVHlwZSksIGNoYWxrLnJlZChjaGFuZ2UucmVhc29uKSk7XG4gIH1cblxuICBwcmludCgnJyk7IC8vIG5ld2xpbmVcbn1cbiJdfQ==