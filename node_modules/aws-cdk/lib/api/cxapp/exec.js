"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareContext = exports.prepareDefaultEnvironment = exports.createAssembly = exports.execProgram = void 0;
const childProcess = require("child_process");
const os = require("os");
const path = require("path");
const cxschema = require("@aws-cdk/cloud-assembly-schema");
const cxapi = require("@aws-cdk/cx-api");
const fs = require("fs-extra");
const semver = require("semver");
const logging_1 = require("../../logging");
const settings_1 = require("../../settings");
const tree_1 = require("../../tree");
const objects_1 = require("../../util/objects");
const version_1 = require("../../version");
const rwlock_1 = require("../util/rwlock");
/** Invokes the cloud executable and returns JSON output */
async function execProgram(aws, config) {
    const env = await prepareDefaultEnvironment(aws);
    const context = await prepareContext(config, env);
    const build = config.settings.get(['build']);
    if (build) {
        await exec(build);
    }
    const app = config.settings.get(['app']);
    if (!app) {
        throw new Error(`--app is required either in command-line, in ${settings_1.PROJECT_CONFIG} or in ${settings_1.USER_DEFAULTS}`);
    }
    // bypass "synth" if app points to a cloud assembly
    if (await fs.pathExists(app) && (await fs.stat(app)).isDirectory()) {
        (0, logging_1.debug)('--app points to a cloud assembly, so we bypass synth');
        // Acquire a read lock on this directory
        const lock = await new rwlock_1.RWLock(app).acquireRead();
        return { assembly: createAssembly(app), lock };
    }
    const commandLine = await guessExecutable(appToArray(app));
    const outdir = config.settings.get(['output']);
    if (!outdir) {
        throw new Error('unexpected: --output is required');
    }
    try {
        await fs.mkdirp(outdir);
    }
    catch (error) {
        throw new Error(`Could not create output directory ${outdir} (${error.message})`);
    }
    (0, logging_1.debug)('outdir:', outdir);
    env[cxapi.OUTDIR_ENV] = outdir;
    // Acquire a read lock on the output directory
    const writerLock = await new rwlock_1.RWLock(outdir).acquireWrite();
    // Send version information
    env[cxapi.CLI_ASM_VERSION_ENV] = cxschema.Manifest.version();
    env[cxapi.CLI_VERSION_ENV] = (0, version_1.versionNumber)();
    (0, logging_1.debug)('env:', env);
    const envVariableSizeLimit = os.platform() === 'win32' ? 32760 : 131072;
    const [smallContext, overflow] = (0, objects_1.splitBySize)(context, spaceAvailableForContext(env, envVariableSizeLimit));
    // Store the safe part in the environment variable
    env[cxapi.CONTEXT_ENV] = JSON.stringify(smallContext);
    // If there was any overflow, write it to a temporary file
    let contextOverflowLocation;
    if (Object.keys(overflow ?? {}).length > 0) {
        const contextDir = await fs.mkdtemp(path.join(os.tmpdir(), 'cdk-context'));
        contextOverflowLocation = path.join(contextDir, 'context-overflow.json');
        fs.writeJSONSync(contextOverflowLocation, overflow);
        env[cxapi.CONTEXT_OVERFLOW_LOCATION_ENV] = contextOverflowLocation;
    }
    await exec(commandLine.join(' '));
    const assembly = createAssembly(outdir);
    contextOverflowCleanup(contextOverflowLocation, assembly);
    return { assembly, lock: await writerLock.convertToReaderLock() };
    async function exec(commandAndArgs) {
        return new Promise((ok, fail) => {
            // We use a slightly lower-level interface to:
            //
            // - Pass arguments in an array instead of a string, to get around a
            //   number of quoting issues introduced by the intermediate shell layer
            //   (which would be different between Linux and Windows).
            //
            // - Inherit stderr from controlling terminal. We don't use the captured value
            //   anyway, and if the subprocess is printing to it for debugging purposes the
            //   user gets to see it sooner. Plus, capturing doesn't interact nicely with some
            //   processes like Maven.
            const proc = childProcess.spawn(commandAndArgs, {
                stdio: ['ignore', 'inherit', 'inherit'],
                detached: false,
                shell: true,
                env: {
                    ...process.env,
                    ...env,
                },
            });
            proc.on('error', fail);
            proc.on('exit', code => {
                if (code === 0) {
                    return ok();
                }
                else {
                    (0, logging_1.debug)('failed command:', commandAndArgs);
                    return fail(new Error(`Subprocess exited with error ${code}`));
                }
            });
        });
    }
}
exports.execProgram = execProgram;
/**
 * Creates an assembly with error handling
 */
function createAssembly(appDir) {
    try {
        return new cxapi.CloudAssembly(appDir, {
            // We sort as we deploy
            topoSort: false,
        });
    }
    catch (error) {
        if (error.message.includes(cxschema.VERSION_MISMATCH)) {
            // this means the CLI version is too old.
            // we instruct the user to upgrade.
            throw new Error(`This CDK CLI is not compatible with the CDK library used by your application. Please upgrade the CLI to the latest version.\n(${error.message})`);
        }
        throw error;
    }
}
exports.createAssembly = createAssembly;
/**
 * If we don't have region/account defined in context, we fall back to the default SDK behavior
 * where region is retrieved from ~/.aws/config and account is based on default credentials provider
 * chain and then STS is queried.
 *
 * This is done opportunistically: for example, if we can't access STS for some reason or the region
 * is not configured, the context value will be 'null' and there could failures down the line. In
 * some cases, synthesis does not require region/account information at all, so that might be perfectly
 * fine in certain scenarios.
 *
 * @param context The context key/value bash.
 */
async function prepareDefaultEnvironment(aws) {
    const env = {};
    env[cxapi.DEFAULT_REGION_ENV] = aws.defaultRegion;
    (0, logging_1.debug)(`Setting "${cxapi.DEFAULT_REGION_ENV}" environment variable to`, env[cxapi.DEFAULT_REGION_ENV]);
    const accountId = (await aws.defaultAccount())?.accountId;
    if (accountId) {
        env[cxapi.DEFAULT_ACCOUNT_ENV] = accountId;
        (0, logging_1.debug)(`Setting "${cxapi.DEFAULT_ACCOUNT_ENV}" environment variable to`, env[cxapi.DEFAULT_ACCOUNT_ENV]);
    }
    return env;
}
exports.prepareDefaultEnvironment = prepareDefaultEnvironment;
/**
 * Settings related to synthesis are read from context.
 * The merging of various configuration sources like cli args or cdk.json has already happened.
 * We now need to set the final values to the context.
 */
async function prepareContext(config, env) {
    const context = config.context.all;
    const debugMode = config.settings.get(['debug']) ?? true;
    if (debugMode) {
        env.CDK_DEBUG = 'true';
    }
    const pathMetadata = config.settings.get(['pathMetadata']) ?? true;
    if (pathMetadata) {
        context[cxapi.PATH_METADATA_ENABLE_CONTEXT] = true;
    }
    const assetMetadata = config.settings.get(['assetMetadata']) ?? true;
    if (assetMetadata) {
        context[cxapi.ASSET_RESOURCE_METADATA_ENABLED_CONTEXT] = true;
    }
    const versionReporting = config.settings.get(['versionReporting']) ?? true;
    if (versionReporting) {
        context[cxapi.ANALYTICS_REPORTING_ENABLED_CONTEXT] = true;
    }
    // We need to keep on doing this for framework version from before this flag was deprecated.
    if (!versionReporting) {
        context['aws:cdk:disable-version-reporting'] = true;
    }
    const stagingEnabled = config.settings.get(['staging']) ?? true;
    if (!stagingEnabled) {
        context[cxapi.DISABLE_ASSET_STAGING_CONTEXT] = true;
    }
    const bundlingStacks = config.settings.get(['bundlingStacks']) ?? ['**'];
    context[cxapi.BUNDLING_STACKS] = bundlingStacks;
    (0, logging_1.debug)('context:', context);
    return context;
}
exports.prepareContext = prepareContext;
/**
 * Make sure the 'app' is an array
 *
 * If it's a string, split on spaces as a trivial way of tokenizing the command line.
 */
function appToArray(app) {
    return typeof app === 'string' ? app.split(' ') : app;
}
/**
 * Execute the given file with the same 'node' process as is running the current process
 */
function executeNode(scriptFile) {
    return [process.execPath, scriptFile];
}
/**
 * Mapping of extensions to command-line generators
 */
const EXTENSION_MAP = new Map([
    ['.js', executeNode],
]);
/**
 * Guess the executable from the command-line argument
 *
 * Only do this if the file is NOT marked as executable. If it is,
 * we'll defer to the shebang inside the file itself.
 *
 * If we're on Windows, we ALWAYS take the handler, since it's hard to
 * verify if registry associations have or have not been set up for this
 * file type, so we'll assume the worst and take control.
 */
async function guessExecutable(commandLine) {
    if (commandLine.length === 1) {
        let fstat;
        try {
            fstat = await fs.stat(commandLine[0]);
        }
        catch {
            (0, logging_1.debug)(`Not a file: '${commandLine[0]}'. Using '${commandLine}' as command-line`);
            return commandLine;
        }
        // eslint-disable-next-line no-bitwise
        const isExecutable = (fstat.mode & fs.constants.X_OK) !== 0;
        const isWindows = process.platform === 'win32';
        const handler = EXTENSION_MAP.get(path.extname(commandLine[0]));
        if (handler && (!isExecutable || isWindows)) {
            return handler(commandLine[0]);
        }
    }
    return commandLine;
}
function contextOverflowCleanup(location, assembly) {
    if (location) {
        fs.removeSync(path.dirname(location));
        const tree = (0, tree_1.loadTree)(assembly);
        const frameworkDoesNotSupportContextOverflow = (0, tree_1.some)(tree, node => {
            const fqn = node.constructInfo?.fqn;
            const version = node.constructInfo?.version;
            return (fqn === 'aws-cdk-lib.App' && version != null && semver.lte(version, '2.38.0'))
                || fqn === '@aws-cdk/core.App'; // v1
        });
        // We're dealing with an old version of the framework here. It is unaware of the temporary
        // file, which means that it will ignore the context overflow.
        if (frameworkDoesNotSupportContextOverflow) {
            (0, logging_1.warning)('Part of the context could not be sent to the application. Please update the AWS CDK library to the latest version.');
        }
    }
}
function spaceAvailableForContext(env, limit) {
    const size = (value) => value != null ? Buffer.byteLength(value) : 0;
    const usedSpace = Object.entries(env)
        .map(([k, v]) => k === cxapi.CONTEXT_ENV ? size(k) : size(k) + size(v))
        .reduce((a, b) => a + b, 0);
    return Math.max(0, limit - usedSpace);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhlYy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImV4ZWMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsOENBQThDO0FBQzlDLHlCQUF5QjtBQUN6Qiw2QkFBNkI7QUFDN0IsMkRBQTJEO0FBQzNELHlDQUF5QztBQUN6QywrQkFBK0I7QUFDL0IsaUNBQWlDO0FBQ2pDLDJDQUErQztBQUMvQyw2Q0FBOEU7QUFDOUUscUNBQTRDO0FBQzVDLGdEQUFpRDtBQUNqRCwyQ0FBOEM7QUFFOUMsMkNBQStDO0FBTy9DLDJEQUEyRDtBQUNwRCxLQUFLLFVBQVUsV0FBVyxDQUFDLEdBQWdCLEVBQUUsTUFBcUI7SUFDdkUsTUFBTSxHQUFHLEdBQUcsTUFBTSx5QkFBeUIsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNqRCxNQUFNLE9BQU8sR0FBRyxNQUFNLGNBQWMsQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFFbEQsTUFBTSxLQUFLLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO0lBQzdDLElBQUksS0FBSyxFQUFFO1FBQ1QsTUFBTSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7S0FDbkI7SUFFRCxNQUFNLEdBQUcsR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7SUFDekMsSUFBSSxDQUFDLEdBQUcsRUFBRTtRQUNSLE1BQU0sSUFBSSxLQUFLLENBQUMsZ0RBQWdELHlCQUFjLFVBQVUsd0JBQWEsRUFBRSxDQUFDLENBQUM7S0FDMUc7SUFFRCxtREFBbUQ7SUFDbkQsSUFBSSxNQUFNLEVBQUUsQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUUsRUFBRTtRQUNsRSxJQUFBLGVBQUssRUFBQyxzREFBc0QsQ0FB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O21CQUNqRixHQUFHLEtBQUssbUJBQW1CLENBQUMsQ0FBQyxLQUFLO1FBQ3pDLENBQUMsQ0FBQyxDQUFDO1FBRUgsMEZBQTBGO1FBQzFGLDhEQUE4RDtRQUM5RCxJQUFJLHNDQUFzQyxFQUFFO1lBQzFDLElBQUEsaUJBQU8sRUFBQyxvSEFBb0gsQ0FBQyxDQUFDO1NBQy9IO0tBQ0Y7QUFDSCxDQUFDO0FBRUQsU0FBUyx3QkFBd0IsQ0FBQyxHQUE4QixFQUFFLEtBQWE7SUFDN0UsTUFBTSxJQUFJLEdBQUcsQ0FBQyxLQUFhLEVBQUUsRUFBRSxDQUFDLEtBQUssSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUU3RSxNQUFNLFNBQVMsR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQztTQUNsQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxLQUFLLEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUN0RSxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBRTlCLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsS0FBSyxHQUFHLFNBQVMsQ0FBQyxDQUFDO0FBQ3hDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBjaGlsZFByb2Nlc3MgZnJvbSAnY2hpbGRfcHJvY2Vzcyc7XG5pbXBvcnQgKiBhcyBvcyBmcm9tICdvcyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0ICogYXMgY3hzY2hlbWEgZnJvbSAnQGF3cy1jZGsvY2xvdWQtYXNzZW1ibHktc2NoZW1hJztcbmltcG9ydCAqIGFzIGN4YXBpIGZyb20gJ0Bhd3MtY2RrL2N4LWFwaSc7XG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcy1leHRyYSc7XG5pbXBvcnQgKiBhcyBzZW12ZXIgZnJvbSAnc2VtdmVyJztcbmltcG9ydCB7IGRlYnVnLCB3YXJuaW5nIH0gZnJvbSAnLi4vLi4vbG9nZ2luZyc7XG5pbXBvcnQgeyBDb25maWd1cmF0aW9uLCBQUk9KRUNUX0NPTkZJRywgVVNFUl9ERUZBVUxUUyB9IGZyb20gJy4uLy4uL3NldHRpbmdzJztcbmltcG9ydCB7IGxvYWRUcmVlLCBzb21lIH0gZnJvbSAnLi4vLi4vdHJlZSc7XG5pbXBvcnQgeyBzcGxpdEJ5U2l6ZSB9IGZyb20gJy4uLy4uL3V0aWwvb2JqZWN0cyc7XG5pbXBvcnQgeyB2ZXJzaW9uTnVtYmVyIH0gZnJvbSAnLi4vLi4vdmVyc2lvbic7XG5pbXBvcnQgeyBTZGtQcm92aWRlciB9IGZyb20gJy4uL2F3cy1hdXRoJztcbmltcG9ydCB7IFJXTG9jaywgSUxvY2sgfSBmcm9tICcuLi91dGlsL3J3bG9jayc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXhlY1Byb2dyYW1SZXN1bHQge1xuICByZWFkb25seSBhc3NlbWJseTogY3hhcGkuQ2xvdWRBc3NlbWJseTtcbiAgcmVhZG9ubHkgbG9jazogSUxvY2s7XG59XG5cbi8qKiBJbnZva2VzIHRoZSBjbG91ZCBleGVjdXRhYmxlIGFuZCByZXR1cm5zIEpTT04gb3V0cHV0ICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXhlY1Byb2dyYW0oYXdzOiBTZGtQcm92aWRlciwgY29uZmlnOiBDb25maWd1cmF0aW9uKTogUHJvbWlzZTxFeGVjUHJvZ3JhbVJlc3VsdD4ge1xuICBjb25zdCBlbnYgPSBhd2FpdCBwcmVwYXJlRGVmYXVsdEVudmlyb25tZW50KGF3cyk7XG4gIGNvbnN0IGNvbnRleHQgPSBhd2FpdCBwcmVwYXJlQ29udGV4dChjb25maWcsIGVudik7XG5cbiAgY29uc3QgYnVpbGQgPSBjb25maWcuc2V0dGluZ3MuZ2V0KFsnYnVpbGQnXSk7XG4gIGlmIChidWlsZCkge1xuICAgIGF3YWl0IGV4ZWMoYnVpbGQpO1xuICB9XG5cbiAgY29uc3QgYXBwID0gY29uZmlnLnNldHRpbmdzLmdldChbJ2FwcCddKTtcbiAgaWYgKCFhcHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYC0tYXBwIGlzIHJlcXVpcmVkIGVpdGhlciBpbiBjb21tYW5kLWxpbmUsIGluICR7UFJPSkVDVF9DT05GSUd9IG9yIGluICR7VVNFUl9ERUZBVUxUU31gKTtcbiAgfVxuXG4gIC8vIGJ5cGFzcyBcInN5bnRoXCIgaWYgYXBwIHBvaW50cyB0byBhIGNsb3VkIGFzc2VtYmx5XG4gIGlmIChhd2FpdCBmcy5wYXRoRXhpc3RzKGFwcCkgJiYgKGF3YWl0IGZzLnN0YXQoYXBwKSkuaXNEaXJlY3RvcnkoKSkge1xuICAgIGRlYnVnKCctLWFwcCBwb2ludHMgdG8gYSBjbG91ZCBhc3NlbWJseSwgc28gd2UgYnlwYXNzIHN5bnRoJyk7XG5cbiAgICAvLyBBY3F1aXJlIGEgcmVhZCBsb2NrIG9uIHRoaXMgZGlyZWN0b3J5XG4gICAgY29uc3QgbG9jayA9IGF3YWl0IG5ldyBSV0xvY2soYXBwKS5hY3F1aXJlUmVhZCgpO1xuXG4gICAgcmV0dXJuIHsgYXNzZW1ibHk6IGNyZWF0ZUFzc2VtYmx5KGFwcCksIGxvY2sgfTtcbiAgfVxuXG4gIGNvbnN0IGNvbW1hbmRMaW5lID0gYXdhaXQgZ3Vlc3NFeGVjdXRhYmxlKGFwcFRvQXJyYXkoYXBwKSk7XG5cbiAgY29uc3Qgb3V0ZGlyID0gY29uZmlnLnNldHRpbmdzLmdldChbJ291dHB1dCddKTtcbiAgaWYgKCFvdXRkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQ6IC0tb3V0cHV0IGlzIHJlcXVpcmVkJyk7XG4gIH1cbiAgdHJ5IHtcbiAgICBhd2FpdCBmcy5ta2RpcnAob3V0ZGlyKTtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGNyZWF0ZSBvdXRwdXQgZGlyZWN0b3J5ICR7b3V0ZGlyfSAoJHtlcnJvci5tZXNzYWdlfSlgKTtcbiAgfVxuXG4gIGRlYnVnKCdvdXRkaXI6Jywgb3V0ZGlyKTtcbiAgZW52W2N4YXBpLk9VVERJUl9FTlZdID0gb3V0ZGlyO1xuXG4gIC8vIEFjcXVpcmUgYSByZWFkIGxvY2sgb24gdGhlIG91dHB1dCBkaXJlY3RvcnlcbiAgY29uc3Qgd3JpdGVyTG9jayA9IGF3YWl0IG5ldyBSV0xvY2sob3V0ZGlyKS5hY3F1aXJlV3JpdGUoKTtcblxuICAvLyBTZW5kIHZlcnNpb24gaW5mb3JtYXRpb25cbiAgZW52W2N4YXBpLkNMSV9BU01fVkVSU0lPTl9FTlZdID0gY3hzY2hlbWEuTWFuaWZlc3QudmVyc2lvbigpO1xuICBlbnZbY3hhcGkuQ0xJX1ZFUlNJT05fRU5WXSA9IHZlcnNpb25OdW1iZXIoKTtcblxuICBkZWJ1ZygnZW52OicsIGVudik7XG5cbiAgY29uc3QgZW52VmFyaWFibGVTaXplTGltaXQgPSBvcy5wbGF0Zm9ybSgpID09PSAnd2luMzInID8gMzI3NjAgOiAxMzEwNzI7XG4gIGNvbnN0IFtzbWFsbENvbnRleHQsIG92ZXJmbG93XSA9IHNwbGl0QnlTaXplKGNvbnRleHQsIHNwYWNlQXZhaWxhYmxlRm9yQ29udGV4dChlbnYsIGVudlZhcmlhYmxlU2l6ZUxpbWl0KSk7XG5cbiAgLy8gU3RvcmUgdGhlIHNhZmUgcGFydCBpbiB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVcbiAgZW52W2N4YXBpLkNPTlRFWFRfRU5WXSA9IEpTT04uc3RyaW5naWZ5KHNtYWxsQ29udGV4dCk7XG5cbiAgLy8gSWYgdGhlcmUgd2FzIGFueSBvdmVyZmxvdywgd3JpdGUgaXQgdG8gYSB0ZW1wb3JhcnkgZmlsZVxuICBsZXQgY29udGV4dE92ZXJmbG93TG9jYXRpb247XG4gIGlmIChPYmplY3Qua2V5cyhvdmVyZmxvdyA/PyB7fSkubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGNvbnRleHREaXIgPSBhd2FpdCBmcy5ta2R0ZW1wKHBhdGguam9pbihvcy50bXBkaXIoKSwgJ2Nkay1jb250ZXh0JykpO1xuICAgIGNvbnRleHRPdmVyZmxvd0xvY2F0aW9uID0gcGF0aC5qb2luKGNvbnRleHREaXIsICdjb250ZXh0LW92ZXJmbG93Lmpzb24nKTtcbiAgICBmcy53cml0ZUpTT05TeW5jKGNvbnRleHRPdmVyZmxvd0xvY2F0aW9uLCBvdmVyZmxvdyk7XG4gICAgZW52W2N4YXBpLkNPTlRFWFRfT1ZFUkZMT1dfTE9DQVRJT05fRU5WXSA9IGNvbnRleHRPdmVyZmxvd0xvY2F0aW9uO1xuICB9XG5cbiAgYXdhaXQgZXhlYyhjb21tYW5kTGluZS5qb2luKCcgJykpO1xuXG4gIGNvbnN0IGFzc2VtYmx5ID0gY3JlYXRlQXNzZW1ibHkob3V0ZGlyKTtcblxuICBjb250ZXh0T3ZlcmZsb3dDbGVhbnVwKGNvbnRleHRPdmVyZmxvd0xvY2F0aW9uLCBhc3NlbWJseSk7XG5cbiAgcmV0dXJuIHsgYXNzZW1ibHksIGxvY2s6IGF3YWl0IHdyaXRlckxvY2suY29udmVydFRvUmVhZGVyTG9jaygpIH07XG5cbiAgYXN5bmMgZnVuY3Rpb24gZXhlYyhjb21tYW5kQW5kQXJnczogc3RyaW5nKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KChvaywgZmFpbCkgPT4ge1xuICAgICAgLy8gV2UgdXNlIGEgc2xpZ2h0bHkgbG93ZXItbGV2ZWwgaW50ZXJmYWNlIHRvOlxuICAgICAgLy9cbiAgICAgIC8vIC0gUGFzcyBhcmd1bWVudHMgaW4gYW4gYXJyYXkgaW5zdGVhZCBvZiBhIHN0cmluZywgdG8gZ2V0IGFyb3VuZCBhXG4gICAgICAvLyAgIG51bWJlciBvZiBxdW90aW5nIGlzc3VlcyBpbnRyb2R1Y2VkIGJ5IHRoZSBpbnRlcm1lZGlhdGUgc2hlbGwgbGF5ZXJcbiAgICAgIC8vICAgKHdoaWNoIHdvdWxkIGJlIGRpZmZlcmVudCBiZXR3ZWVuIExpbnV4IGFuZCBXaW5kb3dzKS5cbiAgICAgIC8vXG4gICAgICAvLyAtIEluaGVyaXQgc3RkZXJyIGZyb20gY29udHJvbGxpbmcgdGVybWluYWwuIFdlIGRvbid0IHVzZSB0aGUgY2FwdHVyZWQgdmFsdWVcbiAgICAgIC8vICAgYW55d2F5LCBhbmQgaWYgdGhlIHN1YnByb2Nlc3MgaXMgcHJpbnRpbmcgdG8gaXQgZm9yIGRlYnVnZ2luZyBwdXJwb3NlcyB0aGVcbiAgICAgIC8vICAgdXNlciBnZXRzIHRvIHNlZSBpdCBzb29uZXIuIFBsdXMsIGNhcHR1cmluZyBkb2Vzbid0IGludGVyYWN0IG5pY2VseSB3aXRoIHNvbWVcbiAgICAgIC8vICAgcHJvY2Vzc2VzIGxpa2UgTWF2ZW4uXG4gICAgICBjb25zdCBwcm9jID0gY2hpbGRQcm9jZXNzLnNwYXduKGNvbW1hbmRBbmRBcmdzLCB7XG4gICAgICAgIHN0ZGlvOiBbJ2lnbm9yZScsICdpbmhlcml0JywgJ2luaGVyaXQnXSxcbiAgICAgICAgZGV0YWNoZWQ6IGZhbHNlLFxuICAgICAgICBzaGVsbDogdHJ1ZSxcbiAgICAgICAgZW52OiB7XG4gICAgICAgICAgLi4ucHJvY2Vzcy5lbnYsXG4gICAgICAgICAgLi4uZW52LFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIHByb2Mub24oJ2Vycm9yJywgZmFpbCk7XG5cbiAgICAgIHByb2Mub24oJ2V4aXQnLCBjb2RlID0+IHtcbiAgICAgICAgaWYgKGNvZGUgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gb2soKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWJ1ZygnZmFpbGVkIGNvbW1hbmQ6JywgY29tbWFuZEFuZEFyZ3MpO1xuICAgICAgICAgIHJldHVybiBmYWlsKG5ldyBFcnJvcihgU3VicHJvY2VzcyBleGl0ZWQgd2l0aCBlcnJvciAke2NvZGV9YCkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXNzZW1ibHkgd2l0aCBlcnJvciBoYW5kbGluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQXNzZW1ibHkoYXBwRGlyOiBzdHJpbmcpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IGN4YXBpLkNsb3VkQXNzZW1ibHkoYXBwRGlyLCB7XG4gICAgICAvLyBXZSBzb3J0IGFzIHdlIGRlcGxveVxuICAgICAgdG9wb1NvcnQ6IGZhbHNlLFxuICAgIH0pO1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgaWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoY3hzY2hlbWEuVkVSU0lPTl9NSVNNQVRDSCkpIHtcbiAgICAgIC8vIHRoaXMgbWVhbnMgdGhlIENMSSB2ZXJzaW9uIGlzIHRvbyBvbGQuXG4gICAgICAvLyB3ZSBpbnN0cnVjdCB0aGUgdXNlciB0byB1cGdyYWRlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGlzIENESyBDTEkgaXMgbm90IGNvbXBhdGlibGUgd2l0aCB0aGUgQ0RLIGxpYnJhcnkgdXNlZCBieSB5b3VyIGFwcGxpY2F0aW9uLiBQbGVhc2UgdXBncmFkZSB0aGUgQ0xJIHRvIHRoZSBsYXRlc3QgdmVyc2lvbi5cXG4oJHtlcnJvci5tZXNzYWdlfSlgKTtcbiAgICB9XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuLyoqXG4gKiBJZiB3ZSBkb24ndCBoYXZlIHJlZ2lvbi9hY2NvdW50IGRlZmluZWQgaW4gY29udGV4dCwgd2UgZmFsbCBiYWNrIHRvIHRoZSBkZWZhdWx0IFNESyBiZWhhdmlvclxuICogd2hlcmUgcmVnaW9uIGlzIHJldHJpZXZlZCBmcm9tIH4vLmF3cy9jb25maWcgYW5kIGFjY291bnQgaXMgYmFzZWQgb24gZGVmYXVsdCBjcmVkZW50aWFscyBwcm92aWRlclxuICogY2hhaW4gYW5kIHRoZW4gU1RTIGlzIHF1ZXJpZWQuXG4gKlxuICogVGhpcyBpcyBkb25lIG9wcG9ydHVuaXN0aWNhbGx5OiBmb3IgZXhhbXBsZSwgaWYgd2UgY2FuJ3QgYWNjZXNzIFNUUyBmb3Igc29tZSByZWFzb24gb3IgdGhlIHJlZ2lvblxuICogaXMgbm90IGNvbmZpZ3VyZWQsIHRoZSBjb250ZXh0IHZhbHVlIHdpbGwgYmUgJ251bGwnIGFuZCB0aGVyZSBjb3VsZCBmYWlsdXJlcyBkb3duIHRoZSBsaW5lLiBJblxuICogc29tZSBjYXNlcywgc3ludGhlc2lzIGRvZXMgbm90IHJlcXVpcmUgcmVnaW9uL2FjY291bnQgaW5mb3JtYXRpb24gYXQgYWxsLCBzbyB0aGF0IG1pZ2h0IGJlIHBlcmZlY3RseVxuICogZmluZSBpbiBjZXJ0YWluIHNjZW5hcmlvcy5cbiAqXG4gKiBAcGFyYW0gY29udGV4dCBUaGUgY29udGV4dCBrZXkvdmFsdWUgYmFzaC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByZXBhcmVEZWZhdWx0RW52aXJvbm1lbnQoYXdzOiBTZGtQcm92aWRlcik6IFByb21pc2U8eyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfT4ge1xuICBjb25zdCBlbnY6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7IH07XG5cbiAgZW52W2N4YXBpLkRFRkFVTFRfUkVHSU9OX0VOVl0gPSBhd3MuZGVmYXVsdFJlZ2lvbjtcbiAgZGVidWcoYFNldHRpbmcgXCIke2N4YXBpLkRFRkFVTFRfUkVHSU9OX0VOVn1cIiBlbnZpcm9ubWVudCB2YXJpYWJsZSB0b2AsIGVudltjeGFwaS5ERUZBVUxUX1JFR0lPTl9FTlZdKTtcblxuICBjb25zdCBhY2NvdW50SWQgPSAoYXdhaXQgYXdzLmRlZmF1bHRBY2NvdW50KCkpPy5hY2NvdW50SWQ7XG4gIGlmIChhY2NvdW50SWQpIHtcbiAgICBlbnZbY3hhcGkuREVGQVVMVF9BQ0NPVU5UX0VOVl0gPSBhY2NvdW50SWQ7XG4gICAgZGVidWcoYFNldHRpbmcgXCIke2N4YXBpLkRFRkFVTFRfQUNDT1VOVF9FTlZ9XCIgZW52aXJvbm1lbnQgdmFyaWFibGUgdG9gLCBlbnZbY3hhcGkuREVGQVVMVF9BQ0NPVU5UX0VOVl0pO1xuICB9XG5cbiAgcmV0dXJuIGVudjtcbn1cblxuLyoqXG4gKiBTZXR0aW5ncyByZWxhdGVkIHRvIHN5bnRoZXNpcyBhcmUgcmVhZCBmcm9tIGNvbnRleHQuXG4gKiBUaGUgbWVyZ2luZyBvZiB2YXJpb3VzIGNvbmZpZ3VyYXRpb24gc291cmNlcyBsaWtlIGNsaSBhcmdzIG9yIGNkay5qc29uIGhhcyBhbHJlYWR5IGhhcHBlbmVkLlxuICogV2Ugbm93IG5lZWQgdG8gc2V0IHRoZSBmaW5hbCB2YWx1ZXMgdG8gdGhlIGNvbnRleHQuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcmVwYXJlQ29udGV4dChjb25maWc6IENvbmZpZ3VyYXRpb24sIGVudjogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCB1bmRlZmluZWR9KSB7XG4gIGNvbnN0IGNvbnRleHQgPSBjb25maWcuY29udGV4dC5hbGw7XG5cbiAgY29uc3QgZGVidWdNb2RlOiBib29sZWFuID0gY29uZmlnLnNldHRpbmdzLmdldChbJ2RlYnVnJ10pID8/IHRydWU7XG4gIGlmIChkZWJ1Z01vZGUpIHtcbiAgICBlbnYuQ0RLX0RFQlVHID0gJ3RydWUnO1xuICB9XG5cbiAgY29uc3QgcGF0aE1ldGFkYXRhOiBib29sZWFuID0gY29uZmlnLnNldHRpbmdzLmdldChbJ3BhdGhNZXRhZGF0YSddKSA/PyB0cnVlO1xuICBpZiAocGF0aE1ldGFkYXRhKSB7XG4gICAgY29udGV4dFtjeGFwaS5QQVRIX01FVEFEQVRBX0VOQUJMRV9DT05URVhUXSA9IHRydWU7XG4gIH1cblxuICBjb25zdCBhc3NldE1ldGFkYXRhOiBib29sZWFuID0gY29uZmlnLnNldHRpbmdzLmdldChbJ2Fzc2V0TWV0YWRhdGEnXSkgPz8gdHJ1ZTtcbiAgaWYgKGFzc2V0TWV0YWRhdGEpIHtcbiAgICBjb250ZXh0W2N4YXBpLkFTU0VUX1JFU09VUkNFX01FVEFEQVRBX0VOQUJMRURfQ09OVEVYVF0gPSB0cnVlO1xuICB9XG5cbiAgY29uc3QgdmVyc2lvblJlcG9ydGluZzogYm9vbGVhbiA9IGNvbmZpZy5zZXR0aW5ncy5nZXQoWyd2ZXJzaW9uUmVwb3J0aW5nJ10pID8/IHRydWU7XG4gIGlmICh2ZXJzaW9uUmVwb3J0aW5nKSB7IGNvbnRleHRbY3hhcGkuQU5BTFlUSUNTX1JFUE9SVElOR19FTkFCTEVEX0NPTlRFWFRdID0gdHJ1ZTsgfVxuICAvLyBXZSBuZWVkIHRvIGtlZXAgb24gZG9pbmcgdGhpcyBmb3IgZnJhbWV3b3JrIHZlcnNpb24gZnJvbSBiZWZvcmUgdGhpcyBmbGFnIHdhcyBkZXByZWNhdGVkLlxuICBpZiAoIXZlcnNpb25SZXBvcnRpbmcpIHsgY29udGV4dFsnYXdzOmNkazpkaXNhYmxlLXZlcnNpb24tcmVwb3J0aW5nJ10gPSB0cnVlOyB9XG5cbiAgY29uc3Qgc3RhZ2luZ0VuYWJsZWQgPSBjb25maWcuc2V0dGluZ3MuZ2V0KFsnc3RhZ2luZyddKSA/PyB0cnVlO1xuICBpZiAoIXN0YWdpbmdFbmFibGVkKSB7XG4gICAgY29udGV4dFtjeGFwaS5ESVNBQkxFX0FTU0VUX1NUQUdJTkdfQ09OVEVYVF0gPSB0cnVlO1xuICB9XG5cbiAgY29uc3QgYnVuZGxpbmdTdGFja3MgPSBjb25maWcuc2V0dGluZ3MuZ2V0KFsnYnVuZGxpbmdTdGFja3MnXSkgPz8gWycqKiddO1xuICBjb250ZXh0W2N4YXBpLkJVTkRMSU5HX1NUQUNLU10gPSBidW5kbGluZ1N0YWNrcztcblxuICBkZWJ1ZygnY29udGV4dDonLCBjb250ZXh0KTtcblxuICByZXR1cm4gY29udGV4dDtcbn1cblxuLyoqXG4gKiBNYWtlIHN1cmUgdGhlICdhcHAnIGlzIGFuIGFycmF5XG4gKlxuICogSWYgaXQncyBhIHN0cmluZywgc3BsaXQgb24gc3BhY2VzIGFzIGEgdHJpdmlhbCB3YXkgb2YgdG9rZW5pemluZyB0aGUgY29tbWFuZCBsaW5lLlxuICovXG5mdW5jdGlvbiBhcHBUb0FycmF5KGFwcDogYW55KSB7XG4gIHJldHVybiB0eXBlb2YgYXBwID09PSAnc3RyaW5nJyA/IGFwcC5zcGxpdCgnICcpIDogYXBwO1xufVxuXG50eXBlIENvbW1hbmRHZW5lcmF0b3IgPSAoZmlsZTogc3RyaW5nKSA9PiBzdHJpbmdbXTtcblxuLyoqXG4gKiBFeGVjdXRlIHRoZSBnaXZlbiBmaWxlIHdpdGggdGhlIHNhbWUgJ25vZGUnIHByb2Nlc3MgYXMgaXMgcnVubmluZyB0aGUgY3VycmVudCBwcm9jZXNzXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVOb2RlKHNjcmlwdEZpbGU6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgcmV0dXJuIFtwcm9jZXNzLmV4ZWNQYXRoLCBzY3JpcHRGaWxlXTtcbn1cblxuLyoqXG4gKiBNYXBwaW5nIG9mIGV4dGVuc2lvbnMgdG8gY29tbWFuZC1saW5lIGdlbmVyYXRvcnNcbiAqL1xuY29uc3QgRVhURU5TSU9OX01BUCA9IG5ldyBNYXA8c3RyaW5nLCBDb21tYW5kR2VuZXJhdG9yPihbXG4gIFsnLmpzJywgZXhlY3V0ZU5vZGVdLFxuXSk7XG5cbi8qKlxuICogR3Vlc3MgdGhlIGV4ZWN1dGFibGUgZnJvbSB0aGUgY29tbWFuZC1saW5lIGFyZ3VtZW50XG4gKlxuICogT25seSBkbyB0aGlzIGlmIHRoZSBmaWxlIGlzIE5PVCBtYXJrZWQgYXMgZXhlY3V0YWJsZS4gSWYgaXQgaXMsXG4gKiB3ZSdsbCBkZWZlciB0byB0aGUgc2hlYmFuZyBpbnNpZGUgdGhlIGZpbGUgaXRzZWxmLlxuICpcbiAqIElmIHdlJ3JlIG9uIFdpbmRvd3MsIHdlIEFMV0FZUyB0YWtlIHRoZSBoYW5kbGVyLCBzaW5jZSBpdCdzIGhhcmQgdG9cbiAqIHZlcmlmeSBpZiByZWdpc3RyeSBhc3NvY2lhdGlvbnMgaGF2ZSBvciBoYXZlIG5vdCBiZWVuIHNldCB1cCBmb3IgdGhpc1xuICogZmlsZSB0eXBlLCBzbyB3ZSdsbCBhc3N1bWUgdGhlIHdvcnN0IGFuZCB0YWtlIGNvbnRyb2wuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGd1ZXNzRXhlY3V0YWJsZShjb21tYW5kTGluZTogc3RyaW5nW10pIHtcbiAgaWYgKGNvbW1hbmRMaW5lLmxlbmd0aCA9PT0gMSkge1xuICAgIGxldCBmc3RhdDtcblxuICAgIHRyeSB7XG4gICAgICBmc3RhdCA9IGF3YWl0IGZzLnN0YXQoY29tbWFuZExpbmVbMF0pO1xuICAgIH0gY2F0Y2gge1xuICAgICAgZGVidWcoYE5vdCBhIGZpbGU6ICcke2NvbW1hbmRMaW5lWzBdfScuIFVzaW5nICcke2NvbW1hbmRMaW5lfScgYXMgY29tbWFuZC1saW5lYCk7XG4gICAgICByZXR1cm4gY29tbWFuZExpbmU7XG4gICAgfVxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICBjb25zdCBpc0V4ZWN1dGFibGUgPSAoZnN0YXQubW9kZSAmIGZzLmNvbnN0YW50cy5YX09LKSAhPT0gMDtcbiAgICBjb25zdCBpc1dpbmRvd3MgPSBwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInO1xuXG4gICAgY29uc3QgaGFuZGxlciA9IEVYVEVOU0lPTl9NQVAuZ2V0KHBhdGguZXh0bmFtZShjb21tYW5kTGluZVswXSkpO1xuICAgIGlmIChoYW5kbGVyICYmICghaXNFeGVjdXRhYmxlIHx8IGlzV2luZG93cykpIHtcbiAgICAgIHJldHVybiBoYW5kbGVyKGNvbW1hbmRMaW5lWzBdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbW1hbmRMaW5lO1xufVxuXG5mdW5jdGlvbiBjb250ZXh0T3ZlcmZsb3dDbGVhbnVwKGxvY2F0aW9uOiBzdHJpbmcgfCB1bmRlZmluZWQsIGFzc2VtYmx5OiBjeGFwaS5DbG91ZEFzc2VtYmx5KSB7XG4gIGlmIChsb2NhdGlvbikge1xuICAgIGZzLnJlbW92ZVN5bmMocGF0aC5kaXJuYW1lKGxvY2F0aW9uKSk7XG5cbiAgICBjb25zdCB0cmVlID0gbG9hZFRyZWUoYXNzZW1ibHkpO1xuICAgIGNvbnN0IGZyYW1ld29ya0RvZXNOb3RTdXBwb3J0Q29udGV4dE92ZXJmbG93ID0gc29tZSh0cmVlLCBub2RlID0+IHtcbiAgICAgIGNvbnN0IGZxbiA9IG5vZGUuY29uc3RydWN0SW5mbz8uZnFuO1xuICAgICAgY29uc3QgdmVyc2lvbiA9IG5vZGUuY29uc3RydWN0SW5mbz8udmVyc2lvbjtcbiAgICAgIHJldHVybiAoZnFuID09PSAnYXdzLWNkay1saWIuQXBwJyAmJiB2ZXJzaW9uICE9IG51bGwgJiYgc2VtdmVyLmx0ZSh2ZXJzaW9uLCAnMi4zOC4wJykpXG4gICAgICAgIHx8IGZxbiA9PT0gJ0Bhd3MtY2RrL2NvcmUuQXBwJzsgLy8gdjFcbiAgICB9KTtcblxuICAgIC8vIFdlJ3JlIGRlYWxpbmcgd2l0aCBhbiBvbGQgdmVyc2lvbiBvZiB0aGUgZnJhbWV3b3JrIGhlcmUuIEl0IGlzIHVuYXdhcmUgb2YgdGhlIHRlbXBvcmFyeVxuICAgIC8vIGZpbGUsIHdoaWNoIG1lYW5zIHRoYXQgaXQgd2lsbCBpZ25vcmUgdGhlIGNvbnRleHQgb3ZlcmZsb3cuXG4gICAgaWYgKGZyYW1ld29ya0RvZXNOb3RTdXBwb3J0Q29udGV4dE92ZXJmbG93KSB7XG4gICAgICB3YXJuaW5nKCdQYXJ0IG9mIHRoZSBjb250ZXh0IGNvdWxkIG5vdCBiZSBzZW50IHRvIHRoZSBhcHBsaWNhdGlvbi4gUGxlYXNlIHVwZGF0ZSB0aGUgQVdTIENESyBsaWJyYXJ5IHRvIHRoZSBsYXRlc3QgdmVyc2lvbi4nKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3BhY2VBdmFpbGFibGVGb3JDb250ZXh0KGVudjogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSwgbGltaXQ6IG51bWJlcikge1xuICBjb25zdCBzaXplID0gKHZhbHVlOiBzdHJpbmcpID0+IHZhbHVlICE9IG51bGwgPyBCdWZmZXIuYnl0ZUxlbmd0aCh2YWx1ZSkgOiAwO1xuXG4gIGNvbnN0IHVzZWRTcGFjZSA9IE9iamVjdC5lbnRyaWVzKGVudilcbiAgICAubWFwKChbaywgdl0pID0+IGsgPT09IGN4YXBpLkNPTlRFWFRfRU5WID8gc2l6ZShrKSA6IHNpemUoaykgKyBzaXplKHYpKVxuICAgIC5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKTtcblxuICByZXR1cm4gTWF0aC5tYXgoMCwgbGltaXQgLSB1c2VkU3BhY2UpO1xufVxuIl19