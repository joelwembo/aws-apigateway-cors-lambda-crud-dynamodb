"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EvaluateCloudFormationTemplate = exports.CfnEvaluationException = exports.LazyLookupExport = exports.LookupExportError = exports.LazyListStackResources = void 0;
class LazyListStackResources {
    constructor(sdk, stackName) {
        this.sdk = sdk;
        this.stackName = stackName;
    }
    async listStackResources() {
        if (this.stackResources === undefined) {
            this.stackResources = this.getStackResources(undefined);
        }
        return this.stackResources;
    }
    async getStackResources(nextToken) {
        const ret = new Array();
        return this.sdk.cloudFormation().listStackResources({
            StackName: this.stackName,
            NextToken: nextToken,
        }).promise().then(async (stackResourcesResponse) => {
            ret.push(...(stackResourcesResponse.StackResourceSummaries ?? []));
            if (stackResourcesResponse.NextToken) {
                ret.push(...await this.getStackResources(stackResourcesResponse.NextToken));
            }
            return ret;
        });
    }
}
exports.LazyListStackResources = LazyListStackResources;
class LookupExportError extends Error {
}
exports.LookupExportError = LookupExportError;
class LazyLookupExport {
    constructor(sdk) {
        this.sdk = sdk;
        this.cachedExports = {};
    }
    async lookupExport(name) {
        if (this.cachedExports[name]) {
            return this.cachedExports[name];
        }
        for await (const cfnExport of this.listExports()) {
            if (!cfnExport.Name) {
                continue; // ignore any result that omits a name
            }
            this.cachedExports[cfnExport.Name] = cfnExport;
            if (cfnExport.Name === name) {
                return cfnExport;
            }
        }
        return undefined; // export not found
    }
    async *listExports() {
        let nextToken = undefined;
        while (true) {
            const response = await this.sdk.cloudFormation().listExports({
                NextToken: nextToken,
            }).promise();
            for (const cfnExport of response.Exports ?? []) {
                yield cfnExport;
            }
            if (!response.NextToken) {
                return;
            }
            nextToken = response.NextToken;
        }
    }
}
exports.LazyLookupExport = LazyLookupExport;
class CfnEvaluationException extends Error {
}
exports.CfnEvaluationException = CfnEvaluationException;
class EvaluateCloudFormationTemplate {
    constructor(props) {
        this.stackName = props.stackName;
        this.template = props.template;
        this.context = {
            'AWS::AccountId': props.account,
            'AWS::Region': props.region,
            'AWS::Partition': props.partition,
            ...props.parameters,
        };
        this.account = props.account;
        this.region = props.region;
        this.partition = props.partition;
        this.urlSuffix = props.urlSuffix;
        this.sdk = props.sdk;
        // We need names of nested stack so we can evaluate cross stack references
        this.nestedStackNames = props.nestedStackNames ?? {};
        // The current resources of the Stack.
        // We need them to figure out the physical name of a resource in case it wasn't specified by the user.
        // We fetch it lazily, to save a service call, in case all hotswapped resources have their physical names set.
        this.stackResources = new LazyListStackResources(this.sdk, this.stackName);
        // CloudFormation Exports lookup to be able to resolve Fn::ImportValue intrinsics in template
        this.lookupExport = new LazyLookupExport(this.sdk);
    }
    // clones current EvaluateCloudFormationTemplate object, but updates the stack name
    async createNestedEvaluateCloudFormationTemplate(stackName, nestedTemplate, nestedStackParameters) {
        const evaluatedParams = await this.evaluateCfnExpression(nestedStackParameters);
        return new EvaluateCloudFormationTemplate({
            stackName,
            template: nestedTemplate,
            parameters: evaluatedParams,
            account: this.account,
            region: this.region,
            partition: this.partition,
            urlSuffix: this.urlSuffix,
            sdk: this.sdk,
            nestedStackNames: this.nestedStackNames,
        });
    }
    async establishResourcePhysicalName(logicalId, physicalNameInCfnTemplate) {
        if (physicalNameInCfnTemplate != null) {
            try {
                return await this.evaluateCfnExpression(physicalNameInCfnTemplate);
            }
            catch (e) {
                // If we can't evaluate the resource's name CloudFormation expression,
                // just look it up in the currently deployed Stack
                if (!(e instanceof CfnEvaluationException)) {
                    throw e;
                }
            }
        }
        return this.findPhysicalNameFor(logicalId);
    }
    async findPhysicalNameFor(logicalId) {
        const stackResources = await this.stackResources.listStackResources();
        return stackResources.find(sr => sr.LogicalResourceId === logicalId)?.PhysicalResourceId;
    }
    async findLogicalIdForPhysicalName(physicalName) {
        const stackResources = await this.stackResources.listStackResources();
        return stackResources.find(sr => sr.PhysicalResourceId === physicalName)?.LogicalResourceId;
    }
    findReferencesTo(logicalId) {
        const ret = new Array();
        for (const [resourceLogicalId, resourceDef] of Object.entries(this.template?.Resources ?? {})) {
            if (logicalId !== resourceLogicalId && this.references(logicalId, resourceDef)) {
                ret.push({
                    ...resourceDef,
                    LogicalId: resourceLogicalId,
                });
            }
        }
        return ret;
    }
    async evaluateCfnExpression(cfnExpression) {
        const self = this;
        /**
         * Evaluates CloudFormation intrinsic functions
         *
         * Note that supported intrinsic functions are documented in README.md -- please update
         * list of supported functions when adding new evaluations
         *
         * See: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference.html
         */
        class CfnIntrinsics {
            evaluateIntrinsic(intrinsic) {
                const intrinsicFunc = this[intrinsic.name];
                if (!intrinsicFunc) {
                    throw new CfnEvaluationException(`CloudFormation function ${intrinsic.name} is not supported`);
                }
                const argsAsArray = Array.isArray(intrinsic.args) ? intrinsic.args : [intrinsic.args];
                return intrinsicFunc.apply(this, argsAsArray);
            }
            async 'Fn::Join'(separator, args) {
                const evaluatedArgs = await self.evaluateCfnExpression(args);
                return evaluatedArgs.join(separator);
            }
            async 'Fn::Split'(separator, args) {
                const evaluatedArgs = await self.evaluateCfnExpression(args);
                return evaluatedArgs.split(separator);
            }
            async 'Fn::Select'(index, args) {
                const evaluatedArgs = await self.evaluateCfnExpression(args);
                return evaluatedArgs[index];
            }
            async 'Ref'(logicalId) {
                const refTarget = await self.findRefTarget(logicalId);
                if (refTarget) {
                    return refTarget;
                }
                else {
                    throw new CfnEvaluationException(`Parameter or resource '${logicalId}' could not be found for evaluation`);
                }
            }
            async 'Fn::GetAtt'(logicalId, attributeName) {
                // ToDo handle the 'logicalId.attributeName' form of Fn::GetAtt
                const attrValue = await self.findGetAttTarget(logicalId, attributeName);
                if (attrValue) {
                    return attrValue;
                }
                else {
                    throw new CfnEvaluationException(`Attribute '${attributeName}' of resource '${logicalId}' could not be found for evaluation`);
                }
            }
            async 'Fn::Sub'(template, explicitPlaceholders) {
                const placeholders = explicitPlaceholders
                    ? await self.evaluateCfnExpression(explicitPlaceholders)
                    : {};
                return asyncGlobalReplace(template, /\${([^}]*)}/g, key => {
                    if (key in placeholders) {
                        return placeholders[key];
                    }
                    else {
                        const splitKey = key.split('.');
                        return splitKey.length === 1
                            ? this.Ref(key)
                            : this['Fn::GetAtt'](splitKey[0], splitKey.slice(1).join('.'));
                    }
                });
            }
            async 'Fn::ImportValue'(name) {
                const exported = await self.lookupExport.lookupExport(name);
                if (!exported) {
                    throw new CfnEvaluationException(`Export '${name}' could not be found for evaluation`);
                }
                if (!exported.Value) {
                    throw new CfnEvaluationException(`Export '${name}' exists without a value`);
                }
                return exported.Value;
            }
        }
        if (cfnExpression == null) {
            return cfnExpression;
        }
        if (Array.isArray(cfnExpression)) {
            return Promise.all(cfnExpression.map(expr => this.evaluateCfnExpression(expr)));
        }
        if (typeof cfnExpression === 'object') {
            const intrinsic = this.parseIntrinsic(cfnExpression);
            if (intrinsic) {
                return new CfnIntrinsics().evaluateIntrinsic(intrinsic);
            }
            else {
                const ret = {};
                for (const [key, val] of Object.entries(cfnExpression)) {
                    ret[key] = await this.evaluateCfnExpression(val);
                }
                return ret;
            }
        }
        return cfnExpression;
    }
    references(logicalId, templateElement) {
        if (typeof templateElement === 'string') {
            return logicalId === templateElement;
        }
        if (templateElement == null) {
            return false;
        }
        if (Array.isArray(templateElement)) {
            return templateElement.some(el => this.references(logicalId, el));
        }
        if (typeof templateElement === 'object') {
            return Object.values(templateElement).some(el => this.references(logicalId, el));
        }
        return false;
    }
    parseIntrinsic(x) {
        const keys = Object.keys(x);
        if (keys.length === 1 && (keys[0].startsWith('Fn::') || keys[0] === 'Ref')) {
            return {
                name: keys[0],
                args: x[keys[0]],
            };
        }
        return undefined;
    }
    async findRefTarget(logicalId) {
        // first, check to see if the Ref is a Parameter who's value we have
        if (logicalId === 'AWS::URLSuffix') {
            if (!this.cachedUrlSuffix) {
                this.cachedUrlSuffix = this.urlSuffix(this.region);
            }
            return this.cachedUrlSuffix;
        }
        // Try finding the ref in the passed in parameters
        const parameterTarget = this.context[logicalId];
        if (parameterTarget) {
            return parameterTarget;
        }
        // If not in the passed in parameters, see if there is a default value in the template parameter that was not passed in
        const defaultParameterValue = this.template.Parameters?.[logicalId]?.Default;
        if (defaultParameterValue) {
            return defaultParameterValue;
        }
        // if it's not a Parameter, we need to search in the current Stack resources
        return this.findGetAttTarget(logicalId);
    }
    async findGetAttTarget(logicalId, attribute) {
        // Handle case where the attribute is referencing a stack output (used in nested stacks to share parameters)
        // See https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/quickref-cloudformation.html#w2ab1c17c23c19b5
        if (logicalId === 'Outputs' && attribute) {
            return this.evaluateCfnExpression(this.template.Outputs[attribute]?.Value);
        }
        const stackResources = await this.stackResources.listStackResources();
        const foundResource = stackResources.find(sr => sr.LogicalResourceId === logicalId);
        if (!foundResource) {
            return undefined;
        }
        if (foundResource.ResourceType == 'AWS::CloudFormation::Stack' && attribute?.startsWith('Outputs.')) {
            // need to resolve attributes from another stack's Output section
            const dependantStackName = this.findNestedStack(logicalId, this.nestedStackNames);
            if (!dependantStackName) {
                //this is a newly created nested stack and cannot be hotswapped
                return undefined;
            }
            const dependantStackTemplate = this.template.Resources[logicalId];
            const evaluateCfnTemplate = await this.createNestedEvaluateCloudFormationTemplate(dependantStackName, dependantStackTemplate?.Properties?.NestedTemplate, dependantStackTemplate.newValue?.Properties?.Parameters);
            // Split Outputs.<refName> into 'Outputs' and '<refName>' and recursively call evaluate
            return evaluateCfnTemplate.evaluateCfnExpression({ 'Fn::GetAtt': attribute.split(/\.(.*)/s) });
        }
        // now, we need to format the appropriate identifier depending on the resource type,
        // and the requested attribute name
        return this.formatResourceAttribute(foundResource, attribute);
    }
    findNestedStack(logicalId, nestedStackNames) {
        for (const [nestedStackLogicalId, { nestedChildStackNames, nestedStackPhysicalName }] of Object.entries(nestedStackNames)) {
            if (nestedStackLogicalId === logicalId) {
                return nestedStackPhysicalName;
            }
            const checkInNestedChildStacks = this.findNestedStack(logicalId, nestedChildStackNames);
            if (checkInNestedChildStacks)
                return checkInNestedChildStacks;
        }
        return undefined;
    }
    formatResourceAttribute(resource, attribute) {
        const physicalId = resource.PhysicalResourceId;
        // no attribute means Ref expression, for which we use the physical ID directly
        if (!attribute) {
            return physicalId;
        }
        const resourceTypeFormats = RESOURCE_TYPE_ATTRIBUTES_FORMATS[resource.ResourceType];
        if (!resourceTypeFormats) {
            throw new CfnEvaluationException(`We don't support attributes of the '${resource.ResourceType}' resource. This is a CDK limitation. ` +
                'Please report it at https://github.com/aws/aws-cdk/issues/new/choose');
        }
        const attributeFmtFunc = resourceTypeFormats[attribute];
        if (!attributeFmtFunc) {
            throw new CfnEvaluationException(`We don't support the '${attribute}' attribute of the '${resource.ResourceType}' resource. This is a CDK limitation. ` +
                'Please report it at https://github.com/aws/aws-cdk/issues/new/choose');
        }
        const service = this.getServiceOfResource(resource);
        const resourceTypeArnPart = this.getResourceTypeArnPartOfResource(resource);
        return attributeFmtFunc({
            partition: this.partition,
            service,
            region: this.region,
            account: this.account,
            resourceType: resourceTypeArnPart,
            resourceName: physicalId,
        });
    }
    getServiceOfResource(resource) {
        return resource.ResourceType.split('::')[1].toLowerCase();
    }
    getResourceTypeArnPartOfResource(resource) {
        const resourceType = resource.ResourceType;
        const specialCaseResourceType = RESOURCE_TYPE_SPECIAL_NAMES[resourceType]?.resourceType;
        return specialCaseResourceType
            ? specialCaseResourceType
            // this is the default case
            : resourceType.split('::')[2].toLowerCase();
    }
}
exports.EvaluateCloudFormationTemplate = EvaluateCloudFormationTemplate;
/**
 * Usually, we deduce the names of the service and the resource type used to format the ARN from the CloudFormation resource type.
 * For a CFN type like AWS::Service::ResourceType, the second segment becomes the service name, and the third the resource type
 * (after converting both of them to lowercase).
 * However, some resource types break this simple convention, and we need to special-case them.
 * This map is for storing those cases.
 */
const RESOURCE_TYPE_SPECIAL_NAMES = {
    'AWS::Events::EventBus': {
        resourceType: 'event-bus',
    },
};
const RESOURCE_TYPE_ATTRIBUTES_FORMATS = {
    'AWS::IAM::Role': { Arn: iamArnFmt },
    'AWS::IAM::User': { Arn: iamArnFmt },
    'AWS::IAM::Group': { Arn: iamArnFmt },
    'AWS::S3::Bucket': { Arn: s3ArnFmt },
    'AWS::Lambda::Function': { Arn: stdColonResourceArnFmt },
    'AWS::Events::EventBus': {
        Arn: stdSlashResourceArnFmt,
        // the name attribute of the EventBus is the same as the Ref
        Name: parts => parts.resourceName,
    },
    'AWS::DynamoDB::Table': { Arn: stdSlashResourceArnFmt },
    'AWS::AppSync::GraphQLApi': { ApiId: appsyncGraphQlApiApiIdFmt },
    'AWS::AppSync::FunctionConfiguration': { FunctionId: appsyncGraphQlFunctionIDFmt },
    'AWS::AppSync::DataSource': { Name: appsyncGraphQlDataSourceNameFmt },
};
function iamArnFmt(parts) {
    // we skip region for IAM resources
    return `arn:${parts.partition}:${parts.service}::${parts.account}:${parts.resourceType}/${parts.resourceName}`;
}
function s3ArnFmt(parts) {
    // we skip account, region and resourceType for S3 resources
    return `arn:${parts.partition}:${parts.service}:::${parts.resourceName}`;
}
function stdColonResourceArnFmt(parts) {
    // this is a standard format for ARNs like: arn:aws:service:region:account:resourceType:resourceName
    return `arn:${parts.partition}:${parts.service}:${parts.region}:${parts.account}:${parts.resourceType}:${parts.resourceName}`;
}
function stdSlashResourceArnFmt(parts) {
    // this is a standard format for ARNs like: arn:aws:service:region:account:resourceType/resourceName
    return `arn:${parts.partition}:${parts.service}:${parts.region}:${parts.account}:${parts.resourceType}/${parts.resourceName}`;
}
function appsyncGraphQlApiApiIdFmt(parts) {
    // arn:aws:appsync:us-east-1:111111111111:apis/<apiId>
    return parts.resourceName.split('/')[1];
}
function appsyncGraphQlFunctionIDFmt(parts) {
    // arn:aws:appsync:us-east-1:111111111111:apis/<apiId>/functions/<functionId>
    return parts.resourceName.split('/')[3];
}
function appsyncGraphQlDataSourceNameFmt(parts) {
    // arn:aws:appsync:us-east-1:111111111111:apis/<apiId>/datasources/<name>
    return parts.resourceName.split('/')[3];
}
async function asyncGlobalReplace(str, regex, cb) {
    if (!regex.global) {
        throw new Error('Regex must be created with /g flag');
    }
    const ret = new Array();
    let start = 0;
    while (true) {
        const match = regex.exec(str);
        if (!match) {
            break;
        }
        ret.push(str.substring(start, match.index));
        ret.push(await cb(match[1]));
        start = regex.lastIndex;
    }
    ret.push(str.slice(start));
    return ret.join('');
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXZhbHVhdGUtY2xvdWRmb3JtYXRpb24tdGVtcGxhdGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJldmFsdWF0ZS1jbG91ZGZvcm1hdGlvbi10ZW1wbGF0ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFTQSxNQUFhLHNCQUFzQjtJQUdqQyxZQUE2QixHQUFTLEVBQW1CLFNBQWlCO1FBQTdDLFFBQUcsR0FBSCxHQUFHLENBQU07UUFBbUIsY0FBUyxHQUFULFNBQVMsQ0FBUTtJQUMxRSxDQUFDO0lBRU0sS0FBSyxDQUFDLGtCQUFrQjtRQUM3QixJQUFJLElBQUksQ0FBQyxjQUFjLEtBQUssU0FBUyxFQUFFO1lBQ3JDLElBQUksQ0FBQyxjQUFjLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLFNBQVMsQ0FBQyxDQUFDO1NBQ3pEO1FBQ0QsT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDO0lBQzdCLENBQUM7SUFFTyxLQUFLLENBQUMsaUJBQWlCLENBQUMsU0FBNkI7UUFDM0QsTUFBTSxHQUFHLEdBQUcsSUFBSSxLQUFLLEVBQTJDLENBQUM7UUFDakUsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLGNBQWMsRUFBRSxDQUFDLGtCQUFrQixDQUFDO1lBQ2xELFNBQVMsRUFBRSxJQUFJLENBQUMsU0FBUztZQUN6QixTQUFTLEVBQUUsU0FBUztTQUNyQixDQUFDLENBQUMsT0FBTyxFQUFFLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBQyxzQkFBc0IsRUFBQyxFQUFFO1lBQy9DLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLHNCQUFzQixDQUFDLHNCQUFzQixJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDbkUsSUFBSSxzQkFBc0IsQ0FBQyxTQUFTLEVBQUU7Z0JBQ3BDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxNQUFNLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxzQkFBc0IsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO2FBQzdFO1lBQ0Qs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TUFBTTtTQUFFO1FBRXRCLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFDNUMsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRTdCLEtBQUssR0FBRyxLQUFLLENBQUMsU0FBUyxDQUFDO0tBQ3pCO0lBQ0QsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7SUFFM0IsT0FBTyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ3RCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBBV1MgZnJvbSAnYXdzLXNkayc7XG5pbXBvcnQgeyBQcm9taXNlUmVzdWx0IH0gZnJvbSAnYXdzLXNkay9saWIvcmVxdWVzdCc7XG5pbXBvcnQgeyBJU0RLIH0gZnJvbSAnLi9hd3MtYXV0aCc7XG5pbXBvcnQgeyBOZXN0ZWRTdGFja05hbWVzIH0gZnJvbSAnLi9uZXN0ZWQtc3RhY2staGVscGVycyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGlzdFN0YWNrUmVzb3VyY2VzIHtcbiAgbGlzdFN0YWNrUmVzb3VyY2VzKCk6IFByb21pc2U8QVdTLkNsb3VkRm9ybWF0aW9uLlN0YWNrUmVzb3VyY2VTdW1tYXJ5W10+O1xufVxuXG5leHBvcnQgY2xhc3MgTGF6eUxpc3RTdGFja1Jlc291cmNlcyBpbXBsZW1lbnRzIExpc3RTdGFja1Jlc291cmNlcyB7XG4gIHByaXZhdGUgc3RhY2tSZXNvdXJjZXM6IFByb21pc2U8QVdTLkNsb3VkRm9ybWF0aW9uLlN0YWNrUmVzb3VyY2VTdW1tYXJ5W10+IHwgdW5kZWZpbmVkO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgc2RrOiBJU0RLLCBwcml2YXRlIHJlYWRvbmx5IHN0YWNrTmFtZTogc3RyaW5nKSB7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgbGlzdFN0YWNrUmVzb3VyY2VzKCk6IFByb21pc2U8QVdTLkNsb3VkRm9ybWF0aW9uLlN0YWNrUmVzb3VyY2VTdW1tYXJ5W10+IHtcbiAgICBpZiAodGhpcy5zdGFja1Jlc291cmNlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnN0YWNrUmVzb3VyY2VzID0gdGhpcy5nZXRTdGFja1Jlc291cmNlcyh1bmRlZmluZWQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zdGFja1Jlc291cmNlcztcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZ2V0U3RhY2tSZXNvdXJjZXMobmV4dFRva2VuOiBzdHJpbmcgfCB1bmRlZmluZWQpOiBQcm9taXNlPEFXUy5DbG91ZEZvcm1hdGlvbi5TdGFja1Jlc291cmNlU3VtbWFyeVtdPiB7XG4gICAgY29uc3QgcmV0ID0gbmV3IEFycmF5PEFXUy5DbG91ZEZvcm1hdGlvbi5TdGFja1Jlc291cmNlU3VtbWFyeT4oKTtcbiAgICByZXR1cm4gdGhpcy5zZGsuY2xvdWRGb3JtYXRpb24oKS5saXN0U3RhY2tSZXNvdXJjZXMoe1xuICAgICAgU3RhY2tOYW1lOiB0aGlzLnN0YWNrTmFtZSxcbiAgICAgIE5leHRUb2tlbjogbmV4dFRva2VuLFxuICAgIH0pLnByb21pc2UoKS50aGVuKGFzeW5jIHN0YWNrUmVzb3VyY2VzUmVzcG9uc2UgPT4ge1xuICAgICAgcmV0LnB1c2goLi4uKHN0YWNrUmVzb3VyY2VzUmVzcG9uc2UuU3RhY2tSZXNvdXJjZVN1bW1hcmllcyA/PyBbXSkpO1xuICAgICAgaWYgKHN0YWNrUmVzb3VyY2VzUmVzcG9uc2UuTmV4dFRva2VuKSB7XG4gICAgICAgIHJldC5wdXNoKC4uLmF3YWl0IHRoaXMuZ2V0U3RhY2tSZXNvdXJjZXMoc3RhY2tSZXNvdXJjZXNSZXNwb25zZS5OZXh0VG9rZW4pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBMb29rdXBFeHBvcnQge1xuICBsb29rdXBFeHBvcnQobmFtZTogc3RyaW5nKTogUHJvbWlzZTxBV1MuQ2xvdWRGb3JtYXRpb24uRXhwb3J0IHwgdW5kZWZpbmVkPjtcbn1cblxuZXhwb3J0IGNsYXNzIExvb2t1cEV4cG9ydEVycm9yIGV4dGVuZHMgRXJyb3IgeyB9XG5cbmV4cG9ydCBjbGFzcyBMYXp5TG9va3VwRXhwb3J0IGltcGxlbWVudHMgTG9va3VwRXhwb3J0IHtcbiAgcHJpdmF0ZSBjYWNoZWRFeHBvcnRzOiB7IFtuYW1lOiBzdHJpbmddOiBBV1MuQ2xvdWRGb3JtYXRpb24uRXhwb3J0IH0gPSB7fVxuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgc2RrOiBJU0RLKSB7IH1cblxuICBhc3luYyBsb29rdXBFeHBvcnQobmFtZTogc3RyaW5nKTogUHJvbWlzZTxBV1MuQ2xvdWRGb3JtYXRpb24uRXhwb3J0IHwgdW5kZWZpbmVkPiB7XG4gICAgaWYgKHRoaXMuY2FjaGVkRXhwb3J0c1tuYW1lXSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2FjaGVkRXhwb3J0c1tuYW1lXTtcbiAgICB9XG5cbiAgICBmb3IgYXdhaXQgKGNvbnN0IGNmbkV4cG9ydCBvZiB0aGlzLmxpc3RFeHBvcnRzKCkpIHtcbiAgICAgIGlmICghY2ZuRXhwb3J0Lk5hbWUpIHtcbiAgICAgICAgY29udGludWU7IC8vIGlnbm9yZSBhbnkgcmVzdWx0IHRoYXQgb21pdHMgYSBuYW1lXG4gICAgICB9XG4gICAgICB0aGlzLmNhY2hlZEV4cG9ydHNbY2ZuRXhwb3J0Lk5hbWVdID0gY2ZuRXhwb3J0O1xuXG4gICAgICBpZiAoY2ZuRXhwb3J0Lk5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGNmbkV4cG9ydDtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7IC8vIGV4cG9ydCBub3QgZm91bmRcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgKiBsaXN0RXhwb3J0cygpIHtcbiAgICBsZXQgbmV4dFRva2VuOiBzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlOiBQcm9taXNlUmVzdWx0PEFXUy5DbG91ZEZvcm1hdGlvbi5MaXN0RXhwb3J0c091dHB1dCwgQVdTLkFXU0Vycm9yPiA9IGF3YWl0IHRoaXMuc2RrLmNsb3VkRm9ybWF0aW9uKCkubGlzdEV4cG9ydHMoe1xuICAgICAgICBOZXh0VG9rZW46IG5leHRUb2tlbixcbiAgICAgIH0pLnByb21pc2UoKTtcblxuICAgICAgZm9yIChjb25zdCBjZm5FeHBvcnQgb2YgcmVzcG9uc2UuRXhwb3J0cyA/PyBbXSkge1xuICAgICAgICB5aWVsZCBjZm5FeHBvcnQ7XG4gICAgICB9XG5cbiAgICAgIGlmICghcmVzcG9uc2UuTmV4dFRva2VuKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG5leHRUb2tlbiA9IHJlc3BvbnNlLk5leHRUb2tlbjtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIENmbkV2YWx1YXRpb25FeGNlcHRpb24gZXh0ZW5kcyBFcnJvciB7IH1cblxuZXhwb3J0IGludGVyZmFjZSBSZXNvdXJjZURlZmluaXRpb24ge1xuICByZWFkb25seSBMb2dpY2FsSWQ6IHN0cmluZztcbiAgcmVhZG9ubHkgVHlwZTogc3RyaW5nO1xuICByZWFkb25seSBQcm9wZXJ0aWVzOiB7IFtwOiBzdHJpbmddOiBhbnkgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFdmFsdWF0ZUNsb3VkRm9ybWF0aW9uVGVtcGxhdGVQcm9wcyB7XG4gIHJlYWRvbmx5IHN0YWNrTmFtZTogc3RyaW5nO1xuICByZWFkb25seSB0ZW1wbGF0ZTogVGVtcGxhdGU7XG4gIHJlYWRvbmx5IHBhcmFtZXRlcnM6IHsgW3BhcmFtZXRlck5hbWU6IHN0cmluZ106IHN0cmluZyB9O1xuICByZWFkb25seSBhY2NvdW50OiBzdHJpbmc7XG4gIHJlYWRvbmx5IHJlZ2lvbjogc3RyaW5nO1xuICByZWFkb25seSBwYXJ0aXRpb246IHN0cmluZztcbiAgcmVhZG9ubHkgdXJsU3VmZml4OiAocmVnaW9uOiBzdHJpbmcpID0+IHN0cmluZztcbiAgcmVhZG9ubHkgc2RrOiBJU0RLO1xuICByZWFkb25seSBuZXN0ZWRTdGFja05hbWVzPzogeyBbbmVzdGVkU3RhY2tMb2dpY2FsSWQ6IHN0cmluZ106IE5lc3RlZFN0YWNrTmFtZXMgfTtcbn1cblxuZXhwb3J0IGNsYXNzIEV2YWx1YXRlQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZSB7XG4gIHByaXZhdGUgcmVhZG9ubHkgc3RhY2tOYW1lOiBzdHJpbmc7XG4gIHByaXZhdGUgcmVhZG9ubHkgdGVtcGxhdGU6IFRlbXBsYXRlO1xuICBwcml2YXRlIHJlYWRvbmx5IGNvbnRleHQ6IHsgW2s6IHN0cmluZ106IGFueSB9O1xuICBwcml2YXRlIHJlYWRvbmx5IGFjY291bnQ6IHN0cmluZztcbiAgcHJpdmF0ZSByZWFkb25seSByZWdpb246IHN0cmluZztcbiAgcHJpdmF0ZSByZWFkb25seSBwYXJ0aXRpb246IHN0cmluZztcbiAgcHJpdmF0ZSByZWFkb25seSB1cmxTdWZmaXg6IChyZWdpb246IHN0cmluZykgPT4gc3RyaW5nO1xuICBwcml2YXRlIHJlYWRvbmx5IHNkazogSVNESztcbiAgcHJpdmF0ZSByZWFkb25seSBuZXN0ZWRTdGFja05hbWVzOiB7IFtuZXN0ZWRTdGFja0xvZ2ljYWxJZDogc3RyaW5nXTogTmVzdGVkU3RhY2tOYW1lcyB9O1xuICBwcml2YXRlIHJlYWRvbmx5IHN0YWNrUmVzb3VyY2VzOiBMaXN0U3RhY2tSZXNvdXJjZXM7XG4gIHByaXZhdGUgcmVhZG9ubHkgbG9va3VwRXhwb3J0OiBMb29rdXBFeHBvcnQ7XG5cbiAgcHJpdmF0ZSBjYWNoZWRVcmxTdWZmaXg6IHN0cmluZyB8IHVuZGVmaW5lZDtcblxuICBjb25zdHJ1Y3Rvcihwcm9wczogRXZhbHVhdGVDbG91ZEZvcm1hdGlvblRlbXBsYXRlUHJvcHMpIHtcbiAgICB0aGlzLnN0YWNrTmFtZSA9IHByb3BzLnN0YWNrTmFtZTtcbiAgICB0aGlzLnRlbXBsYXRlID0gcHJvcHMudGVtcGxhdGU7XG4gICAgdGhpcy5jb250ZXh0ID0ge1xuICAgICAgJ0FXUzo6QWNjb3VudElkJzogcHJvcHMuYWNjb3VudCxcbiAgICAgICdBV1M6OlJlZ2lvbic6IHByb3BzLnJlZ2lvbixcbiAgICAgICdBV1M6OlBhcnRpdGlvbic6IHByb3BzLnBhcnRpdGlvbixcbiAgICAgIC4uLnByb3BzLnBhcmFtZXRlcnMsXG4gICAgfTtcbiAgICB0aGlzLmFjY291bnQgPSBwcm9wcy5hY2NvdW50O1xuICAgIHRoaXMucmVnaW9uID0gcHJvcHMucmVnaW9uO1xuICAgIHRoaXMucGFydGl0aW9uID0gcHJvcHMucGFydGl0aW9uO1xuICAgIHRoaXMudXJsU3VmZml4ID0gcHJvcHMudXJsU3VmZml4O1xuICAgIHRoaXMuc2RrID0gcHJvcHMuc2RrO1xuXG4gICAgLy8gV2UgbmVlZCBuYW1lcyBvZiBuZXN0ZWQgc3RhY2sgc28gd2UgY2FuIGV2YWx1YXRlIGNyb3NzIHN0YWNrIHJlZmVyZW5jZXNcbiAgICB0aGlzLm5lc3RlZFN0YWNrTmFtZXMgPSBwcm9wcy5uZXN0ZWRTdGFja05hbWVzID8/IHt9O1xuXG4gICAgLy8gVGhlIGN1cnJlbnQgcmVzb3VyY2VzIG9mIHRoZSBTdGFjay5cbiAgICAvLyBXZSBuZWVkIHRoZW0gdG8gZmlndXJlIG91dCB0aGUgcGh5c2ljYWwgbmFtZSBvZiBhIHJlc291cmNlIGluIGNhc2UgaXQgd2Fzbid0IHNwZWNpZmllZCBieSB0aGUgdXNlci5cbiAgICAvLyBXZSBmZXRjaCBpdCBsYXppbHksIHRvIHNhdmUgYSBzZXJ2aWNlIGNhbGwsIGluIGNhc2UgYWxsIGhvdHN3YXBwZWQgcmVzb3VyY2VzIGhhdmUgdGhlaXIgcGh5c2ljYWwgbmFtZXMgc2V0LlxuICAgIHRoaXMuc3RhY2tSZXNvdXJjZXMgPSBuZXcgTGF6eUxpc3RTdGFja1Jlc291cmNlcyh0aGlzLnNkaywgdGhpcy5zdGFja05hbWUpO1xuXG4gICAgLy8gQ2xvdWRGb3JtYXRpb24gRXhwb3J0cyBsb29rdXAgdG8gYmUgYWJsZSB0byByZXNvbHZlIEZuOjpJbXBvcnRWYWx1ZSBpbnRyaW5zaWNzIGluIHRlbXBsYXRlXG4gICAgdGhpcy5sb29rdXBFeHBvcnQgPSBuZXcgTGF6eUxvb2t1cEV4cG9ydCh0aGlzLnNkayk7XG4gIH1cblxuICAvLyBjbG9uZXMgY3VycmVudCBFdmFsdWF0ZUNsb3VkRm9ybWF0aW9uVGVtcGxhdGUgb2JqZWN0LCBidXQgdXBkYXRlcyB0aGUgc3RhY2sgbmFtZVxuICBwdWJsaWMgYXN5bmMgY3JlYXRlTmVzdGVkRXZhbHVhdGVDbG91ZEZvcm1hdGlvblRlbXBsYXRlKFxuICAgIHN0YWNrTmFtZTogc3RyaW5nLFxuICAgIG5lc3RlZFRlbXBsYXRlOiBUZW1wbGF0ZSxcbiAgICBuZXN0ZWRTdGFja1BhcmFtZXRlcnM6IHsgW3BhcmFtZXRlck5hbWU6IHN0cmluZ106IGFueSB9LFxuICApIHtcbiAgICBjb25zdCBldmFsdWF0ZWRQYXJhbXMgPSBhd2FpdCB0aGlzLmV2YWx1YXRlQ2ZuRXhwcmVzc2lvbihuZXN0ZWRTdGFja1BhcmFtZXRlcnMpO1xuICAgIHJldHVybiBuZXcgRXZhbHVhdGVDbG91ZEZvcm1hdGlvblRlbXBsYXRlKHtcbiAgICAgIHN0YWNrTmFtZSxcbiAgICAgIHRlbXBsYXRlOiBuZXN0ZWRUZW1wbGF0ZSxcbiAgICAgIHBhcmFtZXRlcnM6IGV2YWx1YXRlZFBhcmFtcyxcbiAgICAgIGFjY291bnQ6IHRoaXMuYWNjb3VudCxcbiAgICAgIHJlZ2lvbjogdGhpcy5yZWdpb24sXG4gICAgICBwYXJ0aXRpb246IHRoaXMucGFydGl0aW9uLFxuICAgICAgdXJsU3VmZml4OiB0aGlzLnVybFN1ZmZpeCxcbiAgICAgIHNkazogdGhpcy5zZGssXG4gICAgICBuZXN0ZWRTdGFja05hbWVzOiB0aGlzLm5lc3RlZFN0YWNrTmFtZXMsXG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZXN0YWJsaXNoUmVzb3VyY2VQaHlzaWNhbE5hbWUobG9naWNhbElkOiBzdHJpbmcsIHBoeXNpY2FsTmFtZUluQ2ZuVGVtcGxhdGU6IGFueSk6IFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPiB7XG4gICAgaWYgKHBoeXNpY2FsTmFtZUluQ2ZuVGVtcGxhdGUgIT0gbnVsbCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZXZhbHVhdGVDZm5FeHByZXNzaW9uKHBoeXNpY2FsTmFtZUluQ2ZuVGVtcGxhdGUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBJZiB3ZSBjYW4ndCBldmFsdWF0ZSB0aGUgcmVzb3VyY2UncyBuYW1lIENsb3VkRm9ybWF0aW9uIGV4cHJlc3Npb24sXG4gICAgICAgIC8vIGp1c3QgbG9vayBpdCB1cCBpbiB0aGUgY3VycmVudGx5IGRlcGxveWVkIFN0YWNrXG4gICAgICAgIGlmICghKGUgaW5zdGFuY2VvZiBDZm5FdmFsdWF0aW9uRXhjZXB0aW9uKSkge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluZFBoeXNpY2FsTmFtZUZvcihsb2dpY2FsSWQpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGZpbmRQaHlzaWNhbE5hbWVGb3IobG9naWNhbElkOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xuICAgIGNvbnN0IHN0YWNrUmVzb3VyY2VzID0gYXdhaXQgdGhpcy5zdGFja1Jlc291cmNlcy5saXN0U3RhY2tSZXNvdXJjZXMoKTtcbiAgICByZXR1cm4gc3RhY2tSZXNvdXJjZXMuZmluZChzciA9PiBzci5Mb2dpY2FsUmVzb3VyY2VJZCA9PT0gbG9naWNhbElkKT8uUGh5c2ljYWxSZXNvdXJjZUlkO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGZpbmRMb2dpY2FsSWRGb3JQaHlzaWNhbE5hbWUocGh5c2ljYWxOYW1lOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xuICAgIGNvbnN0IHN0YWNrUmVzb3VyY2VzID0gYXdhaXQgdGhpcy5zdGFja1Jlc291cmNlcy5saXN0U3RhY2tSZXNvdXJjZXMoKTtcbiAgICByZXR1cm4gc3RhY2tSZXNvdXJjZXMuZmluZChzciA9PiBzci5QaHlzaWNhbFJlc291cmNlSWQgPT09IHBoeXNpY2FsTmFtZSk/LkxvZ2ljYWxSZXNvdXJjZUlkO1xuICB9XG5cbiAgcHVibGljIGZpbmRSZWZlcmVuY2VzVG8obG9naWNhbElkOiBzdHJpbmcpOiBBcnJheTxSZXNvdXJjZURlZmluaXRpb24+IHtcbiAgICBjb25zdCByZXQgPSBuZXcgQXJyYXk8UmVzb3VyY2VEZWZpbml0aW9uPigpO1xuICAgIGZvciAoY29uc3QgW3Jlc291cmNlTG9naWNhbElkLCByZXNvdXJjZURlZl0gb2YgT2JqZWN0LmVudHJpZXModGhpcy50ZW1wbGF0ZT8uUmVzb3VyY2VzID8/IHt9KSkge1xuICAgICAgaWYgKGxvZ2ljYWxJZCAhPT0gcmVzb3VyY2VMb2dpY2FsSWQgJiYgdGhpcy5yZWZlcmVuY2VzKGxvZ2ljYWxJZCwgcmVzb3VyY2VEZWYpKSB7XG4gICAgICAgIHJldC5wdXNoKHtcbiAgICAgICAgICAuLi4ocmVzb3VyY2VEZWYgYXMgYW55KSxcbiAgICAgICAgICBMb2dpY2FsSWQ6IHJlc291cmNlTG9naWNhbElkLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBldmFsdWF0ZUNmbkV4cHJlc3Npb24oY2ZuRXhwcmVzc2lvbjogYW55KTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZXMgQ2xvdWRGb3JtYXRpb24gaW50cmluc2ljIGZ1bmN0aW9uc1xuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHN1cHBvcnRlZCBpbnRyaW5zaWMgZnVuY3Rpb25zIGFyZSBkb2N1bWVudGVkIGluIFJFQURNRS5tZCAtLSBwbGVhc2UgdXBkYXRlXG4gICAgICogbGlzdCBvZiBzdXBwb3J0ZWQgZnVuY3Rpb25zIHdoZW4gYWRkaW5nIG5ldyBldmFsdWF0aW9uc1xuICAgICAqXG4gICAgICogU2VlOiBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vQVdTQ2xvdWRGb3JtYXRpb24vbGF0ZXN0L1VzZXJHdWlkZS9pbnRyaW5zaWMtZnVuY3Rpb24tcmVmZXJlbmNlLmh0bWxcbiAgICAgKi9cbiAgICBjbGFzcyBDZm5JbnRyaW5zaWNzIHtcbiAgICAgIHB1YmxpYyBldmFsdWF0ZUludHJpbnNpYyhpbnRyaW5zaWM6IEludHJpbnNpYyk6IGFueSB7XG4gICAgICAgIGNvbnN0IGludHJpbnNpY0Z1bmMgPSAodGhpcyBhcyBhbnkpW2ludHJpbnNpYy5uYW1lXTtcbiAgICAgICAgaWYgKCFpbnRyaW5zaWNGdW5jKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IENmbkV2YWx1YXRpb25FeGNlcHRpb24oYENsb3VkRm9ybWF0aW9uIGZ1bmN0aW9uICR7aW50cmluc2ljLm5hbWV9IGlzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGFyZ3NBc0FycmF5ID0gQXJyYXkuaXNBcnJheShpbnRyaW5zaWMuYXJncykgPyBpbnRyaW5zaWMuYXJncyA6IFtpbnRyaW5zaWMuYXJnc107XG5cbiAgICAgICAgcmV0dXJuIGludHJpbnNpY0Z1bmMuYXBwbHkodGhpcywgYXJnc0FzQXJyYXkpO1xuICAgICAgfVxuXG4gICAgICBhc3luYyAnRm46OkpvaW4nKHNlcGFyYXRvcjogc3RyaW5nLCBhcmdzOiBhbnlbXSk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIGNvbnN0IGV2YWx1YXRlZEFyZ3MgPSBhd2FpdCBzZWxmLmV2YWx1YXRlQ2ZuRXhwcmVzc2lvbihhcmdzKTtcbiAgICAgICAgcmV0dXJuIGV2YWx1YXRlZEFyZ3Muam9pbihzZXBhcmF0b3IpO1xuICAgICAgfVxuXG4gICAgICBhc3luYyAnRm46OlNwbGl0JyhzZXBhcmF0b3I6IHN0cmluZywgYXJnczogYW55KTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgY29uc3QgZXZhbHVhdGVkQXJncyA9IGF3YWl0IHNlbGYuZXZhbHVhdGVDZm5FeHByZXNzaW9uKGFyZ3MpO1xuICAgICAgICByZXR1cm4gZXZhbHVhdGVkQXJncy5zcGxpdChzZXBhcmF0b3IpO1xuICAgICAgfVxuXG4gICAgICBhc3luYyAnRm46OlNlbGVjdCcoaW5kZXg6IG51bWJlciwgYXJnczogYW55W10pOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICBjb25zdCBldmFsdWF0ZWRBcmdzID0gYXdhaXQgc2VsZi5ldmFsdWF0ZUNmbkV4cHJlc3Npb24oYXJncyk7XG4gICAgICAgIHJldHVybiBldmFsdWF0ZWRBcmdzW2luZGV4XTtcbiAgICAgIH1cblxuICAgICAgYXN5bmMgJ1JlZicobG9naWNhbElkOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICBjb25zdCByZWZUYXJnZXQgPSBhd2FpdCBzZWxmLmZpbmRSZWZUYXJnZXQobG9naWNhbElkKTtcbiAgICAgICAgaWYgKHJlZlRhcmdldCkge1xuICAgICAgICAgIHJldHVybiByZWZUYXJnZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IENmbkV2YWx1YXRpb25FeGNlcHRpb24oYFBhcmFtZXRlciBvciByZXNvdXJjZSAnJHtsb2dpY2FsSWR9JyBjb3VsZCBub3QgYmUgZm91bmQgZm9yIGV2YWx1YXRpb25gKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBhc3luYyAnRm46OkdldEF0dCcobG9naWNhbElkOiBzdHJpbmcsIGF0dHJpYnV0ZU5hbWU6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIC8vIFRvRG8gaGFuZGxlIHRoZSAnbG9naWNhbElkLmF0dHJpYnV0ZU5hbWUnIGZvcm0gb2YgRm46OkdldEF0dFxuICAgICAgICBjb25zdCBhdHRyVmFsdWUgPSBhd2FpdCBzZWxmLmZpbmRHZXRBdHRUYXJnZXQobG9naWNhbElkLCBhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgaWYgKGF0dHJWYWx1ZSkge1xuICAgICAgICAgIHJldHVybiBhdHRyVmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IENmbkV2YWx1YXRpb25FeGNlcHRpb24oYEF0dHJpYnV0ZSAnJHthdHRyaWJ1dGVOYW1lfScgb2YgcmVzb3VyY2UgJyR7bG9naWNhbElkfScgY291bGQgbm90IGJlIGZvdW5kIGZvciBldmFsdWF0aW9uYCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYXN5bmMgJ0ZuOjpTdWInKHRlbXBsYXRlOiBzdHJpbmcsIGV4cGxpY2l0UGxhY2Vob2xkZXJzPzogeyBbdmFyaWFibGU6IHN0cmluZ106IHN0cmluZyB9KTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgY29uc3QgcGxhY2Vob2xkZXJzID0gZXhwbGljaXRQbGFjZWhvbGRlcnNcbiAgICAgICAgICA/IGF3YWl0IHNlbGYuZXZhbHVhdGVDZm5FeHByZXNzaW9uKGV4cGxpY2l0UGxhY2Vob2xkZXJzKVxuICAgICAgICAgIDoge307XG5cbiAgICAgICAgcmV0dXJuIGFzeW5jR2xvYmFsUmVwbGFjZSh0ZW1wbGF0ZSwgL1xcJHsoW159XSopfS9nLCBrZXkgPT4ge1xuICAgICAgICAgIGlmIChrZXkgaW4gcGxhY2Vob2xkZXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXJzW2tleV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHNwbGl0S2V5ID0ga2V5LnNwbGl0KCcuJyk7XG4gICAgICAgICAgICByZXR1cm4gc3BsaXRLZXkubGVuZ3RoID09PSAxXG4gICAgICAgICAgICAgID8gdGhpcy5SZWYoa2V5KVxuICAgICAgICAgICAgICA6IHRoaXNbJ0ZuOjpHZXRBdHQnXShzcGxpdEtleVswXSwgc3BsaXRLZXkuc2xpY2UoMSkuam9pbignLicpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBhc3luYyAnRm46OkltcG9ydFZhbHVlJyhuYW1lOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICBjb25zdCBleHBvcnRlZCA9IGF3YWl0IHNlbGYubG9va3VwRXhwb3J0Lmxvb2t1cEV4cG9ydChuYW1lKTtcbiAgICAgICAgaWYgKCFleHBvcnRlZCkge1xuICAgICAgICAgIHRocm93IG5ldyBDZm5FdmFsdWF0aW9uRXhjZXB0aW9uKGBFeHBvcnQgJyR7bmFtZX0nIGNvdWxkIG5vdCBiZSBmb3VuZCBmb3IgZXZhbHVhdGlvbmApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZXhwb3J0ZWQuVmFsdWUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgQ2ZuRXZhbHVhdGlvbkV4Y2VwdGlvbihgRXhwb3J0ICcke25hbWV9JyBleGlzdHMgd2l0aG91dCBhIHZhbHVlYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4cG9ydGVkLlZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjZm5FeHByZXNzaW9uID09IG51bGwpIHtcbiAgICAgIHJldHVybiBjZm5FeHByZXNzaW9uO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KGNmbkV4cHJlc3Npb24pKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoY2ZuRXhwcmVzc2lvbi5tYXAoZXhwciA9PiB0aGlzLmV2YWx1YXRlQ2ZuRXhwcmVzc2lvbihleHByKSkpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY2ZuRXhwcmVzc2lvbiA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGNvbnN0IGludHJpbnNpYyA9IHRoaXMucGFyc2VJbnRyaW5zaWMoY2ZuRXhwcmVzc2lvbik7XG4gICAgICBpZiAoaW50cmluc2ljKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2ZuSW50cmluc2ljcygpLmV2YWx1YXRlSW50cmluc2ljKGludHJpbnNpYyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCByZXQ6IHsgW2tleTogc3RyaW5nXTogYW55IH0gPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIE9iamVjdC5lbnRyaWVzKGNmbkV4cHJlc3Npb24pKSB7XG4gICAgICAgICAgcmV0W2tleV0gPSBhd2FpdCB0aGlzLmV2YWx1YXRlQ2ZuRXhwcmVzc2lvbih2YWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNmbkV4cHJlc3Npb247XG4gIH1cblxuICBwcml2YXRlIHJlZmVyZW5jZXMobG9naWNhbElkOiBzdHJpbmcsIHRlbXBsYXRlRWxlbWVudDogYW55KTogYm9vbGVhbiB7XG4gICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZUVsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gbG9naWNhbElkID09PSB0ZW1wbGF0ZUVsZW1lbnQ7XG4gICAgfVxuXG4gICAgaWYgKHRlbXBsYXRlRWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGVtcGxhdGVFbGVtZW50KSkge1xuICAgICAgcmV0dXJuIHRlbXBsYXRlRWxlbWVudC5zb21lKGVsID0+IHRoaXMucmVmZXJlbmNlcyhsb2dpY2FsSWQsIGVsKSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZUVsZW1lbnQgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0ZW1wbGF0ZUVsZW1lbnQpLnNvbWUoZWwgPT4gdGhpcy5yZWZlcmVuY2VzKGxvZ2ljYWxJZCwgZWwpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwcml2YXRlIHBhcnNlSW50cmluc2ljKHg6IGFueSk6IEludHJpbnNpYyB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHgpO1xuICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMSAmJiAoa2V5c1swXS5zdGFydHNXaXRoKCdGbjo6JykgfHwga2V5c1swXSA9PT0gJ1JlZicpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBrZXlzWzBdLFxuICAgICAgICBhcmdzOiB4W2tleXNbMF1dLFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZmluZFJlZlRhcmdldChsb2dpY2FsSWQ6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPiB7XG4gICAgLy8gZmlyc3QsIGNoZWNrIHRvIHNlZSBpZiB0aGUgUmVmIGlzIGEgUGFyYW1ldGVyIHdobydzIHZhbHVlIHdlIGhhdmVcbiAgICBpZiAobG9naWNhbElkID09PSAnQVdTOjpVUkxTdWZmaXgnKSB7XG4gICAgICBpZiAoIXRoaXMuY2FjaGVkVXJsU3VmZml4KSB7XG4gICAgICAgIHRoaXMuY2FjaGVkVXJsU3VmZml4ID0gdGhpcy51cmxTdWZmaXgodGhpcy5yZWdpb24pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jYWNoZWRVcmxTdWZmaXg7XG4gICAgfVxuXG4gICAgLy8gVHJ5IGZpbmRpbmcgdGhlIHJlZiBpbiB0aGUgcGFzc2VkIGluIHBhcmFtZXRlcnNcbiAgICBjb25zdCBwYXJhbWV0ZXJUYXJnZXQgPSB0aGlzLmNvbnRleHRbbG9naWNhbElkXTtcbiAgICBpZiAocGFyYW1ldGVyVGFyZ2V0KSB7XG4gICAgICByZXR1cm4gcGFyYW1ldGVyVGFyZ2V0O1xuICAgIH1cblxuICAgIC8vIElmIG5vdCBpbiB0aGUgcGFzc2VkIGluIHBhcmFtZXRlcnMsIHNlZSBpZiB0aGVyZSBpcyBhIGRlZmF1bHQgdmFsdWUgaW4gdGhlIHRlbXBsYXRlIHBhcmFtZXRlciB0aGF0IHdhcyBub3QgcGFzc2VkIGluXG4gICAgY29uc3QgZGVmYXVsdFBhcmFtZXRlclZhbHVlID0gdGhpcy50ZW1wbGF0ZS5QYXJhbWV0ZXJzPy5bbG9naWNhbElkXT8uRGVmYXVsdDtcbiAgICBpZiAoZGVmYXVsdFBhcmFtZXRlclZhbHVlKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdFBhcmFtZXRlclZhbHVlO1xuICAgIH1cblxuICAgIC8vIGlmIGl0J3Mgbm90IGEgUGFyYW1ldGVyLCB3ZSBuZWVkIHRvIHNlYXJjaCBpbiB0aGUgY3VycmVudCBTdGFjayByZXNvdXJjZXNcbiAgICByZXR1cm4gdGhpcy5maW5kR2V0QXR0VGFyZ2V0KGxvZ2ljYWxJZCk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGZpbmRHZXRBdHRUYXJnZXQobG9naWNhbElkOiBzdHJpbmcsIGF0dHJpYnV0ZT86IHN0cmluZyk6IFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPiB7XG5cbiAgICAvLyBIYW5kbGUgY2FzZSB3aGVyZSB0aGUgYXR0cmlidXRlIGlzIHJlZmVyZW5jaW5nIGEgc3RhY2sgb3V0cHV0ICh1c2VkIGluIG5lc3RlZCBzdGFja3MgdG8gc2hhcmUgcGFyYW1ldGVycylcbiAgICAvLyBTZWUgaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL0FXU0Nsb3VkRm9ybWF0aW9uL2xhdGVzdC9Vc2VyR3VpZGUvcXVpY2tyZWYtY2xvdWRmb3JtYXRpb24uaHRtbCN3MmFiMWMxN2MyM2MxOWI1XG4gICAgaWYgKGxvZ2ljYWxJZCA9PT0gJ091dHB1dHMnICYmIGF0dHJpYnV0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZXZhbHVhdGVDZm5FeHByZXNzaW9uKHRoaXMudGVtcGxhdGUuT3V0cHV0c1thdHRyaWJ1dGVdPy5WYWx1ZSk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhY2tSZXNvdXJjZXMgPSBhd2FpdCB0aGlzLnN0YWNrUmVzb3VyY2VzLmxpc3RTdGFja1Jlc291cmNlcygpO1xuICAgIGNvbnN0IGZvdW5kUmVzb3VyY2UgPSBzdGFja1Jlc291cmNlcy5maW5kKHNyID0+IHNyLkxvZ2ljYWxSZXNvdXJjZUlkID09PSBsb2dpY2FsSWQpO1xuICAgIGlmICghZm91bmRSZXNvdXJjZSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoZm91bmRSZXNvdXJjZS5SZXNvdXJjZVR5cGUgPT0gJ0FXUzo6Q2xvdWRGb3JtYXRpb246OlN0YWNrJyAmJiBhdHRyaWJ1dGU/LnN0YXJ0c1dpdGgoJ091dHB1dHMuJykpIHtcbiAgICAgIC8vIG5lZWQgdG8gcmVzb2x2ZSBhdHRyaWJ1dGVzIGZyb20gYW5vdGhlciBzdGFjaydzIE91dHB1dCBzZWN0aW9uXG4gICAgICBjb25zdCBkZXBlbmRhbnRTdGFja05hbWUgPSB0aGlzLmZpbmROZXN0ZWRTdGFjayhsb2dpY2FsSWQsIHRoaXMubmVzdGVkU3RhY2tOYW1lcyk7XG4gICAgICBpZiAoIWRlcGVuZGFudFN0YWNrTmFtZSkge1xuICAgICAgICAvL3RoaXMgaXMgYSBuZXdseSBjcmVhdGVkIG5lc3RlZCBzdGFjayBhbmQgY2Fubm90IGJlIGhvdHN3YXBwZWRcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRlcGVuZGFudFN0YWNrVGVtcGxhdGUgPSB0aGlzLnRlbXBsYXRlLlJlc291cmNlc1tsb2dpY2FsSWRdO1xuICAgICAgY29uc3QgZXZhbHVhdGVDZm5UZW1wbGF0ZSA9IGF3YWl0IHRoaXMuY3JlYXRlTmVzdGVkRXZhbHVhdGVDbG91ZEZvcm1hdGlvblRlbXBsYXRlKFxuICAgICAgICBkZXBlbmRhbnRTdGFja05hbWUsXG4gICAgICAgIGRlcGVuZGFudFN0YWNrVGVtcGxhdGU/LlByb3BlcnRpZXM/Lk5lc3RlZFRlbXBsYXRlLFxuICAgICAgICBkZXBlbmRhbnRTdGFja1RlbXBsYXRlLm5ld1ZhbHVlPy5Qcm9wZXJ0aWVzPy5QYXJhbWV0ZXJzKTtcblxuICAgICAgLy8gU3BsaXQgT3V0cHV0cy48cmVmTmFtZT4gaW50byAnT3V0cHV0cycgYW5kICc8cmVmTmFtZT4nIGFuZCByZWN1cnNpdmVseSBjYWxsIGV2YWx1YXRlXG4gICAgICByZXR1cm4gZXZhbHVhdGVDZm5UZW1wbGF0ZS5ldmFsdWF0ZUNmbkV4cHJlc3Npb24oeyAnRm46OkdldEF0dCc6IGF0dHJpYnV0ZS5zcGxpdCgvXFwuKC4qKS9zKSB9KTtcbiAgICB9XG4gICAgLy8gbm93LCB3ZSBuZWVkIHRvIGZvcm1hdCB0aGUgYXBwcm9wcmlhdGUgaWRlbnRpZmllciBkZXBlbmRpbmcgb24gdGhlIHJlc291cmNlIHR5cGUsXG4gICAgLy8gYW5kIHRoZSByZXF1ZXN0ZWQgYXR0cmlidXRlIG5hbWVcbiAgICByZXR1cm4gdGhpcy5mb3JtYXRSZXNvdXJjZUF0dHJpYnV0ZShmb3VuZFJlc291cmNlLCBhdHRyaWJ1dGUpO1xuICB9XG5cbiAgcHJpdmF0ZSBmaW5kTmVzdGVkU3RhY2sobG9naWNhbElkOiBzdHJpbmcsIG5lc3RlZFN0YWNrTmFtZXM6IHtcbiAgICBbbmVzdGVkU3RhY2tMb2dpY2FsSWQ6IHN0cmluZ106IE5lc3RlZFN0YWNrTmFtZXM7XG4gIH0pOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIGZvciAoY29uc3QgW25lc3RlZFN0YWNrTG9naWNhbElkLCB7IG5lc3RlZENoaWxkU3RhY2tOYW1lcywgbmVzdGVkU3RhY2tQaHlzaWNhbE5hbWUgfV0gb2YgT2JqZWN0LmVudHJpZXMobmVzdGVkU3RhY2tOYW1lcykpIHtcbiAgICAgIGlmIChuZXN0ZWRTdGFja0xvZ2ljYWxJZCA9PT0gbG9naWNhbElkKSB7XG4gICAgICAgIHJldHVybiBuZXN0ZWRTdGFja1BoeXNpY2FsTmFtZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoZWNrSW5OZXN0ZWRDaGlsZFN0YWNrcyA9IHRoaXMuZmluZE5lc3RlZFN0YWNrKGxvZ2ljYWxJZCwgbmVzdGVkQ2hpbGRTdGFja05hbWVzKTtcbiAgICAgIGlmIChjaGVja0luTmVzdGVkQ2hpbGRTdGFja3MpIHJldHVybiBjaGVja0luTmVzdGVkQ2hpbGRTdGFja3M7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBwcml2YXRlIGZvcm1hdFJlc291cmNlQXR0cmlidXRlKHJlc291cmNlOiBBV1MuQ2xvdWRGb3JtYXRpb24uU3RhY2tSZXNvdXJjZVN1bW1hcnksIGF0dHJpYnV0ZTogc3RyaW5nIHwgdW5kZWZpbmVkKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBwaHlzaWNhbElkID0gcmVzb3VyY2UuUGh5c2ljYWxSZXNvdXJjZUlkO1xuXG4gICAgLy8gbm8gYXR0cmlidXRlIG1lYW5zIFJlZiBleHByZXNzaW9uLCBmb3Igd2hpY2ggd2UgdXNlIHRoZSBwaHlzaWNhbCBJRCBkaXJlY3RseVxuICAgIGlmICghYXR0cmlidXRlKSB7XG4gICAgICByZXR1cm4gcGh5c2ljYWxJZDtcbiAgICB9XG5cbiAgICBjb25zdCByZXNvdXJjZVR5cGVGb3JtYXRzID0gUkVTT1VSQ0VfVFlQRV9BVFRSSUJVVEVTX0ZPUk1BVFNbcmVzb3VyY2UuUmVzb3VyY2VUeXBlXTtcbiAgICBpZiAoIXJlc291cmNlVHlwZUZvcm1hdHMpIHtcbiAgICAgIHRocm93IG5ldyBDZm5FdmFsdWF0aW9uRXhjZXB0aW9uKGBXZSBkb24ndCBzdXBwb3J0IGF0dHJpYnV0ZXMgb2YgdGhlICcke3Jlc291cmNlLlJlc291cmNlVHlwZX0nIHJlc291cmNlLiBUaGlzIGlzIGEgQ0RLIGxpbWl0YXRpb24uIGAgK1xuICAgICAgICAnUGxlYXNlIHJlcG9ydCBpdCBhdCBodHRwczovL2dpdGh1Yi5jb20vYXdzL2F3cy1jZGsvaXNzdWVzL25ldy9jaG9vc2UnKTtcbiAgICB9XG4gICAgY29uc3QgYXR0cmlidXRlRm10RnVuYyA9IHJlc291cmNlVHlwZUZvcm1hdHNbYXR0cmlidXRlXTtcbiAgICBpZiAoIWF0dHJpYnV0ZUZtdEZ1bmMpIHtcbiAgICAgIHRocm93IG5ldyBDZm5FdmFsdWF0aW9uRXhjZXB0aW9uKGBXZSBkb24ndCBzdXBwb3J0IHRoZSAnJHthdHRyaWJ1dGV9JyBhdHRyaWJ1dGUgb2YgdGhlICcke3Jlc291cmNlLlJlc291cmNlVHlwZX0nIHJlc291cmNlLiBUaGlzIGlzIGEgQ0RLIGxpbWl0YXRpb24uIGAgK1xuICAgICAgICAnUGxlYXNlIHJlcG9ydCBpdCBhdCBodHRwczovL2dpdGh1Yi5jb20vYXdzL2F3cy1jZGsvaXNzdWVzL25ldy9jaG9vc2UnKTtcbiAgICB9XG4gICAgY29uc3Qgc2VydmljZSA9IHRoaXMuZ2V0U2VydmljZU9mUmVzb3VyY2UocmVzb3VyY2UpO1xuICAgIGNvbnN0IHJlc291cmNlVHlwZUFyblBhcnQgPSB0aGlzLmdldFJlc291cmNlVHlwZUFyblBhcnRPZlJlc291cmNlKHJlc291cmNlKTtcbiAgICByZXR1cm4gYXR0cmlidXRlRm10RnVuYyh7XG4gICAgICBwYXJ0aXRpb246IHRoaXMucGFydGl0aW9uLFxuICAgICAgc2VydmljZSxcbiAgICAgIHJlZ2lvbjogdGhpcy5yZWdpb24sXG4gICAgICBhY2NvdW50OiB0aGlzLmFjY291bnQsXG4gICAgICByZXNvdXJjZVR5cGU6IHJlc291cmNlVHlwZUFyblBhcnQsXG4gICAgICByZXNvdXJjZU5hbWU6IHBoeXNpY2FsSWQhLFxuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRTZXJ2aWNlT2ZSZXNvdXJjZShyZXNvdXJjZTogQVdTLkNsb3VkRm9ybWF0aW9uLlN0YWNrUmVzb3VyY2VTdW1tYXJ5KTogc3RyaW5nIHtcbiAgICByZXR1cm4gcmVzb3VyY2UuUmVzb3VyY2VUeXBlLnNwbGl0KCc6OicpWzFdLnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICBwcml2YXRlIGdldFJlc291cmNlVHlwZUFyblBhcnRPZlJlc291cmNlKHJlc291cmNlOiBBV1MuQ2xvdWRGb3JtYXRpb24uU3RhY2tSZXNvdXJjZVN1bW1hcnkpOiBzdHJpbmcge1xuICAgIGNvbnN0IHJlc291cmNlVHlwZSA9IHJlc291cmNlLlJlc291cmNlVHlwZTtcbiAgICBjb25zdCBzcGVjaWFsQ2FzZVJlc291cmNlVHlwZSA9IFJFU09VUkNFX1RZUEVfU1BFQ0lBTF9OQU1FU1tyZXNvdXJjZVR5cGVdPy5yZXNvdXJjZVR5cGU7XG4gICAgcmV0dXJuIHNwZWNpYWxDYXNlUmVzb3VyY2VUeXBlXG4gICAgICA/IHNwZWNpYWxDYXNlUmVzb3VyY2VUeXBlXG4gICAgICAvLyB0aGlzIGlzIHRoZSBkZWZhdWx0IGNhc2VcbiAgICAgIDogcmVzb3VyY2VUeXBlLnNwbGl0KCc6OicpWzJdLnRvTG93ZXJDYXNlKCk7XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgVGVtcGxhdGUgPSB7IFtzZWN0aW9uOiBzdHJpbmddOiB7IFtoZWFkaW5nczogc3RyaW5nXTogYW55IH0gfTtcblxuaW50ZXJmYWNlIEFyblBhcnRzIHtcbiAgcmVhZG9ubHkgcGFydGl0aW9uOiBzdHJpbmc7XG4gIHJlYWRvbmx5IHNlcnZpY2U6IHN0cmluZztcbiAgcmVhZG9ubHkgcmVnaW9uOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGFjY291bnQ6IHN0cmluZztcbiAgcmVhZG9ubHkgcmVzb3VyY2VUeXBlOiBzdHJpbmc7XG4gIHJlYWRvbmx5IHJlc291cmNlTmFtZTogc3RyaW5nO1xufVxuXG4vKipcbiAqIFVzdWFsbHksIHdlIGRlZHVjZSB0aGUgbmFtZXMgb2YgdGhlIHNlcnZpY2UgYW5kIHRoZSByZXNvdXJjZSB0eXBlIHVzZWQgdG8gZm9ybWF0IHRoZSBBUk4gZnJvbSB0aGUgQ2xvdWRGb3JtYXRpb24gcmVzb3VyY2UgdHlwZS5cbiAqIEZvciBhIENGTiB0eXBlIGxpa2UgQVdTOjpTZXJ2aWNlOjpSZXNvdXJjZVR5cGUsIHRoZSBzZWNvbmQgc2VnbWVudCBiZWNvbWVzIHRoZSBzZXJ2aWNlIG5hbWUsIGFuZCB0aGUgdGhpcmQgdGhlIHJlc291cmNlIHR5cGVcbiAqIChhZnRlciBjb252ZXJ0aW5nIGJvdGggb2YgdGhlbSB0byBsb3dlcmNhc2UpLlxuICogSG93ZXZlciwgc29tZSByZXNvdXJjZSB0eXBlcyBicmVhayB0aGlzIHNpbXBsZSBjb252ZW50aW9uLCBhbmQgd2UgbmVlZCB0byBzcGVjaWFsLWNhc2UgdGhlbS5cbiAqIFRoaXMgbWFwIGlzIGZvciBzdG9yaW5nIHRob3NlIGNhc2VzLlxuICovXG5jb25zdCBSRVNPVVJDRV9UWVBFX1NQRUNJQUxfTkFNRVM6IHsgW3R5cGU6IHN0cmluZ106IHsgcmVzb3VyY2VUeXBlOiBzdHJpbmcgfSB9ID0ge1xuICAnQVdTOjpFdmVudHM6OkV2ZW50QnVzJzoge1xuICAgIHJlc291cmNlVHlwZTogJ2V2ZW50LWJ1cycsXG4gIH0sXG59O1xuXG5jb25zdCBSRVNPVVJDRV9UWVBFX0FUVFJJQlVURVNfRk9STUFUUzogeyBbdHlwZTogc3RyaW5nXTogeyBbYXR0cmlidXRlOiBzdHJpbmddOiAocGFydHM6IEFyblBhcnRzKSA9PiBzdHJpbmcgfSB9ID0ge1xuICAnQVdTOjpJQU06OlJvbGUnOiB7IEFybjogaWFtQXJuRm10IH0sXG4gICdBV1M6OklBTTo6VXNlcic6IHsgQXJuOiBpYW1Bcm5GbXQgfSxcbiAgJ0FXUzo6SUFNOjpHcm91cCc6IHsgQXJuOiBpYW1Bcm5GbXQgfSxcbiAgJ0FXUzo6UzM6OkJ1Y2tldCc6IHsgQXJuOiBzM0FybkZtdCB9LFxuICAnQVdTOjpMYW1iZGE6OkZ1bmN0aW9uJzogeyBBcm46IHN0ZENvbG9uUmVzb3VyY2VBcm5GbXQgfSxcbiAgJ0FXUzo6RXZlbnRzOjpFdmVudEJ1cyc6IHtcbiAgICBBcm46IHN0ZFNsYXNoUmVzb3VyY2VBcm5GbXQsXG4gICAgLy8gdGhlIG5hbWUgYXR0cmlidXRlIG9mIHRoZSBFdmVudEJ1cyBpcyB0aGUgc2FtZSBhcyB0aGUgUmVmXG4gICAgTmFtZTogcGFydHMgPT4gcGFydHMucmVzb3VyY2VOYW1lLFxuICB9LFxuICAnQVdTOjpEeW5hbW9EQjo6VGFibGUnOiB7IEFybjogc3RkU2xhc2hSZXNvdXJjZUFybkZtdCB9LFxuICAnQVdTOjpBcHBTeW5jOjpHcmFwaFFMQXBpJzogeyBBcGlJZDogYXBwc3luY0dyYXBoUWxBcGlBcGlJZEZtdCB9LFxuICAnQVdTOjpBcHBTeW5jOjpGdW5jdGlvbkNvbmZpZ3VyYXRpb24nOiB7IEZ1bmN0aW9uSWQ6IGFwcHN5bmNHcmFwaFFsRnVuY3Rpb25JREZtdCB9LFxuICAnQVdTOjpBcHBTeW5jOjpEYXRhU291cmNlJzogeyBOYW1lOiBhcHBzeW5jR3JhcGhRbERhdGFTb3VyY2VOYW1lRm10IH0sXG59O1xuXG5mdW5jdGlvbiBpYW1Bcm5GbXQocGFydHM6IEFyblBhcnRzKTogc3RyaW5nIHtcbiAgLy8gd2Ugc2tpcCByZWdpb24gZm9yIElBTSByZXNvdXJjZXNcbiAgcmV0dXJuIGBhcm46JHtwYXJ0cy5wYXJ0aXRpb259OiR7cGFydHMuc2VydmljZX06OiR7cGFydHMuYWNjb3VudH06JHtwYXJ0cy5yZXNvdXJjZVR5cGV9LyR7cGFydHMucmVzb3VyY2VOYW1lfWA7XG59XG5cbmZ1bmN0aW9uIHMzQXJuRm10KHBhcnRzOiBBcm5QYXJ0cyk6IHN0cmluZyB7XG4gIC8vIHdlIHNraXAgYWNjb3VudCwgcmVnaW9uIGFuZCByZXNvdXJjZVR5cGUgZm9yIFMzIHJlc291cmNlc1xuICByZXR1cm4gYGFybjoke3BhcnRzLnBhcnRpdGlvbn06JHtwYXJ0cy5zZXJ2aWNlfTo6OiR7cGFydHMucmVzb3VyY2VOYW1lfWA7XG59XG5cbmZ1bmN0aW9uIHN0ZENvbG9uUmVzb3VyY2VBcm5GbXQocGFydHM6IEFyblBhcnRzKTogc3RyaW5nIHtcbiAgLy8gdGhpcyBpcyBhIHN0YW5kYXJkIGZvcm1hdCBmb3IgQVJOcyBsaWtlOiBhcm46YXdzOnNlcnZpY2U6cmVnaW9uOmFjY291bnQ6cmVzb3VyY2VUeXBlOnJlc291cmNlTmFtZVxuICByZXR1cm4gYGFybjoke3BhcnRzLnBhcnRpdGlvbn06JHtwYXJ0cy5zZXJ2aWNlfToke3BhcnRzLnJlZ2lvbn06JHtwYXJ0cy5hY2NvdW50fToke3BhcnRzLnJlc291cmNlVHlwZX06JHtwYXJ0cy5yZXNvdXJjZU5hbWV9YDtcbn1cblxuZnVuY3Rpb24gc3RkU2xhc2hSZXNvdXJjZUFybkZtdChwYXJ0czogQXJuUGFydHMpOiBzdHJpbmcge1xuICAvLyB0aGlzIGlzIGEgc3RhbmRhcmQgZm9ybWF0IGZvciBBUk5zIGxpa2U6IGFybjphd3M6c2VydmljZTpyZWdpb246YWNjb3VudDpyZXNvdXJjZVR5cGUvcmVzb3VyY2VOYW1lXG4gIHJldHVybiBgYXJuOiR7cGFydHMucGFydGl0aW9ufToke3BhcnRzLnNlcnZpY2V9OiR7cGFydHMucmVnaW9ufToke3BhcnRzLmFjY291bnR9OiR7cGFydHMucmVzb3VyY2VUeXBlfS8ke3BhcnRzLnJlc291cmNlTmFtZX1gO1xufVxuXG5mdW5jdGlvbiBhcHBzeW5jR3JhcGhRbEFwaUFwaUlkRm10KHBhcnRzOiBBcm5QYXJ0cyk6IHN0cmluZyB7XG4gIC8vIGFybjphd3M6YXBwc3luYzp1cy1lYXN0LTE6MTExMTExMTExMTExOmFwaXMvPGFwaUlkPlxuICByZXR1cm4gcGFydHMucmVzb3VyY2VOYW1lLnNwbGl0KCcvJylbMV07XG59XG5cbmZ1bmN0aW9uIGFwcHN5bmNHcmFwaFFsRnVuY3Rpb25JREZtdChwYXJ0czogQXJuUGFydHMpOiBzdHJpbmcge1xuICAvLyBhcm46YXdzOmFwcHN5bmM6dXMtZWFzdC0xOjExMTExMTExMTExMTphcGlzLzxhcGlJZD4vZnVuY3Rpb25zLzxmdW5jdGlvbklkPlxuICByZXR1cm4gcGFydHMucmVzb3VyY2VOYW1lLnNwbGl0KCcvJylbM107XG59XG5cbmZ1bmN0aW9uIGFwcHN5bmNHcmFwaFFsRGF0YVNvdXJjZU5hbWVGbXQocGFydHM6IEFyblBhcnRzKTogc3RyaW5nIHtcbiAgLy8gYXJuOmF3czphcHBzeW5jOnVzLWVhc3QtMToxMTExMTExMTExMTE6YXBpcy88YXBpSWQ+L2RhdGFzb3VyY2VzLzxuYW1lPlxuICByZXR1cm4gcGFydHMucmVzb3VyY2VOYW1lLnNwbGl0KCcvJylbM107XG59XG5cbmludGVyZmFjZSBJbnRyaW5zaWMge1xuICByZWFkb25seSBuYW1lOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGFyZ3M6IGFueTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gYXN5bmNHbG9iYWxSZXBsYWNlKHN0cjogc3RyaW5nLCByZWdleDogUmVnRXhwLCBjYjogKHg6IHN0cmluZykgPT4gUHJvbWlzZTxzdHJpbmc+KTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgaWYgKCFyZWdleC5nbG9iYWwpIHsgdGhyb3cgbmV3IEVycm9yKCdSZWdleCBtdXN0IGJlIGNyZWF0ZWQgd2l0aCAvZyBmbGFnJyk7IH1cblxuICBjb25zdCByZXQgPSBuZXcgQXJyYXk8c3RyaW5nPigpO1xuICBsZXQgc3RhcnQgPSAwO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IG1hdGNoID0gcmVnZXguZXhlYyhzdHIpO1xuICAgIGlmICghbWF0Y2gpIHsgYnJlYWs7IH1cblxuICAgIHJldC5wdXNoKHN0ci5zdWJzdHJpbmcoc3RhcnQsIG1hdGNoLmluZGV4KSk7XG4gICAgcmV0LnB1c2goYXdhaXQgY2IobWF0Y2hbMV0pKTtcblxuICAgIHN0YXJ0ID0gcmVnZXgubGFzdEluZGV4O1xuICB9XG4gIHJldC5wdXNoKHN0ci5zbGljZShzdGFydCkpO1xuXG4gIHJldHVybiByZXQuam9pbignJyk7XG59XG4iXX0=