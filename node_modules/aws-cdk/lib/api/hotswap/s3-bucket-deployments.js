"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.skipChangeForS3DeployCustomResourcePolicy = exports.isHotswappableS3BucketDeploymentChange = exports.REQUIRED_BY_CFN = void 0;
/**
 * This means that the value is required to exist by CloudFormation's Custom Resource API (or our S3 Bucket Deployment Lambda's API)
 * but the actual value specified is irrelevant
 */
exports.REQUIRED_BY_CFN = 'required-to-be-present-by-cfn';
async function isHotswappableS3BucketDeploymentChange(_logicalId, change, evaluateCfnTemplate) {
    // In old-style synthesis, the policy used by the lambda to copy assets Ref's the assets directly,
    // meaning that the changes made to the Policy are artifacts that can be safely ignored
    const ret = [];
    if (change.newValue.Type !== 'Custom::CDKBucketDeployment') {
        return [];
    }
    // no classification to be done here; all the properties of this custom resource thing are hotswappable
    const customResourceProperties = await evaluateCfnTemplate.evaluateCfnExpression({
        ...change.newValue.Properties,
        ServiceToken: undefined,
    });
    ret.push({
        hotswappable: true,
        resourceType: change.newValue.Type,
        propsChanged: ['*'],
        service: 'custom-s3-deployment',
        resourceNames: [`Contents of S3 Bucket '${customResourceProperties.DestinationBucketName}'`],
        apply: async (sdk) => {
            // note that this gives the ARN of the lambda, not the name. This is fine though, the invoke() sdk call will take either
            const functionName = await evaluateCfnTemplate.evaluateCfnExpression(change.newValue.Properties?.ServiceToken);
            if (!functionName) {
                return;
            }
            await sdk.lambda().invoke({
                FunctionName: functionName,
                // Lambda refuses to take a direct JSON object and requires it to be stringify()'d
                Payload: JSON.stringify({
                    RequestType: 'Update',
                    ResponseURL: exports.REQUIRED_BY_CFN,
                    PhysicalResourceId: exports.REQUIRED_BY_CFN,
                    StackId: exports.REQUIRED_BY_CFN,
                    RequestId: exports.REQUIRED_BY_CFN,
                    LogicalResourceId: exports.REQUIRED_BY_CFN,
                    ResourceProperties: stringifyObject(customResourceProperties), // JSON.stringify() doesn't turn the actual objects to strings, but the lambda expects strings
                }),
            }).promise();
        },
    });
    return ret;
}
exports.isHotswappableS3BucketDeploymentChange = isHotswappableS3BucketDeploymentChange;
async function skipChangeForS3DeployCustomResourcePolicy(iamPolicyLogicalId, change, evaluateCfnTemplate) {
    if (change.newValue.Type !== 'AWS::IAM::Policy') {
        return false;
    }
    const roles = change.newValue.Properties?.Roles;
    // If no roles are referenced, the policy is definitely not used for a S3Deployment
    if (!roles || !roles.length) {
        return false;
    }
    // Check if every role this policy is referenced by is only used for a S3Deployment
    for (const role of roles) {
        const roleArn = await evaluateCfnTemplate.evaluateCfnExpression(role);
        const roleLogicalId = await evaluateCfnTemplate.findLogicalIdForPhysicalName(roleArn);
        // We must assume this role is used for something else, because we can't check it
        if (!roleLogicalId) {
            return false;
        }
        // Find all interesting reference to the role
        const roleRefs = evaluateCfnTemplate.findReferencesTo(roleLogicalId)
            // we are not interested in the reference from the original policy - it always exists
            .filter(roleRef => !(roleRef.Type == 'AWS::IAM::Policy' && roleRef.LogicalId === iamPolicyLogicalId));
        // Check if the role is only used for S3Deployment
        // We know this is the case, if S3Deployment -> Lambda -> Role is satisfied for every reference
        // And we have at least one reference.
        const isRoleOnlyForS3Deployment = roleRefs.length >= 1 && roleRefs.every(roleRef => {
            if (roleRef.Type === 'AWS::Lambda::Function') {
                const lambdaRefs = evaluateCfnTemplate.findReferencesTo(roleRef.LogicalId);
                // Every reference must be to the custom resource and at least one reference must be present
                return lambdaRefs.length >= 1 && lambdaRefs.every(lambdaRef => lambdaRef.Type === 'Custom::CDKBucketDeployment');
            }
            return false;
        });
        // We have determined this role is used for something else, so we can't skip the change
        if (!isRoleOnlyForS3Deployment) {
            return false;
        }
    }
    // We have checked that any use of this policy is only for S3Deployment and we can safely skip it
    return true;
}
exports.skipChangeForS3DeployCustomResourcePolicy = skipChangeForS3DeployCustomResourcePolicy;
function stringifyObject(obj) {
    if (obj == null) {
        return obj;
    }
    if (Array.isArray(obj)) {
        return obj.map(stringifyObject);
    }
    if (typeof obj !== 'object') {
        return obj.toString();
    }
    const ret = {};
    for (const [k, v] of Object.entries(obj)) {
        ret[k] = stringifyObject(v);
    }
    return ret;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiczMtYnVja2V0LWRlcGxveW1lbnRzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiczMtYnVja2V0LWRlcGxveW1lbnRzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUlBOzs7R0FHRztBQUNVLFFBQUEsZUFBZSxHQUFHLCtCQUErQixDQUFDO0FBRXhELEtBQUssVUFBVSxzQ0FBc0MsQ0FDMUQsVUFBa0IsRUFBRSxNQUFtQyxFQUFFLG1CQUFtRDtJQUU1RyxrR0FBa0c7SUFDbEcsdUZBQXVGO0lBQ3ZGLE1BQU0sR0FBRyxHQUF3QixFQUFFLENBQUM7SUFFcEMsSUFBSSxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksS0FBSyw2QkFBNkIsRUFBRTtRQUMxRCxPQUFPLEVBQUUsQ0FBQztLQUNYO0lBRUQsdUdBQXVHO0lBQ3ZHLE1BQU0sd0JBQXdCLEdBQUcsTUFBTSxtQkFBbUIsQ0FBQyxxQkFBcUIsQ0FBQztRQUMvRSxHQUFHLE1BQU0sQ0FBQyxRQUFRLENBQUMsVUFBVTtRQUM3QixZQUFZLEVBQUUsU0FBUztLQUN4QixDQUFDLENBQUM7SUFFSCxHQUFHLENBQUMsSUFBSSxDQUFDO1FBQ1AsWUFBWSxFQUFFLElBQUk7UUFDbEIsWUFBWSxFQUFFLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSTtRQUNsQyxZQUFZLEVBQUUsQ0FBQyxHQUFHLENBQUM7UUFDbkIsT0FBTyxFQUFFLHNCQUFzQjtRQUMvQixhQUFhLEVBQUUsQ0FBQywwQkFBMEIsd0JBQXdCLENBQUMscUJBQXFCLEdBQUcsQ0FBQztRQUM1RixLQUFLLEVBQUUsS0FBSyxFQUFFLEdBQVMsRUFBRSxFQUFFO1lBQ3pCLHdIQUF3SDtZQUN4SCxNQUFNLFlBQVksR0FBRyxNQUFNLG1CQUFtQixDQUFDLHFCQUFxQixDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsVUFBVSxFQUFFLFlBQVksQ0FBQyxDQUFDO1lBQy9HLElBQUksQ0FBQyxZQUFZLEVBQUU7Z0JBQ2pCLE9BQU87YUFDUjtZQUVELE1B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QUMsR0FBRyxDQUFDLEVBQUU7UUFDdEIsT0FBTyxHQUFHLENBQUMsR0FBRyxDQUFDLGVBQWUsQ0FBQyxDQUFDO0tBQ2pDO0lBQ0QsSUFBSSxPQUFPLEdBQUcsS0FBSyxRQUFRLEVBQUU7UUFDM0IsT0FBTyxHQUFHLENBQUMsUUFBUSxFQUFFLENBQUM7S0FDdkI7SUFFRCxNQUFNLEdBQUcsR0FBeUIsRUFBRSxDQUFDO0lBQ3JDLEtBQUssTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxFQUFFO1FBQ3hDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxlQUFlLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDN0I7SUFDRCxPQUFPLEdBQUcsQ0FBQztBQUNiLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDaGFuZ2VIb3Rzd2FwUmVzdWx0LCBIb3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUgfSBmcm9tICcuL2NvbW1vbic7XG5pbXBvcnQgeyBJU0RLIH0gZnJvbSAnLi4vYXdzLWF1dGgnO1xuaW1wb3J0IHsgRXZhbHVhdGVDbG91ZEZvcm1hdGlvblRlbXBsYXRlIH0gZnJvbSAnLi4vZXZhbHVhdGUtY2xvdWRmb3JtYXRpb24tdGVtcGxhdGUnO1xuXG4vKipcbiAqIFRoaXMgbWVhbnMgdGhhdCB0aGUgdmFsdWUgaXMgcmVxdWlyZWQgdG8gZXhpc3QgYnkgQ2xvdWRGb3JtYXRpb24ncyBDdXN0b20gUmVzb3VyY2UgQVBJIChvciBvdXIgUzMgQnVja2V0IERlcGxveW1lbnQgTGFtYmRhJ3MgQVBJKVxuICogYnV0IHRoZSBhY3R1YWwgdmFsdWUgc3BlY2lmaWVkIGlzIGlycmVsZXZhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IFJFUVVJUkVEX0JZX0NGTiA9ICdyZXF1aXJlZC10by1iZS1wcmVzZW50LWJ5LWNmbic7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpc0hvdHN3YXBwYWJsZVMzQnVja2V0RGVwbG95bWVudENoYW5nZShcbiAgX2xvZ2ljYWxJZDogc3RyaW5nLCBjaGFuZ2U6IEhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZSwgZXZhbHVhdGVDZm5UZW1wbGF0ZTogRXZhbHVhdGVDbG91ZEZvcm1hdGlvblRlbXBsYXRlLFxuKTogUHJvbWlzZTxDaGFuZ2VIb3Rzd2FwUmVzdWx0PiB7XG4gIC8vIEluIG9sZC1zdHlsZSBzeW50aGVzaXMsIHRoZSBwb2xpY3kgdXNlZCBieSB0aGUgbGFtYmRhIHRvIGNvcHkgYXNzZXRzIFJlZidzIHRoZSBhc3NldHMgZGlyZWN0bHksXG4gIC8vIG1lYW5pbmcgdGhhdCB0aGUgY2hhbmdlcyBtYWRlIHRvIHRoZSBQb2xpY3kgYXJlIGFydGlmYWN0cyB0aGF0IGNhbiBiZSBzYWZlbHkgaWdub3JlZFxuICBjb25zdCByZXQ6IENoYW5nZUhvdHN3YXBSZXN1bHQgPSBbXTtcblxuICBpZiAoY2hhbmdlLm5ld1ZhbHVlLlR5cGUgIT09ICdDdXN0b206OkNES0J1Y2tldERlcGxveW1lbnQnKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgLy8gbm8gY2xhc3NpZmljYXRpb24gdG8gYmUgZG9uZSBoZXJlOyBhbGwgdGhlIHByb3BlcnRpZXMgb2YgdGhpcyBjdXN0b20gcmVzb3VyY2UgdGhpbmcgYXJlIGhvdHN3YXBwYWJsZVxuICBjb25zdCBjdXN0b21SZXNvdXJjZVByb3BlcnRpZXMgPSBhd2FpdCBldmFsdWF0ZUNmblRlbXBsYXRlLmV2YWx1YXRlQ2ZuRXhwcmVzc2lvbih7XG4gICAgLi4uY2hhbmdlLm5ld1ZhbHVlLlByb3BlcnRpZXMsXG4gICAgU2VydmljZVRva2VuOiB1bmRlZmluZWQsXG4gIH0pO1xuXG4gIHJldC5wdXNoKHtcbiAgICBob3Rzd2FwcGFibGU6IHRydWUsXG4gICAgcmVzb3VyY2VUeXBlOiBjaGFuZ2UubmV3VmFsdWUuVHlwZSxcbiAgICBwcm9wc0NoYW5nZWQ6IFsnKiddLFxuICAgIHNlcnZpY2U6ICdjdXN0b20tczMtZGVwbG95bWVudCcsXG4gICAgcmVzb3VyY2VOYW1lczogW2BDb250ZW50cyBvZiBTMyBCdWNrZXQgJyR7Y3VzdG9tUmVzb3VyY2VQcm9wZXJ0aWVzLkRlc3RpbmF0aW9uQnVja2V0TmFtZX0nYF0sXG4gICAgYXBwbHk6IGFzeW5jIChzZGs6IElTREspID0+IHtcbiAgICAgIC8vIG5vdGUgdGhhdCB0aGlzIGdpdmVzIHRoZSBBUk4gb2YgdGhlIGxhbWJkYSwgbm90IHRoZSBuYW1lLiBUaGlzIGlzIGZpbmUgdGhvdWdoLCB0aGUgaW52b2tlKCkgc2RrIGNhbGwgd2lsbCB0YWtlIGVpdGhlclxuICAgICAgY29uc3QgZnVuY3Rpb25OYW1lID0gYXdhaXQgZXZhbHVhdGVDZm5UZW1wbGF0ZS5ldmFsdWF0ZUNmbkV4cHJlc3Npb24oY2hhbmdlLm5ld1ZhbHVlLlByb3BlcnRpZXM/LlNlcnZpY2VUb2tlbik7XG4gICAgICBpZiAoIWZ1bmN0aW9uTmFtZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGF3YWl0IHNkay5sYW1iZGEoKS5pbnZva2Uoe1xuICAgICAgICBGdW5jdGlvbk5hbWU6IGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgLy8gTGFtYmRhIHJlZnVzZXMgdG8gdGFrZSBhIGRpcmVjdCBKU09OIG9iamVjdCBhbmQgcmVxdWlyZXMgaXQgdG8gYmUgc3RyaW5naWZ5KCknZFxuICAgICAgICBQYXlsb2FkOiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgUmVxdWVzdFR5cGU6ICdVcGRhdGUnLFxuICAgICAgICAgIFJlc3BvbnNlVVJMOiBSRVFVSVJFRF9CWV9DRk4sXG4gICAgICAgICAgUGh5c2ljYWxSZXNvdXJjZUlkOiBSRVFVSVJFRF9CWV9DRk4sXG4gICAgICAgICAgU3RhY2tJZDogUkVRVUlSRURfQllfQ0ZOLFxuICAgICAgICAgIFJlcXVlc3RJZDogUkVRVUlSRURfQllfQ0ZOLFxuICAgICAgICAgIExvZ2ljYWxSZXNvdXJjZUlkOiBSRVFVSVJFRF9CWV9DRk4sXG4gICAgICAgICAgUmVzb3VyY2VQcm9wZXJ0aWVzOiBzdHJpbmdpZnlPYmplY3QoY3VzdG9tUmVzb3VyY2VQcm9wZXJ0aWVzKSwgLy8gSlNPTi5zdHJpbmdpZnkoKSBkb2Vzbid0IHR1cm4gdGhlIGFjdHVhbCBvYmplY3RzIHRvIHN0cmluZ3MsIGJ1dCB0aGUgbGFtYmRhIGV4cGVjdHMgc3RyaW5nc1xuICAgICAgICB9KSxcbiAgICAgIH0pLnByb21pc2UoKTtcbiAgICB9LFxuICB9KTtcblxuICByZXR1cm4gcmV0O1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2tpcENoYW5nZUZvclMzRGVwbG95Q3VzdG9tUmVzb3VyY2VQb2xpY3koXG4gIGlhbVBvbGljeUxvZ2ljYWxJZDogc3RyaW5nLCBjaGFuZ2U6IEhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZSwgZXZhbHVhdGVDZm5UZW1wbGF0ZTogRXZhbHVhdGVDbG91ZEZvcm1hdGlvblRlbXBsYXRlLFxuKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIGlmIChjaGFuZ2UubmV3VmFsdWUuVHlwZSAhPT0gJ0FXUzo6SUFNOjpQb2xpY3knKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHJvbGVzOiBzdHJpbmdbXSA9IGNoYW5nZS5uZXdWYWx1ZS5Qcm9wZXJ0aWVzPy5Sb2xlcztcblxuICAvLyBJZiBubyByb2xlcyBhcmUgcmVmZXJlbmNlZCwgdGhlIHBvbGljeSBpcyBkZWZpbml0ZWx5IG5vdCB1c2VkIGZvciBhIFMzRGVwbG95bWVudFxuICBpZiAoIXJvbGVzIHx8ICFyb2xlcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBDaGVjayBpZiBldmVyeSByb2xlIHRoaXMgcG9saWN5IGlzIHJlZmVyZW5jZWQgYnkgaXMgb25seSB1c2VkIGZvciBhIFMzRGVwbG95bWVudFxuICBmb3IgKGNvbnN0IHJvbGUgb2Ygcm9sZXMpIHtcbiAgICBjb25zdCByb2xlQXJuID0gYXdhaXQgZXZhbHVhdGVDZm5UZW1wbGF0ZS5ldmFsdWF0ZUNmbkV4cHJlc3Npb24ocm9sZSk7XG4gICAgY29uc3Qgcm9sZUxvZ2ljYWxJZCA9IGF3YWl0IGV2YWx1YXRlQ2ZuVGVtcGxhdGUuZmluZExvZ2ljYWxJZEZvclBoeXNpY2FsTmFtZShyb2xlQXJuKTtcblxuICAgIC8vIFdlIG11c3QgYXNzdW1lIHRoaXMgcm9sZSBpcyB1c2VkIGZvciBzb21ldGhpbmcgZWxzZSwgYmVjYXVzZSB3ZSBjYW4ndCBjaGVjayBpdFxuICAgIGlmICghcm9sZUxvZ2ljYWxJZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIEZpbmQgYWxsIGludGVyZXN0aW5nIHJlZmVyZW5jZSB0byB0aGUgcm9sZVxuICAgIGNvbnN0IHJvbGVSZWZzID0gZXZhbHVhdGVDZm5UZW1wbGF0ZS5maW5kUmVmZXJlbmNlc1RvKHJvbGVMb2dpY2FsSWQpXG4gICAgICAvLyB3ZSBhcmUgbm90IGludGVyZXN0ZWQgaW4gdGhlIHJlZmVyZW5jZSBmcm9tIHRoZSBvcmlnaW5hbCBwb2xpY3kgLSBpdCBhbHdheXMgZXhpc3RzXG4gICAgICAuZmlsdGVyKHJvbGVSZWYgPT4gIShyb2xlUmVmLlR5cGUgPT0gJ0FXUzo6SUFNOjpQb2xpY3knICYmIHJvbGVSZWYuTG9naWNhbElkID09PSBpYW1Qb2xpY3lMb2dpY2FsSWQpKTtcblxuICAgIC8vIENoZWNrIGlmIHRoZSByb2xlIGlzIG9ubHkgdXNlZCBmb3IgUzNEZXBsb3ltZW50XG4gICAgLy8gV2Uga25vdyB0aGlzIGlzIHRoZSBjYXNlLCBpZiBTM0RlcGxveW1lbnQgLT4gTGFtYmRhIC0+IFJvbGUgaXMgc2F0aXNmaWVkIGZvciBldmVyeSByZWZlcmVuY2VcbiAgICAvLyBBbmQgd2UgaGF2ZSBhdCBsZWFzdCBvbmUgcmVmZXJlbmNlLlxuICAgIGNvbnN0IGlzUm9sZU9ubHlGb3JTM0RlcGxveW1lbnQgPSByb2xlUmVmcy5sZW5ndGggPj0gMSAmJiByb2xlUmVmcy5ldmVyeShyb2xlUmVmID0+IHtcbiAgICAgIGlmIChyb2xlUmVmLlR5cGUgPT09ICdBV1M6OkxhbWJkYTo6RnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IGxhbWJkYVJlZnMgPSBldmFsdWF0ZUNmblRlbXBsYXRlLmZpbmRSZWZlcmVuY2VzVG8ocm9sZVJlZi5Mb2dpY2FsSWQpO1xuICAgICAgICAvLyBFdmVyeSByZWZlcmVuY2UgbXVzdCBiZSB0byB0aGUgY3VzdG9tIHJlc291cmNlIGFuZCBhdCBsZWFzdCBvbmUgcmVmZXJlbmNlIG11c3QgYmUgcHJlc2VudFxuICAgICAgICByZXR1cm4gbGFtYmRhUmVmcy5sZW5ndGggPj0gMSAmJiBsYW1iZGFSZWZzLmV2ZXJ5KGxhbWJkYVJlZiA9PiBsYW1iZGFSZWYuVHlwZSA9PT0gJ0N1c3RvbTo6Q0RLQnVja2V0RGVwbG95bWVudCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuXG4gICAgLy8gV2UgaGF2ZSBkZXRlcm1pbmVkIHRoaXMgcm9sZSBpcyB1c2VkIGZvciBzb21ldGhpbmcgZWxzZSwgc28gd2UgY2FuJ3Qgc2tpcCB0aGUgY2hhbmdlXG4gICAgaWYgKCFpc1JvbGVPbmx5Rm9yUzNEZXBsb3ltZW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLy8gV2UgaGF2ZSBjaGVja2VkIHRoYXQgYW55IHVzZSBvZiB0aGlzIHBvbGljeSBpcyBvbmx5IGZvciBTM0RlcGxveW1lbnQgYW5kIHdlIGNhbiBzYWZlbHkgc2tpcCBpdFxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5T2JqZWN0KG9iajogYW55KTogYW55IHtcbiAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgcmV0dXJuIG9iai5tYXAoc3RyaW5naWZ5T2JqZWN0KTtcbiAgfVxuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gb2JqLnRvU3RyaW5nKCk7XG4gIH1cblxuICBjb25zdCByZXQ6IHsgW2s6IHN0cmluZ106IGFueSB9ID0ge307XG4gIGZvciAoY29uc3QgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKG9iaikpIHtcbiAgICByZXRba10gPSBzdHJpbmdpZnlPYmplY3Qodik7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbiJdfQ==