"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FromScan = exports.CfnTemplateGeneratorProvider = exports.appendWarningsToReadme = exports.buildCfnClient = exports.buildGenertedTemplateOutput = exports.isThereAWarning = exports.getMigrateScanType = exports.writeMigrateJsonFile = exports.displayTimeDiff = exports.rewriteLine = exports.printDots = exports.printBar = exports.scanProgressBar = exports.parseSourceOptions = exports.FilterType = exports.ScanStatus = exports.TemplateSourceOptions = exports.setEnvironment = exports.chunks = exports.generateTemplate = exports.readFromStack = exports.readFromPath = exports.generateStack = exports.generateCdkApp = exports.MIGRATE_SUPPORTED_LANGUAGES = void 0;
/* eslint-disable @typescript-eslint/no-require-imports */
/* eslint-disable @typescript-eslint/no-var-requires */
const fs = require("fs");
const path = require("path");
const cx_api_1 = require("@aws-cdk/cx-api");
const cdk_from_cfn = require("cdk-from-cfn");
const chalk = require("chalk");
const init_1 = require("../../lib/init");
const logging_1 = require("../../lib/logging");
const aws_auth_1 = require("../api/aws-auth");
const cloudformation_1 = require("../api/util/cloudformation");
const archive_1 = require("../util/archive");
const camelCase = require('camelcase');
const decamelize = require('decamelize');
/** The list of languages supported by the built-in noctilucent binary. */
exports.MIGRATE_SUPPORTED_LANGUAGES = cdk_from_cfn.supported_languages();
/**
 * Generates a CDK app from a yaml or json template.
 *
 * @param stackName The name to assign to the stack in the generated app
 * @param stack The yaml or json template for the stack
 * @param language The language to generate the CDK app in
 * @param outputPath The path at which to generate the CDK app
 */
async function generateCdkApp(stackName, stack, language, outputPath, compress) {
    const resolvedOutputPath = path.join(outputPath ?? process.cwd(), stackName);
    const formattedStackName = decamelize(stackName);
    try {
        fs.rmSync(resolvedOutputPath, { recursive: true, force: true });
        fs.mkdirSync(resolvedOutputPath, { recursive: true });
        const generateOnly = compress;
        await (0, init_1.cliInit)({
            type: 'app',
            language,
            canUseNetwork: true,
            generateOnly,
            workDir: resolvedOutputPath,
            stackName,
            migrate: true,
        });
        let stackFileName;
        switch (language) {
            case 'typescript':
                stackFileName = `${resolvedOutputPath}/lib/${formattedStackName}-stack.ts`;
                break;
            case 'java':
                stackFileName = `${resolvedOutputPath}/src/main/java/com/myorg/${camelCase(formattedStackName, { pascalCase: true })}Stack.java`;
                break;
            case 'python':
                stackFileName = `${resolvedOutputPath}/${formattedStackName.replace(/-/g, '_')}/${formattedStackName.replace(/-/g, '_')}_stack.py`;
                break;
            case 'csharp':
                stackFileName = `${resolvedOutputPath}/src/${camelCase(formattedStackName, { pascalCase: true })}/${camelCase(formattedStackName, { pascalCase: true })}Stack.cs`;
                break;
            case 'go':
                stackFileName = `${resolvedOutputPath}/${formattedStackName}.go`;
                break;
            default:
                throw new Error(`${language} is not supported by CDK Migrate. Please choose from: ${exports.MIGRATE_SUPPORTED_LANGUAGES.join(', ')}`);
        }
        fs.writeFileSync(stackFileName, stack);
        if (compress) {
            await (0, archive_1.zipDirectory)(resolvedOutputPath, `${resolvedOutputPath}.zip`);
            fs.rmSync(resolvedOutputPath, { recursive: true, force: true });
        }
    }
    catch (error) {
        fs.rmSync(resolvedOutputPath, { recursive: true, force: true });
        throw error;
    }
}
exports.generateCdkApp = generateCdkApp;
/**
 * Generates a CDK stack file.
 * @param template The template to translate into a CDK stack
 * @param stackName The name to assign to the stack
 * @param language The language to generate the stack in
 * @returns A string representation of a CDK stack file
 */
function generateStack(template, stackName, language) {
    try {
        const formattedStackName = `${camelCase(decamelize(stackName), { pascalCase: true })}Stack`;
        return cdk_from_cfn.transmute(template, language, formattedStackName);
    }
    catch (e) {
        throw new Error(`stack generation failed due to error '${e.message}'`);
    }
}
exports.generateStack = generateStack;
/**
 * Reads and returns a stack template from a local path.
 *
 * @param inputPath The location of the template
 * @returns A string representation of the template if present, otherwise undefined
 */
function readFromPath(inputPath) {
    let readFile;
    try {
        readFile = fs.readFileSync(inputPath, 'utf8');
    }
    catch (e) {
        throw new Error(`'${inputPath}' is not a valid path.`);
    }
    if (readFile == '') {
        throw new Error(`Cloudformation template filepath: '${inputPath}' is an empty file.`);
    }
    return readFile;
}
exports.readFromPath = readFromPath;
/**
 * Reads and returns a stack template from a deployed CloudFormation stack.
 *
 * @param stackName The name of the stack
 * @param sdkProvider The sdk provider for making CloudFormation calls
 * @param environment The account and region where the stack is deployed
 * @returns A string representation of the template if present, otherwise undefined
 */
async function readFromStack(stackName, sdkProvider, environment) {
    const cloudFormation = (await sdkProvider.forEnvironment(environment, aws_auth_1.Mode.ForReading)).sdk.cloudFormation();
    const stack = await cloudformation_1.CloudFormationStack.lookup(cloudFormation, stackName);
    if (stack.stackStatus.isDeploySuccess || stack.stackStatus.isRollbackSuccess) {
        return JSON.stringify(await stack.template());
    }
    else {
        throw new Error(`Stack '${stackName}' in account ${environment.account} and region ${environment.region} has a status of '${stack.stackStatus.name}' due to '${stack.stackStatus.reason}'. The stack cannot be migrated until it is in a healthy state.`);
    }
    return;
}
exports.readFromStack = readFromStack;
/**
 * Takes in a stack name and account and region and returns a generated cloudformation template using the cloudformation
 * template generator.
 *
 * @param GenerateTemplateOptions An object containing the stack name, filters, sdkProvider, environment, and newScan flag
 * @returns a generated cloudformation template
 */
async function generateTemplate(options) {
    const cfn = new CfnTemplateGeneratorProvider(await buildCfnClient(options.sdkProvider, options.environment));
    const scanId = await findLastSuccessfulScan(cfn, options);
    // if a customer accidentally ctrl-c's out of the command and runs it again, this will continue the progress bar where it left off
    const curScan = await cfn.describeResourceScan(scanId);
    if ((curScan.Status == ScanStatus.IN_PROGRESS)) {
        (0, logging_1.print)('Resource scan in progress. Please wait, this can take 10 minutes or longer.');
        await scanProgressBar(scanId, cfn);
    }
    displayTimeDiff(new Date(), new Date(curScan.StartTime));
    let resources = await cfn.listResourceScanResources(scanId, options.filters);
    (0, logging_1.print)('finding related resources.');
    let relatedResources = await cfn.getResourceScanRelatedResources(scanId, resources);
    (0, logging_1.print)(`Found ${relatedResources.length} resources.`);
    (0, logging_1.print)('Generating CFN template from scanned resources.');
    const templateArn = (await cfn.createGeneratedTemplate(options.stackName, relatedResources)).GeneratedTemplateId;
    let generatedTemplate = await cfn.describeGeneratedTemplate(templateArn);
    (0, logging_1.print)('Please wait, template creation in progress. This may take a couple minutes.');
    while (generatedTemplate.Status !== ScanStatus.COMPLETE && generatedTemplate.Status !== ScanStatus.FAILED) {
        await printDots(`[${generatedTemplate.Status}] Template Creation in Progress`, 400);
        generatedTemplate = await cfn.describeGeneratedTemplate(templateArn);
    }
    (0, logging_1.print)('');
    (0, logging_1.print)('Template successfully generated!');
    return buildGenertedTemplateOutput(generatedTemplate, (await cfn.getGeneratedTemplate(templateArn)).TemplateBody, templateArn);
}
exports.generateTemplate = generateTemplate;
async function findLastSuccessfulScan(cfn, options) {
    let resourceScanSummaries = [];
    const clientRequestToken = `cdk-migrate-${options.environment.account}-${options.environment.region}`;
    if (options.fromScan === FromScan.NEW) {
        (0, logging_1.print)(`Starting new scan for account ${options.environment.account} in region ${options.environment.region}`);
        try {
            await cfn.startResourceScan(clientRequestToken);
            resourceScanSummaries = (await cfn.listResourceScans()).ResourceScanSummaries;
        }
        catch (e) {
            // continuing here because if the scan fails on a new-scan it is very likely because there is either already a scan in progress
            // or the customer hit a rate limit. In either case we want to continue with the most recent scan.
            // If this happens to fail for a credential error then that will be caught immediately after anyway.
            (0, logging_1.print)(`Scan failed to start due to error '${e.message}', defaulting to latest scan.`);
        }
    }
    else {
        resourceScanSummaries = (await cfn.listResourceScans()).ResourceScanSummaries;
        await cfn.checkForResourceScan(resourceScanSummaries, options, clientRequestToken);
    }
    // get the latest scan, which we know will exist
    resourceScanSummaries = (await cfn.listResourceScans()).ResourceScanSummaries;
    let scanId = resourceScanSummaries[0].ResourceScanId;
    // find the most recent scan that isn't in a failed state in case we didn't start a new one
    for (const summary of resourceScanSummaries) {
        if (summary.Status !== ScanStatus.FAILED) {
            scanId = summary.ResourceScanId;
            break;
        }
    }
    return scanId;
}
/**
 * Takes a string of filters in the format of key1=value1,key2=value2 and returns a map of the filters.
 *
 * @param filters a string of filters in the format of key1=value1,key2=value2
 * @returns a map of the filters
 */
function parseFilters(filters) {
    if (!filters) {
        return {
            'resource-identifier': undefined,
            'resource-type-prefix': undefined,
            'tag-key': undefined,
            'tag-value': undefined,
        };
    }
    ;
    const filterShorthands = {
        'identifier': FilterType.RESOURCE_IDENTIFIER,
        'id': FilterType.RESOURCE_IDENTIFIER,
        'type': FilterType.RESOURCE_TYPE_PREFIX,
        'type-prefix': FilterType.RESOURCE_TYPE_PREFIX,
    };
    const filterList = filters.split(',');
    let filterMap = {
        [FilterType.RESOURCE_IDENTIFIER]: undefined,
        [FilterType.RESOURCE_TYPE_PREFIX]: undefined,
        [FilterType.TAG_KEY]: undefined,
        [FilterType.TAG_VALUE]: undefined,
    };
    for (const fil of filterList) {
        const filter = fil.split('=');
        let filterKey = filter[0];
        const filterValue = filter[1];
        // if the key is a shorthand, replace it with the full name
        if (filterKey in filterShorthands) {
            filterKey = filterShorthands[filterKey];
        }
        if (Object.values(FilterType).includes(filterKey)) {
            filterMap[filterKey] = filterValue;
        }
        else {
            throw new Error(`Invalid filter: ${filterKey}`);
        }
    }
    return filterMap;
}
/**
 * Takes a list of any type and breaks it up into chunks of a specified size.
 *
 * @param list The list to break up
 * @param chunkSize The size of each chunk
 * @returns A list of lists of the specified size
 */
function chunks(list, chunkSize) {
    const chunkedList = [];
    for (let i = 0; i < list.length; i += chunkSize) {
        chunkedList.push(list.slice(i, i + chunkSize));
    }
    return chunkedList;
}
exports.chunks = chunks;
/**
 * Sets the account and region for making CloudFormation calls.
 * @param account The account to use
 * @param region The region to use
 * @returns The environment object
 */
function setEnvironment(account, region) {
    return { account: account ?? cx_api_1.UNKNOWN_ACCOUNT, region: region ?? cx_api_1.UNKNOWN_REGION, name: 'cdk-migrate-env' };
}
exports.setEnvironment = setEnvironment;
/**
 * Enum for the source options for the template
 */
var TemplateSourceOptions;
(function (TemplateSourceOptions) {
    TemplateSourceOptions["PATH"] = "path";
    TemplateSourceOptions["STACK"] = "stack";
    TemplateSourceOptions["SCAN"] = "scan";
})(TemplateSourceOptions || (exports.TemplateSourceOptions = TemplateSourceOptions = {}));
/**
 * Enum for the status of a resource scan
 */
var ScanStatus;
(function (ScanStatus) {
    ScanStatus["IN_PROGRESS"] = "IN_PROGRESS";
    ScanStatus["COMPLETE"] = "COMPLETE";
    ScanStatus["FAILED"] = "FAILED";
})(ScanStatus || (exports.ScanStatus = ScanStatus = {}));
var FilterType;
(function (FilterType) {
    FilterType["RESOURCE_IDENTIFIER"] = "resource-identifier";
    FilterType["RESOURCE_TYPE_PREFIX"] = "resource-type-prefix";
    FilterType["TAG_KEY"] = "tag-key";
    FilterType["TAG_VALUE"] = "tag-value";
})(FilterType || (exports.FilterType = FilterType = {}));
/**
 * Validates that exactly one source option has been provided.
 * @param fromPath The content of the flag `--from-path`
 * @param fromStack the content of the flag `--from-stack`
 */
function parseSourceOptions(fromPath, fromStack, stackName) {
    if (fromPath && fromStack) {
        throw new Error('Only one of `--from-path` or `--from-stack` may be provided.');
    }
    if (!stackName) {
        throw new Error('`--stack-name` is a required field.');
    }
    if (!fromPath && !fromStack) {
        return { source: TemplateSourceOptions.SCAN };
    }
    if (fromPath) {
        return { source: TemplateSourceOptions.PATH, templatePath: fromPath };
    }
    return { source: TemplateSourceOptions.STACK, stackName: stackName };
}
exports.parseSourceOptions = parseSourceOptions;
/**
 * Takes a set of resources and removes any with the managedbystack flag set to true.
 *
 * @param resourceList the list of resources provided by the list scanned resources calls
 * @returns a list of resources not managed by cfn stacks
 */
function excludeManaged(resourceList) {
    return resourceList.filter((r) => !r.ManagedByStack).map((r) => ({
        ResourceType: r.ResourceType,
        ResourceIdentifier: r.ResourceIdentifier,
    }));
}
/**
 * Transforms a list of resources into a list of resource identifiers by removing the ManagedByStack flag.
 * Setting the value of the field to undefined effectively removes it from the object.
 *
 * @param resourceList the list of resources provided by the list scanned resources calls
 * @returns a list of ScannedResourceIdentifiers
 */
function resourceIdentifiers(resourceList) {
    const identifiers = [];
    resourceList.forEach((r) => {
        const identifier = {
            ResourceType: r.ResourceType,
            ResourceIdentifier: r.ResourceIdentifier,
        };
        identifiers.push(identifier);
    });
    return identifiers;
}
/**
 * Takes a scan id and maintains a progress bar to display the progress of a scan to the user.
 *
 * @param scanId A string representing the scan id
 * @param cloudFormation The CloudFormation sdk client to use
 */
async function scanProgressBar(scanId, cfn) {
    let curProgress = 0.5;
    // we know it's in progress initially since we wouldn't have gotten here if it wasn't
    let curScan = { Status: ScanStatus.IN_PROGRESS };
    while (curScan.Status == ScanStatus.IN_PROGRESS) {
        curScan = await cfn.describeResourceScan(scanId);
        curProgress = curScan.PercentageCompleted ?? curProgress;
        printBar(30, curProgress);
        await new Promise(resolve => setTimeout(resolve, 2000));
    }
    (0, logging_1.print)('');
    (0, logging_1.print)('✅ Scan Complete!');
}
exports.scanProgressBar = scanProgressBar;
/**
 * Prints a progress bar to the console. To be used in a while loop to show progress of a long running task.
 * The progress bar deletes the current line on the console and rewrites it with the progress amount.
 *
 * @param width The width of the progress bar
 * @param progress The current progress to display as a percentage of 100
 */
function printBar(width, progress) {
    if (!process.env.MIGRATE_INTEG_TEST) {
        const FULL_BLOCK = '█';
        const PARTIAL_BLOCK = ['', '▏', '▎', '▍', '▌', '▋', '▊', '▉'];
        const fraction = Math.min(progress / 100, 1);
        const innerWidth = Math.max(1, width - 2);
        const chars = innerWidth * fraction;
        const remainder = chars - Math.floor(chars);
        const fullChars = FULL_BLOCK.repeat(Math.floor(chars));
        const partialChar = PARTIAL_BLOCK[Math.floor(remainder * PARTIAL_BLOCK.length)];
        const filler = '·'.repeat(innerWidth - Math.floor(chars) - (partialChar ? 1 : 0));
        const color = chalk.green;
        rewriteLine('[' + color(fullChars + partialChar) + filler + `] (${progress}%)`);
    }
}
exports.printBar = printBar;
/**
 * Prints a message to the console with a series periods appended to it. To be used in a while loop to show progress of a long running task.
 * The message deletes the current line and rewrites it several times to display 1-3 periods to show the user that the task is still running.
 *
 * @param message The message to display
 * @param timeoutx4 The amount of time to wait before printing the next period
 */
async function printDots(message, timeoutx4) {
    if (!process.env.MIGRATE_INTEG_TEST) {
        rewriteLine(message + ' .');
        await new Promise(resolve => setTimeout(resolve, timeoutx4));
        rewriteLine(message + ' ..');
        await new Promise(resolve => setTimeout(resolve, timeoutx4));
        rewriteLine(message + ' ...');
        await new Promise(resolve => setTimeout(resolve, timeoutx4));
        rewriteLine(message);
        await new Promise(resolve => setTimeout(resolve, timeoutx4));
    }
}
exports.printDots = printDots;
/**
 * Rewrites the current line on the console and writes a new message to it.
 * This is a helper funciton for printDots and printBar.
 *
 * @param message The message to display
 */
function rewriteLine(message) {
    process.stdout.clearLine(0);
    process.stdout.cursorTo(0);
    process.stdout.write(message);
}
exports.rewriteLine = rewriteLine;
/**
 * Prints the time difference between two dates in days, hours, and minutes.
 *
 * @param time1 The first date to compare
 * @param time2 The second date to compare
 */
function displayTimeDiff(time1, time2) {
    const diff = Math.abs(time1.getTime() - time2.getTime());
    const days = Math.floor(diff / (1000 * 60 * 60 * 24));
    const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
    const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
    (0, logging_1.print)(`Using the latest successful scan which is ${days} days, ${hours} hours, and ${minutes} minutes old.`);
}
exports.displayTimeDiff = displayTimeDiff;
/**
 * Writes a migrate.json file to the output directory.
 *
 * @param outputPath The path to write the migrate.json file to
 * @param stackName The name of the stack
 * @param generatedOutput The output of the template generator
 */
function writeMigrateJsonFile(outputPath, stackName, migrateJson) {
    const outputToJson = {
        '//': 'This file is generated by cdk migrate. It will be automatically deleted after the first successful deployment of this app to the environment of the original resources.',
        'Source': migrateJson.source,
        'Resources': migrateJson.resources,
    };
    fs.writeFileSync(`${path.join(outputPath ?? process.cwd(), stackName)}/migrate.json`, JSON.stringify(outputToJson, null, 2));
}
exports.writeMigrateJsonFile = writeMigrateJsonFile;
/**
 * Takes a string representing the from-scan flag and returns a FromScan enum value.
 *
 * @param scanType A string representing the from-scan flag
 * @returns A FromScan enum value
 */
function getMigrateScanType(scanType) {
    switch (scanType) {
        case 'new':
            return FromScan.NEW;
        case 'most-recent':
            return FromScan.MOST_RECENT;
        case '':
            return FromScan.DEFAULT;
        case undefined:
            return FromScan.DEFAULT;
        default:
            throw new Error(`Unknown scan type: ${scanType}`);
    }
}
exports.getMigrateScanType = getMigrateScanType;
/**
 * Takes a generatedTemplateOutput objct and returns a boolean representing whether there are any warnings on any rescources.
 *
 * @param generatedTemplateOutput A GenerateTemplateOutput object
 * @returns A boolean representing whether there are any warnings on any rescources
 */
function isThereAWarning(generatedTemplateOutput) {
    if (generatedTemplateOutput.resources) {
        for (const resource of generatedTemplateOutput.resources) {
            if (resource.Warnings && resource.Warnings.length > 0) {
                return true;
            }
        }
    }
    return false;
}
exports.isThereAWarning = isThereAWarning;
/**
 * Builds the GenerateTemplateOutput object from the DescribeGeneratedTemplateOutput and the template body.
 *
 * @param generatedTemplateSummary The output of the describe generated template call
 * @param templateBody The body of the generated template
 * @returns A GenerateTemplateOutput object
 */
function buildGenertedTemplateOutput(generatedTemplateSummary, templateBody, source) {
    const resources = generatedTemplateSummary.Resources;
    const migrateJson = {
        templateBody: templateBody,
        source: source,
        resources: generatedTemplateSummary.Resources.map((r) => ({
            ResourceType: r.ResourceType,
            LogicalResourceId: r.LogicalResourceId,
            ResourceIdentifier: r.ResourceIdentifier,
        })),
    };
    const templateId = generatedTemplateSummary.GeneratedTemplateId;
    return {
        migrateJson: migrateJson,
        resources: resources,
        templateId: templateId,
    };
}
exports.buildGenertedTemplateOutput = buildGenertedTemplateOutput;
/**
 * Builds a CloudFormation sdk client for making requests with the CFN template generator.
 *
 * @param sdkProvider The sdk provider for making CloudFormation calls
 * @param environment The account and region where the stack is deployed
 * @returns A CloudFormation sdk client
 */
async function buildCfnClient(sdkProvider, environment) {
    const cloudFormationClient = (await sdkProvider.forEnvironment(environment, aws_auth_1.Mode.ForReading)).sdk.cloudFormation();
    cloudFormationClient.config.customUserAgent = 'cdk-migrate';
    return cloudFormationClient;
}
exports.buildCfnClient = buildCfnClient;
/**
 * Appends a list of warnings to a readme file.
 *
 * @param filepath The path to the readme file
 * @param resources A list of resources to append warnings for
 */
function appendWarningsToReadme(filepath, resources) {
    const readme = fs.readFileSync(filepath, 'utf8');
    const lines = readme.split('\n');
    const index = lines.findIndex((line) => line.trim() === 'Enjoy!');
    let linesToAdd = ['\n## Warnings'];
    linesToAdd.push('### Write-only properties');
    linesToAdd.push("Write-only properties are resource property values that can be written to but can't be read by AWS CloudFormation or CDK Migrate. For more information, see [IaC generator and write-only properties](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/generate-IaC-write-only-properties.html).");
    linesToAdd.push('\n');
    linesToAdd.push('Write-only properties discovered during migration are organized here by resource ID and categorized by write-only property type. Resolve write-only properties by providing property values in your CDK app. For guidance, see [Resolve write-only properties](https://docs.aws.amazon.com/cdk/v2/guide/migrate.html#migrate-resources-writeonly).');
    for (const resource of resources) {
        if (resource.Warnings && resource.Warnings.length > 0) {
            linesToAdd.push(`### ${resource.LogicalResourceId}`);
            for (const warning of resource.Warnings) {
                linesToAdd.push(`- **${warning.Type}**: `);
                for (const property of warning.Properties) {
                    linesToAdd.push(`  - ${property.PropertyPath}: ${property.Description}`);
                }
            }
        }
    }
    lines.splice(index, 0, ...linesToAdd);
    fs.writeFileSync(filepath, lines.join('\n'));
}
exports.appendWarningsToReadme = appendWarningsToReadme;
/**
 * takes a list of resources and returns a list of unique resources based on the resource type and logical resource id.
 *
 * @param resources A list of resources to deduplicate
 * @returns A list of unique resources
 */
function deduplicateResources(resources) {
    let uniqueResources = {};
    for (const resource of resources) {
        const key = Object.keys(resource.ResourceIdentifier)[0];
        // Creating our unique identifier using the resource type, the key, and the value of the resource identifier
        // The resource identifier is a combination of a key value pair defined by a resource's schema, and the resource type of the resource.
        const uniqueIdentifer = `${resource.ResourceType}:${key}:${resource.ResourceIdentifier[key]}`;
        uniqueResources[uniqueIdentifer] = resource;
    }
    return Object.values(uniqueResources);
}
;
/**
 * Class for making CloudFormation template generator calls
 */
class CfnTemplateGeneratorProvider {
    constructor(cfn) {
        this.cfn = cfn;
    }
    async checkForResourceScan(resourceScanSummaries, options, clientRequestToken) {
        if (!resourceScanSummaries || resourceScanSummaries.length === 0) {
            if (options.fromScan === FromScan.MOST_RECENT) {
                throw new Error('No scans found. Please either start a new scan with the `--from-scan` new or do not specify a `--from-scan` option.');
            }
            else {
                (0, logging_1.print)('No scans found. Initiating a new resource scan.');
                await this.startResourceScan(clientRequestToken);
            }
        }
    }
    /**
     * Retrieves a tokenized list of resources and their associated scan. If a token is present the function
     * will loop through all pages and combine them into a single list of ScannedRelatedResources
     *
     * @param scanId scan id for the to list resources for
     * @param resources A list of resources to find related resources for
     */
    async getResourceScanRelatedResources(scanId, resources) {
        let relatedResourceList = resources;
        // break the list of resources into chunks of 100 to avoid hitting the 100 resource limit
        for (const chunk of chunks(resources, 100)) {
            // get the first page of related resources
            const res = await this.cfn.listResourceScanRelatedResources({
                ResourceScanId: scanId,
                Resources: chunk,
            }).promise();
            // add the first page to the list
            relatedResourceList.push(...(res.RelatedResources ?? []));
            let nextToken = res.NextToken;
            // if there are more pages, cycle through them and add them to the list before moving on to the next chunk
            while (nextToken) {
                const nextRelatedResources = await this.cfn.listResourceScanRelatedResources({
                    ResourceScanId: scanId,
                    Resources: resourceIdentifiers(resources),
                    NextToken: nextToken,
                }).promise();
                nextToken = nextRelatedResources.NextToken;
                relatedResourceList.push(...(nextRelatedResources.RelatedResources ?? []));
            }
        }
        relatedResourceList = deduplicateResources(relatedResourceList);
        // prune the managedbystack flag off of them again.
        return process.env.MIGRATE_INTEG_TEST ? resourceIdentifiers(relatedResourceList) : resourceIdentifiers(excludeManaged(relatedResourceList));
    }
    /**
     * Kicks off a scan of a customers account, returning the scan id. A scan can take
     * 10 minutes or longer to complete. However this will return a scan id as soon as
     * the scan has begun.
     *
     * @returns A string representing the scan id
     */
    async startResourceScan(requestToken) {
        return (await this.cfn.startResourceScan({
            ClientRequestToken: requestToken,
        }).promise()).ResourceScanId;
    }
    /**
     * Gets the most recent scans a customer has completed
     *
     * @returns a list of resource scan summaries
     */
    async listResourceScans() {
        return this.cfn.listResourceScans().promise();
    }
    /**
     * Retrieves a tokenized list of resources from a resource scan. If a token is present, this function
     * will loop through all pages and combine them into a single list of ScannedResources.
     * Additionally will apply any filters provided by the customer.
     *
     * @param scanId scan id for the to list resources for
     * @param filters a string of filters in the format of key1=value1,key2=value2
     * @returns a combined list of all resources from the scan
     */
    async listResourceScanResources(scanId, filters = []) {
        let resourceList = [];
        let resourceScanInputs;
        if (filters.length > 0) {
            (0, logging_1.print)('Applying filters to resource scan.');
            for (const filter of filters) {
                const filterList = parseFilters(filter);
                resourceScanInputs = {
                    ResourceScanId: scanId,
                    ResourceIdentifier: filterList[FilterType.RESOURCE_IDENTIFIER],
                    ResourceTypePrefix: filterList[FilterType.RESOURCE_TYPE_PREFIX],
                    TagKey: filterList[FilterType.TAG_KEY],
                    TagValue: filterList[FilterType.TAG_VALUE],
                };
                const resources = await this.cfn.listResourceScanResources(resourceScanInputs).promise();
                resourceList = resourceList.concat(resources.Resources ?? []);
                let nextToken = resources.NextToken;
                // cycle through the pages adding all resources to the list until we run out of pages
                while (nextToken) {
                    resourceScanInputs.NextToken = nextToken;
                    const nextResources = await this.cfn.listResourceScanResources(resourceScanInputs).promise();
                    nextToken = nextResources.NextToken;
                    resourceList = resourceList.concat(nextResources.Resources ?? []);
                }
            }
        }
        else {
            (0, logging_1.print)('No filters provided. Retrieving all resources from scan.');
            resourceScanInputs = {
                ResourceScanId: scanId,
            };
            const resources = await this.cfn.listResourceScanResources(resourceScanInputs).promise();
            resourceList = resourceList.concat(resources.Resources ?? []);
            let nextToken = resources.NextToken;
            // cycle through the pages adding all resources to the list until we run out of pages
            while (nextToken) {
                resourceScanInputs.NextToken = nextToken;
                const nextResources = await this.cfn.listResourceScanResources(resourceScanInputs).promise();
                nextToken = nextResources.NextToken;
                resourceList = resourceList.concat(nextResources.Resources ?? []);
            }
        }
        if (resourceList.length === 0) {
            throw new Error(`No resources found with filters ${filters.join(' ')}. Please try again with different filters.`);
        }
        resourceList = deduplicateResources(resourceList);
        return process.env.MIGRATE_INTEG_TEST ? resourceIdentifiers(resourceList) : resourceIdentifiers(excludeManaged(resourceList));
    }
    /**
     * Retrieves information about a resource scan.
     *
     * @param scanId scan id for the to list resources for
     * @returns information about the scan
     */
    async describeResourceScan(scanId) {
        return this.cfn.describeResourceScan({
            ResourceScanId: scanId,
        }).promise();
    }
    /**
     * Describes the current status of the template being generated.
     *
     * @param templateId A string representing the template id
     * @returns DescribeGeneratedTemplateOutput an object containing the template status and results
     */
    async describeGeneratedTemplate(templateId) {
        const generatedTemplate = await this.cfn.describeGeneratedTemplate({
            GeneratedTemplateName: templateId,
        }).promise();
        if (generatedTemplate.Status == ScanStatus.FAILED) {
            throw new Error(generatedTemplate.StatusReason);
        }
        return generatedTemplate;
    }
    /**
   * Retrieves a completed generated cloudformation template from the template generator.
   *
   * @param templateId A string representing the template id
   * @param cloudFormation The CloudFormation sdk client to use
   * @returns DescribeGeneratedTemplateOutput an object containing the template status and body
   */
    async getGeneratedTemplate(templateId) {
        return this.cfn.getGeneratedTemplate({
            GeneratedTemplateName: templateId,
        }).promise();
    }
    /**
   * Kicks off a template generation for a set of resources.
   *
   * @param stackName The name of the stack
   * @param resources A list of resources to generate the template from
   * @returns CreateGeneratedTemplateOutput an object containing the template arn to query on later
   */
    async createGeneratedTemplate(stackName, resources) {
        const createTemplateOutput = await this.cfn.createGeneratedTemplate({
            Resources: resources,
            GeneratedTemplateName: stackName,
        }).promise();
        if (createTemplateOutput.GeneratedTemplateId === undefined) {
            throw new Error('CreateGeneratedTemplate failed to retrun an Arn.');
        }
        return createTemplateOutput;
    }
    /**
     * Deletes a generated template from the template generator.
     *
     * @param templateArn The arn of the template to delete
     * @returns A promise that resolves when the template has been deleted
     */
    async deleteGeneratedTemplate(templateArn) {
        await this.cfn.deleteGeneratedTemplate({
            GeneratedTemplateName: templateArn,
        }).promise();
    }
}
exports.CfnTemplateGeneratorProvider = CfnTemplateGeneratorProvider;
/**
 * The possible ways to choose a scan to generate a CDK application from
 */
var FromScan;
(function (FromScan) {
    /**
     * Initiate a new resource scan to build the CDK application from.
     */
    FromScan[FromScan["NEW"] = 0] = "NEW";
    /**
     * Use the last successful scan to build the CDK application from. Will fail if no scan is found.
     */
    FromScan[FromScan["MOST_RECENT"] = 1] = "MOST_RECENT";
    /**
     * Starts a scan if none exists, otherwise uses the most recent successful scan to build the CDK application from.
     */
    FromScan[FromScan["DEFAULT"] = 2] = "DEFAULT";
})(FromScan || (exports.FromScan = FromScan = {}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWlncmF0ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIm1pZ3JhdGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsMERBQTBEO0FBQzFELHVEQUF1RDtBQUN2RCx5QkFBeUI7QUFDekIsNkJBQTZCO0FBQzdCLDRDQUErRTtBQUUvRSw2Q0FBNkM7QUFDN0MsK0JBQStCO0FBQy9CLHlDQUF5QztBQUN6QywrQ0FBMEM7QUFDMUMsOENBQW9EO0FBQ3BELCtEQUFpRTtBQUNqRSw2Q0FBK0M7QUFDL0MsTUFBTSxTQUFTLEdBQUcsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0FBQ3ZDLE1BQU0sVUFBVSxHQUFHLE9BQU8sQ0FBQyxZQUFZLENBQUMsQ0FBQztBQUN6QywwRUFBMEU7QUFDN0QsUUFBQSwyQkFBMkIsR0FBc0IsWUFBWSxDQUFDLG1CQUFtQixFQUFFLENBQUM7QUFFakc7Ozs7Ozs7R0FPRztBQUNJLEtBQUssVUFBVSxjQUFjLENBQUMsU0FBaUIsRUFBRSxLQUFhLEVBQUUsUUFBZ0IsRUFBRSxVQUFtQixFQUFFLFFBQWtCO0lBRTlILE1BQU0sa0JBQWtCLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLElBQUksT0FBTyxDQUFDLEdBQUcsRUFBRSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0lBQzdFLE1BQU0sa0JBQWtCLEdBQUcsVUFBVSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBRWpELElBQUk7UUFDRixFQUFFLENBQUMsTUFBTSxDQUFDLGtCQUFrQixFQUFFLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztRQUNoRSxFQUFFLENBQUMsU0FBUyxDQUFDLGtCQUFrQixFQUFFLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7UUFDdEQsTUFBTSxZQUFZLEdBQUcsUUFBUSxDQUFDO1FBQzlCLE1BQU0sSUFBQSxjQUFPLEVBQUM7WUFDWixJQUFJLEVBQUUsS0FBSztZQUNY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QUNqQyxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7UUFFYixJQUFJLG9CQUFvQixDQUFDLG1CQUFtQixLQUFLLFNBQVMsRUFBRTtZQUMxRCxNQUFNLElBQUksS0FBSyxDQUFDLGtEQUFrRCxDQUFDLENBQUM7U0FDckU7UUFDRCxPQUFPLG9CQUFvQixDQUFDO0lBQzlCLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILEtBQUssQ0FBQyx1QkFBdUIsQ0FBQyxXQUFtQjtRQUMvQyxNQUFNLElBQUksQ0FBQyxHQUFHLENBQUMsdUJBQXVCLENBQUM7WUFDckMscUJBQXFCLEVBQUUsV0FBVztTQUNuQyxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7SUFDZixDQUFDO0NBQ0Y7QUFsT0Qsb0VBa09DO0FBRUQ7O0dBRUc7QUFDSCxJQUFZLFFBZVg7QUFmRCxXQUFZLFFBQVE7SUFDbEI7O09BRUc7SUFDSCxxQ0FBRyxDQUFBO0lBRUg7O09BRUc7SUFDSCxxREFBVyxDQUFBO0lBRVg7O09BRUc7SUFDSCw2Q0FBTyxDQUFBO0FBQ1QsQ0FBQyxFQWZXLFFBQVEsd0JBQVIsUUFBUSxRQWVuQiIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHMgKi9cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby12YXItcmVxdWlyZXMgKi9cbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBFbnZpcm9ubWVudCwgVU5LTk9XTl9BQ0NPVU5ULCBVTktOT1dOX1JFR0lPTiB9IGZyb20gJ0Bhd3MtY2RrL2N4LWFwaSc7XG5pbXBvcnQgeyBDbG91ZEZvcm1hdGlvbiB9IGZyb20gJ2F3cy1zZGsnO1xuaW1wb3J0ICogYXMgY2RrX2Zyb21fY2ZuIGZyb20gJ2Nkay1mcm9tLWNmbic7XG5pbXBvcnQgKiBhcyBjaGFsayBmcm9tICdjaGFsayc7XG5pbXBvcnQgeyBjbGlJbml0IH0gZnJvbSAnLi4vLi4vbGliL2luaXQnO1xuaW1wb3J0IHsgcHJpbnQgfSBmcm9tICcuLi8uLi9saWIvbG9nZ2luZyc7XG5pbXBvcnQgeyBNb2RlLCBTZGtQcm92aWRlciB9IGZyb20gJy4uL2FwaS9hd3MtYXV0aCc7XG5pbXBvcnQgeyBDbG91ZEZvcm1hdGlvblN0YWNrIH0gZnJvbSAnLi4vYXBpL3V0aWwvY2xvdWRmb3JtYXRpb24nO1xuaW1wb3J0IHsgemlwRGlyZWN0b3J5IH0gZnJvbSAnLi4vdXRpbC9hcmNoaXZlJztcbmNvbnN0IGNhbWVsQ2FzZSA9IHJlcXVpcmUoJ2NhbWVsY2FzZScpO1xuY29uc3QgZGVjYW1lbGl6ZSA9IHJlcXVpcmUoJ2RlY2FtZWxpemUnKTtcbi8qKiBUaGUgbGlzdCBvZiBsYW5ndWFnZXMgc3VwcG9ydGVkIGJ5IHRoZSBidWlsdC1pbiBub2N0aWx1Y2VudCBiaW5hcnkuICovXG5leHBvcnQgY29uc3QgTUlHUkFURV9TVVBQT1JURURfTEFOR1VBR0VTOiByZWFkb25seSBzdHJpbmdbXSA9IGNka19mcm9tX2Nmbi5zdXBwb3J0ZWRfbGFuZ3VhZ2VzKCk7XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgQ0RLIGFwcCBmcm9tIGEgeWFtbCBvciBqc29uIHRlbXBsYXRlLlxuICpcbiAqIEBwYXJhbSBzdGFja05hbWUgVGhlIG5hbWUgdG8gYXNzaWduIHRvIHRoZSBzdGFjayBpbiB0aGUgZ2VuZXJhdGVkIGFwcFxuICogQHBhcmFtIHN0YWNrIFRoZSB5YW1sIG9yIGpzb24gdGVtcGxhdGUgZm9yIHRoZSBzdGFja1xuICogQHBhcmFtIGxhbmd1YWdlIFRoZSBsYW5ndWFnZSB0byBnZW5lcmF0ZSB0aGUgQ0RLIGFwcCBpblxuICogQHBhcmFtIG91dHB1dFBhdGggVGhlIHBhdGggYXQgd2hpY2ggdG8gZ2VuZXJhdGUgdGhlIENESyBhcHBcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlQ2RrQXBwKHN0YWNrTmFtZTogc3RyaW5nLCBzdGFjazogc3RyaW5nLCBsYW5ndWFnZTogc3RyaW5nLCBvdXRwdXRQYXRoPzogc3RyaW5nLCBjb21wcmVzcz86IGJvb2xlYW4pXG4gIDogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IHJlc29sdmVkT3V0cHV0UGF0aCA9IHBhdGguam9pbihvdXRwdXRQYXRoID8/IHByb2Nlc3MuY3dkKCksIHN0YWNrTmFtZSk7XG4gIGNvbnN0IGZvcm1hdHRlZFN0YWNrTmFtZSA9IGRlY2FtZWxpemUoc3RhY2tOYW1lKTtcblxuICB0cnkge1xuICAgIGZzLnJtU3luYyhyZXNvbHZlZE91dHB1dFBhdGgsIHsgcmVjdXJzaXZlOiB0cnVlLCBmb3JjZTogdHJ1ZSB9KTtcbiAgICBmcy5ta2RpclN5bmMocmVzb2x2ZWRPdXRwdXRQYXRoLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgICBjb25zdCBnZW5lcmF0ZU9ubHkgPSBjb21wcmVzcztcbiAgICBhd2FpdCBjbGlJbml0KHtcbiAgICAgIHR5cGU6ICdhcHAnLFxuICAgICAgbGFuZ3VhZ2UsXG4gICAgICBjYW5Vc2VOZXR3b3JrOiB0cnVlLFxuICAgICAgZ2VuZXJhdGVPbmx5LFxuICAgICAgd29ya0RpcjogcmVzb2x2ZWRPdXRwdXRQYXRoLFxuICAgICAgc3RhY2tOYW1lLFxuICAgICAgbWlncmF0ZTogdHJ1ZSxcbiAgICB9KTtcblxuICAgIGxldCBzdGFja0ZpbGVOYW1lOiBzdHJpbmc7XG4gICAgc3dpdGNoIChsYW5ndWFnZSkge1xuICAgICAgY2FzZSAndHlwZXNjcmlwdCc6XG4gICAgICAgIHN0YWNrRmlsZU5hbWUgPSBgJHtyZXNvbHZlZE91dHB1dFBhdGh9L2xpYi8ke2Zvcm1hdHRlZFN0YWNrTmFtZX0tc3RhY2sudHNgO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2phdmEnOlxuICAgICAgICBzdGFja0ZpbGVOYW1lID0gYCR7cmVzb2x2ZWRPdXRwdXRQYXRofS9zcmMvbWFpbi9qYXZhL2NvbS9teW9yZy8ke2NhbWVsQ2FzZShmb3JtYXR0ZWRTdGFja05hbWUsIHsgcGFzY2FsQ2FzZTogdHJ1ZSB9KX1TdGFjay5qYXZhYDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdweXRob24nOlxuICAgICAgICBzdGFja0ZpbGVOYW1lID0gYCR7cmVzb2x2ZWRPdXRwdXRQYXRofS8ke2Zvcm1hdHRlZFN0YWNrTmFtZS5yZXBsYWNlKC8tL2csICdfJyl9LyR7Zm9ybWF0dGVkU3RhY2tOYW1lLnJlcGxhY2UoLy0vZywgJ18nKX1fc3RhY2sucHlgO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NzaGFycCc6XG4gICAgICAgIHN0YWNrRmlsZU5hbWUgPSBgJHtyZXNvbHZlZE91dHB1dFBhdGh9L3NyYy8ke2NhbWVsQ2FzZShmb3JtYXR0ZWRTdGFja05hbWUsIHsgcGFzY2FsQ2FzZTogdHJ1ZSB9KX0vJHtjYW1lbENhc2UoZm9ybWF0dGVkU3RhY2tOYW1lLCB7IHBhc2NhbENhc2U6IHRydWUgfSl9U3RhY2suY3NgO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2dvJzpcbiAgICAgICAgc3RhY2tGaWxlTmFtZSA9IGAke3Jlc29sdmVkT3V0cHV0UGF0aH0vJHtmb3JtYXR0ZWRTdGFja05hbWV9LmdvYDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bGFuZ3VhZ2V9IGlzIG5vdCBzdXBwb3J0ZWQgYnkgQ0RLIE1pZ3JhdGUuIFBsZWFzZSBjaG9vc2UgZnJvbTogJHtNSUdSQVRFX1NVUFBPUlRFRF9MQU5HVUFHRVMuam9pbignLCAnKX1gKTtcbiAgICB9XG4gICAgZnMud3JpdGVGaWxlU3luYyhzdGFja0ZpbGVOYW1lLCBzdGFjayk7XG4gICAgaWYgKGNvbXByZXNzKSB7XG4gICAgICBhd2FpdCB6aXBEaXJlY3RvcnkocmVzb2x2ZWRPdXRwdXRQYXRoLCBgJHtyZXNvbHZlZE91dHB1dFBhdGh9LnppcGApO1xuICAgICAgZnMucm1TeW5jKHJlc29sdmVkT3V0cHV0UGF0aCwgeyByZWN1cnNpdmU6IHRydWUsIGZvcmNlOiB0cnVlIH0pO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBmcy5ybVN5bmMocmVzb2x2ZWRPdXRwdXRQYXRoLCB7IHJlY3Vyc2l2ZTogdHJ1ZSwgZm9yY2U6IHRydWUgfSk7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBDREsgc3RhY2sgZmlsZS5cbiAqIEBwYXJhbSB0ZW1wbGF0ZSBUaGUgdGVtcGxhdGUgdG8gdHJhbnNsYXRlIGludG8gYSBDREsgc3RhY2tcbiAqIEBwYXJhbSBzdGFja05hbWUgVGhlIG5hbWUgdG8gYXNzaWduIHRvIHRoZSBzdGFja1xuICogQHBhcmFtIGxhbmd1YWdlIFRoZSBsYW5ndWFnZSB0byBnZW5lcmF0ZSB0aGUgc3RhY2sgaW5cbiAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgQ0RLIHN0YWNrIGZpbGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlU3RhY2sodGVtcGxhdGU6IHN0cmluZywgc3RhY2tOYW1lOiBzdHJpbmcsIGxhbmd1YWdlOiBzdHJpbmcpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBmb3JtYXR0ZWRTdGFja05hbWUgPSBgJHtjYW1lbENhc2UoZGVjYW1lbGl6ZShzdGFja05hbWUpLCB7IHBhc2NhbENhc2U6IHRydWUgfSl9U3RhY2tgO1xuICAgIHJldHVybiBjZGtfZnJvbV9jZm4udHJhbnNtdXRlKHRlbXBsYXRlLCBsYW5ndWFnZSwgZm9ybWF0dGVkU3RhY2tOYW1lKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgc3RhY2sgZ2VuZXJhdGlvbiBmYWlsZWQgZHVlIHRvIGVycm9yICckeyhlIGFzIEVycm9yKS5tZXNzYWdlfSdgKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlYWRzIGFuZCByZXR1cm5zIGEgc3RhY2sgdGVtcGxhdGUgZnJvbSBhIGxvY2FsIHBhdGguXG4gKlxuICogQHBhcmFtIGlucHV0UGF0aCBUaGUgbG9jYXRpb24gb2YgdGhlIHRlbXBsYXRlXG4gKiBAcmV0dXJucyBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdGVtcGxhdGUgaWYgcHJlc2VudCwgb3RoZXJ3aXNlIHVuZGVmaW5lZFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVhZEZyb21QYXRoKGlucHV0UGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgbGV0IHJlYWRGaWxlOiBzdHJpbmc7XG4gIHRyeSB7XG4gICAgcmVhZEZpbGUgPSBmcy5yZWFkRmlsZVN5bmMoaW5wdXRQYXRoLCAndXRmOCcpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAnJHtpbnB1dFBhdGh9JyBpcyBub3QgYSB2YWxpZCBwYXRoLmApO1xuICB9XG4gIGlmIChyZWFkRmlsZSA9PSAnJykge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2xvdWRmb3JtYXRpb24gdGVtcGxhdGUgZmlsZXBhdGg6ICcke2lucHV0UGF0aH0nIGlzIGFuIGVtcHR5IGZpbGUuYCk7XG4gIH1cbiAgcmV0dXJuIHJlYWRGaWxlO1xufVxuXG4vKipcbiAqIFJlYWRzIGFuZCByZXR1cm5zIGEgc3RhY2sgdGVtcGxhdGUgZnJvbSBhIGRlcGxveWVkIENsb3VkRm9ybWF0aW9uIHN0YWNrLlxuICpcbiAqIEBwYXJhbSBzdGFja05hbWUgVGhlIG5hbWUgb2YgdGhlIHN0YWNrXG4gKiBAcGFyYW0gc2RrUHJvdmlkZXIgVGhlIHNkayBwcm92aWRlciBmb3IgbWFraW5nIENsb3VkRm9ybWF0aW9uIGNhbGxzXG4gKiBAcGFyYW0gZW52aXJvbm1lbnQgVGhlIGFjY291bnQgYW5kIHJlZ2lvbiB3aGVyZSB0aGUgc3RhY2sgaXMgZGVwbG95ZWRcbiAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0ZW1wbGF0ZSBpZiBwcmVzZW50LCBvdGhlcndpc2UgdW5kZWZpbmVkXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWFkRnJvbVN0YWNrKHN0YWNrTmFtZTogc3RyaW5nLCBzZGtQcm92aWRlcjogU2RrUHJvdmlkZXIsIGVudmlyb25tZW50OiBFbnZpcm9ubWVudCk6IFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPiB7XG4gIGNvbnN0IGNsb3VkRm9ybWF0aW9uID0gKGF3YWl0IHNka1Byb3ZpZGVyLmZvckVudmlyb25tZW50KGVudmlyb25tZW50LCBNb2RlLkZvclJlYWRpbmcpKS5zZGsuY2xvdWRGb3JtYXRpb24oKTtcblxuICBjb25zdCBzdGFjayA9IGF3YWl0IENsb3VkRm9ybWF0aW9uU3RhY2subG9va3VwKGNsb3VkRm9ybWF0aW9uLCBzdGFja05hbWUpO1xuICBpZiAoc3RhY2suc3RhY2tTdGF0dXMuaXNEZXBsb3lTdWNjZXNzIHx8IHN0YWNrLnN0YWNrU3RhdHVzLmlzUm9sbGJhY2tTdWNjZXNzKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGF3YWl0IHN0YWNrLnRlbXBsYXRlKCkpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihgU3RhY2sgJyR7c3RhY2tOYW1lfScgaW4gYWNjb3VudCAke2Vudmlyb25tZW50LmFjY291bnR9IGFuZCByZWdpb24gJHtlbnZpcm9ubWVudC5yZWdpb259IGhhcyBhIHN0YXR1cyBvZiAnJHtzdGFjay5zdGFja1N0YXR1cy5uYW1lfScgZHVlIHRvICcke3N0YWNrLnN0YWNrU3RhdHVzLnJlYXNvbn0nLiBUaGUgc3RhY2sgY2Fubm90IGJlIG1pZ3JhdGVkIHVudGlsIGl0IGlzIGluIGEgaGVhbHRoeSBzdGF0ZS5gKTtcbiAgfVxuICByZXR1cm47XG59XG5cbi8qKlxuICogVGFrZXMgaW4gYSBzdGFjayBuYW1lIGFuZCBhY2NvdW50IGFuZCByZWdpb24gYW5kIHJldHVybnMgYSBnZW5lcmF0ZWQgY2xvdWRmb3JtYXRpb24gdGVtcGxhdGUgdXNpbmcgdGhlIGNsb3VkZm9ybWF0aW9uXG4gKiB0ZW1wbGF0ZSBnZW5lcmF0b3IuXG4gKlxuICogQHBhcmFtIEdlbmVyYXRlVGVtcGxhdGVPcHRpb25zIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBzdGFjayBuYW1lLCBmaWx0ZXJzLCBzZGtQcm92aWRlciwgZW52aXJvbm1lbnQsIGFuZCBuZXdTY2FuIGZsYWdcbiAqIEByZXR1cm5zIGEgZ2VuZXJhdGVkIGNsb3VkZm9ybWF0aW9uIHRlbXBsYXRlXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZW5lcmF0ZVRlbXBsYXRlKFxuICBvcHRpb25zOiBHZW5lcmF0ZVRlbXBsYXRlT3B0aW9ucyxcbik6IFByb21pc2U8R2VuZXJhdGVUZW1wbGF0ZU91dHB1dD4ge1xuICBjb25zdCBjZm4gPSBuZXcgQ2ZuVGVtcGxhdGVHZW5lcmF0b3JQcm92aWRlcihhd2FpdCBidWlsZENmbkNsaWVudChvcHRpb25zLnNka1Byb3ZpZGVyLCBvcHRpb25zLmVudmlyb25tZW50KSk7XG5cbiAgY29uc3Qgc2NhbklkID0gYXdhaXQgZmluZExhc3RTdWNjZXNzZnVsU2NhbihjZm4sIG9wdGlvbnMpO1xuXG4gIC8vIGlmIGEgY3VzdG9tZXIgYWNjaWRlbnRhbGx5IGN0cmwtYydzIG91dCBvZiB0aGUgY29tbWFuZCBhbmQgcnVucyBpdCBhZ2FpbiwgdGhpcyB3aWxsIGNvbnRpbnVlIHRoZSBwcm9ncmVzcyBiYXIgd2hlcmUgaXQgbGVmdCBvZmZcbiAgY29uc3QgY3VyU2NhbiA9IGF3YWl0IGNmbi5kZXNjcmliZVJlc291cmNlU2NhbihzY2FuSWQpO1xuICBpZiAoKGN1clNjYW4uU3RhdHVzID09IFNjYW5TdGF0dXMuSU5fUFJPR1JFU1MpKSB7XG4gICAgcHJpbnQoJ1Jlc291cmNlIHNjYW4gaW4gcHJvZ3Jlc3MuIFBsZWFzZSB3YWl0LCB0aGlzIGNhbiB0YWtlIDEwIG1pbnV0ZXMgb3IgbG9uZ2VyLicpO1xuICAgIGF3YWl0IHNjYW5Qcm9ncmVzc0JhcihzY2FuSWQsIGNmbik7XG4gIH1cblxuICBkaXNwbGF5VGltZURpZmYobmV3IERhdGUoKSwgbmV3IERhdGUoY3VyU2Nhbi5TdGFydFRpbWUhKSk7XG5cbiAgbGV0IHJlc291cmNlczogQ2xvdWRGb3JtYXRpb24uU2Nhbm5lZFJlc291cmNlcyA9IGF3YWl0IGNmbi5saXN0UmVzb3VyY2VTY2FuUmVzb3VyY2VzKHNjYW5JZCEsIG9wdGlvbnMuZmlsdGVycyk7XG5cbiAgcHJpbnQoJ2ZpbmRpbmcgcmVsYXRlZCByZXNvdXJjZXMuJyk7XG4gIGxldCByZWxhdGVkUmVzb3VyY2VzID0gYXdhaXQgY2ZuLmdldFJlc291cmNlU2NhblJlbGF0ZWRSZXNvdXJjZXMoc2NhbklkISwgcmVzb3VyY2VzKTtcblxuICBwcmludChgRm91bmQgJHtyZWxhdGVkUmVzb3VyY2VzLmxlbmd0aH0gcmVzb3VyY2VzLmApO1xuXG4gIHByaW50KCdHZW5lcmF0aW5nIENGTiB0ZW1wbGF0ZSBmcm9tIHNjYW5uZWQgcmVzb3VyY2VzLicpO1xuICBjb25zdCB0ZW1wbGF0ZUFybiA9IChhd2FpdCBjZm4uY3JlYXRlR2VuZXJhdGVkVGVtcGxhdGUob3B0aW9ucy5zdGFja05hbWUsIHJlbGF0ZWRSZXNvdXJjZXMpKS5HZW5lcmF0ZWRUZW1wbGF0ZUlkITtcblxuICBsZXQgZ2VuZXJhdGVkVGVtcGxhdGUgPSBhd2FpdCBjZm4uZGVzY3JpYmVHZW5lcmF0ZWRUZW1wbGF0ZSh0ZW1wbGF0ZUFybik7XG5cbiAgcHJpbnQoJ1BsZWFzZSB3YWl0LCB0ZW1wbGF0ZSBjcmVhdGlvbiBpbiBwcm9ncmVzcy4gVGhpcyBtYXkgdGFrZSBhIGNvdXBsZSBtaW51dGVzLicpO1xuICB3aGlsZSAoZ2VuZXJhdGVkVGVtcGxhdGUuU3RhdHVzICE9PSBTY2FuU3RhdHVzLkNPTVBMRVRFICYmIGdlbmVyYXRlZFRlbXBsYXRlLlN0YXR1cyAhPT0gU2NhblN0YXR1cy5GQUlMRUQpIHtcbiAgICBhd2FpdCBwcmludERvdHMoYFske2dlbmVyYXRlZFRlbXBsYXRlLlN0YXR1c31dIFRlbXBsYXRlIENyZWF0aW9uIGluIFByb2dyZXNzYCwgNDAwKTtcbiAgICBnZW5lcmF0ZWRUZW1wbGF0ZSA9IGF3YWl0IGNmbi5kZXNjcmliZUdlbmVyYXRlZFRlbXBsYXRlKHRlbXBsYXRlQXJuKTtcbiAgfVxuICBwcmludCgnJyk7XG4gIHByaW50KCdUZW1wbGF0ZSBzdWNjZXNzZnVsbHkgZ2VuZXJhdGVkIScpO1xuICByZXR1cm4gYnVpbGRHZW5lcnRlZFRlbXBsYXRlT3V0cHV0KGdlbmVyYXRlZFRlbXBsYXRlLCAoYXdhaXQgY2ZuLmdldEdlbmVyYXRlZFRlbXBsYXRlKHRlbXBsYXRlQXJuKSkuVGVtcGxhdGVCb2R5ISwgdGVtcGxhdGVBcm4pO1xufVxuXG5hc3luYyBmdW5jdGlvbiBmaW5kTGFzdFN1Y2Nlc3NmdWxTY2FuKGNmbjogQ2ZuVGVtcGxhdGVHZW5lcmF0b3JQcm92aWRlciwgb3B0aW9uczogR2VuZXJhdGVUZW1wbGF0ZU9wdGlvbnMpOiBQcm9taXNlPHN0cmluZz4ge1xuICBsZXQgcmVzb3VyY2VTY2FuU3VtbWFyaWVzOiBDbG91ZEZvcm1hdGlvbi5SZXNvdXJjZVNjYW5TdW1tYXJpZXMgfCB1bmRlZmluZWQgPSBbXTtcbiAgY29uc3QgY2xpZW50UmVxdWVzdFRva2VuID0gYGNkay1taWdyYXRlLSR7b3B0aW9ucy5lbnZpcm9ubWVudC5hY2NvdW50fS0ke29wdGlvbnMuZW52aXJvbm1lbnQucmVnaW9ufWA7XG4gIGlmIChvcHRpb25zLmZyb21TY2FuID09PSBGcm9tU2Nhbi5ORVcpIHtcbiAgICBwcmludChgU3RhcnRpbmcgbmV3IHNjYW4gZm9yIGFjY291bnQgJHtvcHRpb25zLmVudmlyb25tZW50LmFjY291bnR9IGluIHJlZ2lvbiAke29wdGlvbnMuZW52aXJvbm1lbnQucmVnaW9ufWApO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBjZm4uc3RhcnRSZXNvdXJjZVNjYW4oY2xpZW50UmVxdWVzdFRva2VuKTtcbiAgICAgIHJlc291cmNlU2NhblN1bW1hcmllcyA9IChhd2FpdCBjZm4ubGlzdFJlc291cmNlU2NhbnMoKSkuUmVzb3VyY2VTY2FuU3VtbWFyaWVzO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGNvbnRpbnVpbmcgaGVyZSBiZWNhdXNlIGlmIHRoZSBzY2FuIGZhaWxzIG9uIGEgbmV3LXNjYW4gaXQgaXMgdmVyeSBsaWtlbHkgYmVjYXVzZSB0aGVyZSBpcyBlaXRoZXIgYWxyZWFkeSBhIHNjYW4gaW4gcHJvZ3Jlc3NcbiAgICAgIC8vIG9yIHRoZSBjdXN0b21lciBoaXQgYSByYXRlIGxpbWl0LiBJbiBlaXRoZXIgY2FzZSB3ZSB3YW50IHRvIGNvbnRpbnVlIHdpdGggdGhlIG1vc3QgcmVjZW50IHNjYW4uXG4gICAgICAvLyBJZiB0aGlzIGhhcHBlbnMgdG8gZmFpbCBmb3IgYSBjcmVkZW50aWFsIGVycm9yIHRoZW4gdGhhdCB3aWxsIGJlIGNhdWdodCBpbW1lZGlhdGVseSBhZnRlciBhbnl3YXkuXG4gICAgICBwcmludChgU2NhbiBmYWlsZWQgdG8gc3RhcnQgZHVlIHRvIGVycm9yICckeyhlIGFzIEVycm9yKS5tZXNzYWdlfScsIGRlZmF1bHRpbmcgdG8gbGF0ZXN0IHNjYW4uYCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlc291cmNlU2NhblN1bW1hcmllcyA9IChhd2FpdCBjZm4ubGlzdFJlc291cmNlU2NhbnMoKSkuUmVzb3VyY2VTY2FuU3VtbWFyaWVzO1xuICAgIGF3YWl0IGNmbi5jaGVja0ZvclJlc291cmNlU2NhbihyZXNvdXJjZVNjYW5TdW1tYXJpZXMsIG9wdGlvbnMsIGNsaWVudFJlcXVlc3RUb2tlbik7XG4gIH1cbiAgLy8gZ2V0IHRoZSBsYXRlc3Qgc2Nhbiwgd2hpY2ggd2Uga25vdyB3aWxsIGV4aXN0XG4gIHJlc291cmNlU2NhblN1bW1hcmllcyA9IChhd2FpdCBjZm4ubGlzdFJlc291cmNlU2NhbnMoKSkuUmVzb3VyY2VTY2FuU3VtbWFyaWVzO1xuICBsZXQgc2NhbklkOiBzdHJpbmcgfCB1bmRlZmluZWQgPSByZXNvdXJjZVNjYW5TdW1tYXJpZXMhWzBdLlJlc291cmNlU2NhbklkO1xuXG4gIC8vIGZpbmQgdGhlIG1vc3QgcmVjZW50IHNjYW4gdGhhdCBpc24ndCBpbiBhIGZhaWxlZCBzdGF0ZSBpbiBjYXNlIHdlIGRpZG4ndCBzdGFydCBhIG5ldyBvbmVcbiAgZm9yIChjb25zdCBzdW1tYXJ5IG9mIHJlc291cmNlU2NhblN1bW1hcmllcyEpIHtcbiAgICBpZiAoc3VtbWFyeS5TdGF0dXMgIT09IFNjYW5TdGF0dXMuRkFJTEVEKSB7XG4gICAgICBzY2FuSWQgPSBzdW1tYXJ5LlJlc291cmNlU2NhbklkITtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzY2FuSWQhO1xufVxuXG4vKipcbiAqIFRha2VzIGEgc3RyaW5nIG9mIGZpbHRlcnMgaW4gdGhlIGZvcm1hdCBvZiBrZXkxPXZhbHVlMSxrZXkyPXZhbHVlMiBhbmQgcmV0dXJucyBhIG1hcCBvZiB0aGUgZmlsdGVycy5cbiAqXG4gKiBAcGFyYW0gZmlsdGVycyBhIHN0cmluZyBvZiBmaWx0ZXJzIGluIHRoZSBmb3JtYXQgb2Yga2V5MT12YWx1ZTEsa2V5Mj12YWx1ZTJcbiAqIEByZXR1cm5zIGEgbWFwIG9mIHRoZSBmaWx0ZXJzXG4gKi9cbmZ1bmN0aW9uIHBhcnNlRmlsdGVycyhmaWx0ZXJzOiBzdHJpbmcpOiB7W2tleSBpbiBGaWx0ZXJUeXBlXTogc3RyaW5nIHwgdW5kZWZpbmVkIH0ge1xuICBpZiAoIWZpbHRlcnMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ3Jlc291cmNlLWlkZW50aWZpZXInOiB1bmRlZmluZWQsXG4gICAgICAncmVzb3VyY2UtdHlwZS1wcmVmaXgnOiB1bmRlZmluZWQsXG4gICAgICAndGFnLWtleSc6IHVuZGVmaW5lZCxcbiAgICAgICd0YWctdmFsdWUnOiB1bmRlZmluZWQsXG4gICAgfTtcbiAgfTtcblxuICBjb25zdCBmaWx0ZXJTaG9ydGhhbmRzOiB7IFtrZXk6IHN0cmluZ106IEZpbHRlclR5cGUgfSA9IHtcbiAgICAnaWRlbnRpZmllcic6IEZpbHRlclR5cGUuUkVTT1VSQ0VfSURFTlRJRklFUixcbiAgICAnaWQnOiBGaWx0ZXJUeXBlLlJFU09VUkNFX0lERU5USUZJRVIsXG4gICAgJ3R5cGUnOiBGaWx0ZXJUeXBlLlJFU09VUkNFX1RZUEVfUFJFRklYLFxuICAgICd0eXBlLXByZWZpeCc6IEZpbHRlclR5cGUuUkVTT1VSQ0VfVFlQRV9QUkVGSVgsXG4gIH07XG5cbiAgY29uc3QgZmlsdGVyTGlzdCA9IGZpbHRlcnMuc3BsaXQoJywnKTtcblxuICBsZXQgZmlsdGVyTWFwOiB7IFtrZXkgaW4gRmlsdGVyVHlwZV06IHN0cmluZyB8IHVuZGVmaW5lZH0gPSB7XG4gICAgW0ZpbHRlclR5cGUuUkVTT1VSQ0VfSURFTlRJRklFUl06IHVuZGVmaW5lZCxcbiAgICBbRmlsdGVyVHlwZS5SRVNPVVJDRV9UWVBFX1BSRUZJWF06IHVuZGVmaW5lZCxcbiAgICBbRmlsdGVyVHlwZS5UQUdfS0VZXTogdW5kZWZpbmVkLFxuICAgIFtGaWx0ZXJUeXBlLlRBR19WQUxVRV06IHVuZGVmaW5lZCxcbiAgfTtcblxuICBmb3IgKGNvbnN0IGZpbCBvZiBmaWx0ZXJMaXN0KSB7XG4gICAgY29uc3QgZmlsdGVyID0gZmlsLnNwbGl0KCc9Jyk7XG4gICAgbGV0IGZpbHRlcktleSA9IGZpbHRlclswXTtcbiAgICBjb25zdCBmaWx0ZXJWYWx1ZSA9IGZpbHRlclsxXTtcbiAgICAvLyBpZiB0aGUga2V5IGlzIGEgc2hvcnRoYW5kLCByZXBsYWNlIGl0IHdpdGggdGhlIGZ1bGwgbmFtZVxuICAgIGlmIChmaWx0ZXJLZXkgaW4gZmlsdGVyU2hvcnRoYW5kcykge1xuICAgICAgZmlsdGVyS2V5ID0gZmlsdGVyU2hvcnRoYW5kc1tmaWx0ZXJLZXldO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LnZhbHVlcyhGaWx0ZXJUeXBlKS5pbmNsdWRlcyhmaWx0ZXJLZXkgYXMgYW55KSkge1xuICAgICAgZmlsdGVyTWFwW2ZpbHRlcktleSBhcyBrZXlvZiB0eXBlb2YgZmlsdGVyTWFwXSA9IGZpbHRlclZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZmlsdGVyOiAke2ZpbHRlcktleX1gKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZpbHRlck1hcDtcbn1cblxuLyoqXG4gKiBUYWtlcyBhIGxpc3Qgb2YgYW55IHR5cGUgYW5kIGJyZWFrcyBpdCB1cCBpbnRvIGNodW5rcyBvZiBhIHNwZWNpZmllZCBzaXplLlxuICpcbiAqIEBwYXJhbSBsaXN0IFRoZSBsaXN0IHRvIGJyZWFrIHVwXG4gKiBAcGFyYW0gY2h1bmtTaXplIFRoZSBzaXplIG9mIGVhY2ggY2h1bmtcbiAqIEByZXR1cm5zIEEgbGlzdCBvZiBsaXN0cyBvZiB0aGUgc3BlY2lmaWVkIHNpemVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNodW5rcyhsaXN0OiBhbnlbXSwgY2h1bmtTaXplOiBudW1iZXIpOiBhbnlbXVtdIHtcbiAgY29uc3QgY2h1bmtlZExpc3Q6IGFueVtdW10gPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSBjaHVua1NpemUpIHtcbiAgICBjaHVua2VkTGlzdC5wdXNoKGxpc3Quc2xpY2UoaSwgaSArIGNodW5rU2l6ZSkpO1xuICB9XG4gIHJldHVybiBjaHVua2VkTGlzdDtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBhY2NvdW50IGFuZCByZWdpb24gZm9yIG1ha2luZyBDbG91ZEZvcm1hdGlvbiBjYWxscy5cbiAqIEBwYXJhbSBhY2NvdW50IFRoZSBhY2NvdW50IHRvIHVzZVxuICogQHBhcmFtIHJlZ2lvbiBUaGUgcmVnaW9uIHRvIHVzZVxuICogQHJldHVybnMgVGhlIGVudmlyb25tZW50IG9iamVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0RW52aXJvbm1lbnQoYWNjb3VudD86IHN0cmluZywgcmVnaW9uPzogc3RyaW5nKTogRW52aXJvbm1lbnQge1xuICByZXR1cm4geyBhY2NvdW50OiBhY2NvdW50ID8/IFVOS05PV05fQUNDT1VOVCwgcmVnaW9uOiByZWdpb24gPz8gVU5LTk9XTl9SRUdJT04sIG5hbWU6ICdjZGstbWlncmF0ZS1lbnYnIH07XG59XG5cbi8qKlxuICogRW51bSBmb3IgdGhlIHNvdXJjZSBvcHRpb25zIGZvciB0aGUgdGVtcGxhdGVcbiAqL1xuZXhwb3J0IGVudW0gVGVtcGxhdGVTb3VyY2VPcHRpb25zIHtcbiAgUEFUSCA9ICdwYXRoJyxcbiAgU1RBQ0sgPSAnc3RhY2snLFxuICBTQ0FOID0gJ3NjYW4nLFxufVxuXG4vKipcbiAqIEFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHNvdXJjZSBvZiBhIHRlbXBsYXRlLlxuICovXG50eXBlIFRlbXBsYXRlU291cmNlID1cbiAgfCB7IHNvdXJjZTogVGVtcGxhdGVTb3VyY2VPcHRpb25zLlNDQU4gfVxuICB8IHsgc291cmNlOiBUZW1wbGF0ZVNvdXJjZU9wdGlvbnMuUEFUSCwgdGVtcGxhdGVQYXRoOiBzdHJpbmcgfVxuICB8IHsgc291cmNlOiBUZW1wbGF0ZVNvdXJjZU9wdGlvbnMuU1RBQ0ssIHN0YWNrTmFtZTogc3RyaW5nIH1cbiAgO1xuXG4vKipcbiAqIEVudW0gZm9yIHRoZSBzdGF0dXMgb2YgYSByZXNvdXJjZSBzY2FuXG4gKi9cbmV4cG9ydCBlbnVtIFNjYW5TdGF0dXMge1xuICBJTl9QUk9HUkVTUyA9ICdJTl9QUk9HUkVTUycsXG4gIENPTVBMRVRFID0gJ0NPTVBMRVRFJyxcbiAgRkFJTEVEID0gJ0ZBSUxFRCcsXG59XG5cbmV4cG9ydCBlbnVtIEZpbHRlclR5cGUge1xuICBSRVNPVVJDRV9JREVOVElGSUVSID0gJ3Jlc291cmNlLWlkZW50aWZpZXInLFxuICBSRVNPVVJDRV9UWVBFX1BSRUZJWCA9ICdyZXNvdXJjZS10eXBlLXByZWZpeCcsXG4gIFRBR19LRVkgPSAndGFnLWtleScsXG4gIFRBR19WQUxVRSA9ICd0YWctdmFsdWUnLFxufVxuXG4vKipcbiAqIFZhbGlkYXRlcyB0aGF0IGV4YWN0bHkgb25lIHNvdXJjZSBvcHRpb24gaGFzIGJlZW4gcHJvdmlkZWQuXG4gKiBAcGFyYW0gZnJvbVBhdGggVGhlIGNvbnRlbnQgb2YgdGhlIGZsYWcgYC0tZnJvbS1wYXRoYFxuICogQHBhcmFtIGZyb21TdGFjayB0aGUgY29udGVudCBvZiB0aGUgZmxhZyBgLS1mcm9tLXN0YWNrYFxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VTb3VyY2VPcHRpb25zKGZyb21QYXRoPzogc3RyaW5nLCBmcm9tU3RhY2s/OiBib29sZWFuLCBzdGFja05hbWU/OiBzdHJpbmcpOiBUZW1wbGF0ZVNvdXJjZSB7XG4gIGlmIChmcm9tUGF0aCAmJiBmcm9tU3RhY2spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgb25lIG9mIGAtLWZyb20tcGF0aGAgb3IgYC0tZnJvbS1zdGFja2AgbWF5IGJlIHByb3ZpZGVkLicpO1xuICB9XG4gIGlmICghc3RhY2tOYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgLS1zdGFjay1uYW1lYCBpcyBhIHJlcXVpcmVkIGZpZWxkLicpO1xuICB9XG4gIGlmICghZnJvbVBhdGggJiYgIWZyb21TdGFjaykge1xuICAgIHJldHVybiB7IHNvdXJjZTogVGVtcGxhdGVTb3VyY2VPcHRpb25zLlNDQU4gfTtcbiAgfVxuICBpZiAoZnJvbVBhdGgpIHtcbiAgICByZXR1cm4geyBzb3VyY2U6IFRlbXBsYXRlU291cmNlT3B0aW9ucy5QQVRILCB0ZW1wbGF0ZVBhdGg6IGZyb21QYXRoIH07XG4gIH1cbiAgcmV0dXJuIHsgc291cmNlOiBUZW1wbGF0ZVNvdXJjZU9wdGlvbnMuU1RBQ0ssIHN0YWNrTmFtZTogc3RhY2tOYW1lISB9O1xufVxuXG4vKipcbiAqIFRha2VzIGEgc2V0IG9mIHJlc291cmNlcyBhbmQgcmVtb3ZlcyBhbnkgd2l0aCB0aGUgbWFuYWdlZGJ5c3RhY2sgZmxhZyBzZXQgdG8gdHJ1ZS5cbiAqXG4gKiBAcGFyYW0gcmVzb3VyY2VMaXN0IHRoZSBsaXN0IG9mIHJlc291cmNlcyBwcm92aWRlZCBieSB0aGUgbGlzdCBzY2FubmVkIHJlc291cmNlcyBjYWxsc1xuICogQHJldHVybnMgYSBsaXN0IG9mIHJlc291cmNlcyBub3QgbWFuYWdlZCBieSBjZm4gc3RhY2tzXG4gKi9cbmZ1bmN0aW9uIGV4Y2x1ZGVNYW5hZ2VkKHJlc291cmNlTGlzdDogQ2xvdWRGb3JtYXRpb24uU2Nhbm5lZFJlc291cmNlcyk6IENsb3VkRm9ybWF0aW9uLlNjYW5uZWRSZXNvdXJjZUlkZW50aWZpZXJzIHtcbiAgcmV0dXJuIHJlc291cmNlTGlzdC5maWx0ZXIoKHIpID0+ICFyLk1hbmFnZWRCeVN0YWNrKS5tYXAoKHIpID0+ICh7XG4gICAgUmVzb3VyY2VUeXBlOiByLlJlc291cmNlVHlwZSEsXG4gICAgUmVzb3VyY2VJZGVudGlmaWVyOiByLlJlc291cmNlSWRlbnRpZmllciEsXG4gIH0pKTtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIGEgbGlzdCBvZiByZXNvdXJjZXMgaW50byBhIGxpc3Qgb2YgcmVzb3VyY2UgaWRlbnRpZmllcnMgYnkgcmVtb3ZpbmcgdGhlIE1hbmFnZWRCeVN0YWNrIGZsYWcuXG4gKiBTZXR0aW5nIHRoZSB2YWx1ZSBvZiB0aGUgZmllbGQgdG8gdW5kZWZpbmVkIGVmZmVjdGl2ZWx5IHJlbW92ZXMgaXQgZnJvbSB0aGUgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSByZXNvdXJjZUxpc3QgdGhlIGxpc3Qgb2YgcmVzb3VyY2VzIHByb3ZpZGVkIGJ5IHRoZSBsaXN0IHNjYW5uZWQgcmVzb3VyY2VzIGNhbGxzXG4gKiBAcmV0dXJucyBhIGxpc3Qgb2YgU2Nhbm5lZFJlc291cmNlSWRlbnRpZmllcnNcbiAqL1xuZnVuY3Rpb24gcmVzb3VyY2VJZGVudGlmaWVycyhyZXNvdXJjZUxpc3Q6IENsb3VkRm9ybWF0aW9uLlNjYW5uZWRSZXNvdXJjZXMpOiBDbG91ZEZvcm1hdGlvbi5TY2FubmVkUmVzb3VyY2VJZGVudGlmaWVycyB7XG4gIGNvbnN0IGlkZW50aWZpZXJzOiBDbG91ZEZvcm1hdGlvbi5TY2FubmVkUmVzb3VyY2VJZGVudGlmaWVycyA9IFtdO1xuICByZXNvdXJjZUxpc3QuZm9yRWFjaCgocikgPT4ge1xuICAgIGNvbnN0IGlkZW50aWZpZXI6IENsb3VkRm9ybWF0aW9uLlNjYW5uZWRSZXNvdXJjZUlkZW50aWZpZXIgPSB7XG4gICAgICBSZXNvdXJjZVR5cGU6IHIuUmVzb3VyY2VUeXBlISxcbiAgICAgIFJlc291cmNlSWRlbnRpZmllcjogci5SZXNvdXJjZUlkZW50aWZpZXIhLFxuICAgIH07XG4gICAgaWRlbnRpZmllcnMucHVzaChpZGVudGlmaWVyKTtcbiAgfSk7XG4gIHJldHVybiBpZGVudGlmaWVycztcbn1cblxuLyoqXG4gKiBUYWtlcyBhIHNjYW4gaWQgYW5kIG1haW50YWlucyBhIHByb2dyZXNzIGJhciB0byBkaXNwbGF5IHRoZSBwcm9ncmVzcyBvZiBhIHNjYW4gdG8gdGhlIHVzZXIuXG4gKlxuICogQHBhcmFtIHNjYW5JZCBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHNjYW4gaWRcbiAqIEBwYXJhbSBjbG91ZEZvcm1hdGlvbiBUaGUgQ2xvdWRGb3JtYXRpb24gc2RrIGNsaWVudCB0byB1c2VcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNjYW5Qcm9ncmVzc0JhcihzY2FuSWQ6IHN0cmluZywgY2ZuOiBDZm5UZW1wbGF0ZUdlbmVyYXRvclByb3ZpZGVyKSB7XG4gIGxldCBjdXJQcm9ncmVzcyA9IDAuNTtcbiAgLy8gd2Uga25vdyBpdCdzIGluIHByb2dyZXNzIGluaXRpYWxseSBzaW5jZSB3ZSB3b3VsZG4ndCBoYXZlIGdvdHRlbiBoZXJlIGlmIGl0IHdhc24ndFxuICBsZXQgY3VyU2NhbjogQ2xvdWRGb3JtYXRpb24uRGVzY3JpYmVSZXNvdXJjZVNjYW5PdXRwdXQgPSB7IFN0YXR1czogU2NhblN0YXR1cy5JTl9QUk9HUkVTUyB9O1xuICB3aGlsZSAoY3VyU2Nhbi5TdGF0dXMgPT0gU2NhblN0YXR1cy5JTl9QUk9HUkVTUykge1xuICAgIGN1clNjYW4gPSBhd2FpdCBjZm4uZGVzY3JpYmVSZXNvdXJjZVNjYW4oc2NhbklkKTtcbiAgICBjdXJQcm9ncmVzcyA9IGN1clNjYW4uUGVyY2VudGFnZUNvbXBsZXRlZCA/PyBjdXJQcm9ncmVzcztcbiAgICBwcmludEJhcigzMCwgY3VyUHJvZ3Jlc3MpO1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAyMDAwKSk7XG4gIH1cbiAgcHJpbnQoJycpO1xuICBwcmludCgn4pyFIFNjYW4gQ29tcGxldGUhJyk7XG59XG5cbi8qKlxuICogUHJpbnRzIGEgcHJvZ3Jlc3MgYmFyIHRvIHRoZSBjb25zb2xlLiBUbyBiZSB1c2VkIGluIGEgd2hpbGUgbG9vcCB0byBzaG93IHByb2dyZXNzIG9mIGEgbG9uZyBydW5uaW5nIHRhc2suXG4gKiBUaGUgcHJvZ3Jlc3MgYmFyIGRlbGV0ZXMgdGhlIGN1cnJlbnQgbGluZSBvbiB0aGUgY29uc29sZSBhbmQgcmV3cml0ZXMgaXQgd2l0aCB0aGUgcHJvZ3Jlc3MgYW1vdW50LlxuICpcbiAqIEBwYXJhbSB3aWR0aCBUaGUgd2lkdGggb2YgdGhlIHByb2dyZXNzIGJhclxuICogQHBhcmFtIHByb2dyZXNzIFRoZSBjdXJyZW50IHByb2dyZXNzIHRvIGRpc3BsYXkgYXMgYSBwZXJjZW50YWdlIG9mIDEwMFxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJpbnRCYXIod2lkdGg6IG51bWJlciwgcHJvZ3Jlc3M6IG51bWJlcikge1xuICBpZiAoIXByb2Nlc3MuZW52Lk1JR1JBVEVfSU5URUdfVEVTVCkge1xuICAgIGNvbnN0IEZVTExfQkxPQ0sgPSAn4paIJztcbiAgICBjb25zdCBQQVJUSUFMX0JMT0NLID0gWycnLCAn4paPJywgJ+KWjicsICfilo0nLCAn4paMJywgJ+KWiycsICfiloonLCAn4paJJ107XG4gICAgY29uc3QgZnJhY3Rpb24gPSBNYXRoLm1pbihwcm9ncmVzcyAvIDEwMCwgMSk7XG4gICAgY29uc3QgaW5uZXJXaWR0aCA9IE1hdGgubWF4KDEsIHdpZHRoIC0gMik7XG4gICAgY29uc3QgY2hhcnMgPSBpbm5lcldpZHRoICogZnJhY3Rpb247XG4gICAgY29uc3QgcmVtYWluZGVyID0gY2hhcnMgLSBNYXRoLmZsb29yKGNoYXJzKTtcblxuICAgIGNvbnN0IGZ1bGxDaGFycyA9IEZVTExfQkxPQ0sucmVwZWF0KE1hdGguZmxvb3IoY2hhcnMpKTtcbiAgICBjb25zdCBwYXJ0aWFsQ2hhciA9IFBBUlRJQUxfQkxPQ0tbTWF0aC5mbG9vcihyZW1haW5kZXIgKiBQQVJUSUFMX0JMT0NLLmxlbmd0aCldO1xuICAgIGNvbnN0IGZpbGxlciA9ICfCtycucmVwZWF0KGlubmVyV2lkdGggLSBNYXRoLmZsb29yKGNoYXJzKSAtIChwYXJ0aWFsQ2hhciA/IDEgOiAwKSk7XG5cbiAgICBjb25zdCBjb2xvciA9IGNoYWxrLmdyZWVuO1xuXG4gICAgcmV3cml0ZUxpbmUoJ1snICsgY29sb3IoZnVsbENoYXJzICsgcGFydGlhbENoYXIpICsgZmlsbGVyICsgYF0gKCR7cHJvZ3Jlc3N9JSlgKTtcbiAgfVxufVxuXG4vKipcbiAqIFByaW50cyBhIG1lc3NhZ2UgdG8gdGhlIGNvbnNvbGUgd2l0aCBhIHNlcmllcyBwZXJpb2RzIGFwcGVuZGVkIHRvIGl0LiBUbyBiZSB1c2VkIGluIGEgd2hpbGUgbG9vcCB0byBzaG93IHByb2dyZXNzIG9mIGEgbG9uZyBydW5uaW5nIHRhc2suXG4gKiBUaGUgbWVzc2FnZSBkZWxldGVzIHRoZSBjdXJyZW50IGxpbmUgYW5kIHJld3JpdGVzIGl0IHNldmVyYWwgdGltZXMgdG8gZGlzcGxheSAxLTMgcGVyaW9kcyB0byBzaG93IHRoZSB1c2VyIHRoYXQgdGhlIHRhc2sgaXMgc3RpbGwgcnVubmluZy5cbiAqXG4gKiBAcGFyYW0gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBkaXNwbGF5XG4gKiBAcGFyYW0gdGltZW91dHg0IFRoZSBhbW91bnQgb2YgdGltZSB0byB3YWl0IGJlZm9yZSBwcmludGluZyB0aGUgbmV4dCBwZXJpb2RcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByaW50RG90cyhtZXNzYWdlOiBzdHJpbmcsIHRpbWVvdXR4NDogbnVtYmVyKSB7XG5cbiAgaWYgKCFwcm9jZXNzLmVudi5NSUdSQVRFX0lOVEVHX1RFU1QpIHtcbiAgICByZXdyaXRlTGluZShtZXNzYWdlICsgJyAuJyk7XG4gICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHRpbWVvdXR4NCkpO1xuXG4gICAgcmV3cml0ZUxpbmUobWVzc2FnZSArICcgLi4nKTtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgdGltZW91dHg0KSk7XG5cbiAgICByZXdyaXRlTGluZShtZXNzYWdlICsgJyAuLi4nKTtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgdGltZW91dHg0KSk7XG5cbiAgICByZXdyaXRlTGluZShtZXNzYWdlKTtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgdGltZW91dHg0KSk7XG4gIH1cblxufVxuXG4vKipcbiAqIFJld3JpdGVzIHRoZSBjdXJyZW50IGxpbmUgb24gdGhlIGNvbnNvbGUgYW5kIHdyaXRlcyBhIG5ldyBtZXNzYWdlIHRvIGl0LlxuICogVGhpcyBpcyBhIGhlbHBlciBmdW5jaXRvbiBmb3IgcHJpbnREb3RzIGFuZCBwcmludEJhci5cbiAqXG4gKiBAcGFyYW0gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBkaXNwbGF5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXdyaXRlTGluZShtZXNzYWdlOiBzdHJpbmcpIHtcbiAgcHJvY2Vzcy5zdGRvdXQuY2xlYXJMaW5lKDApO1xuICBwcm9jZXNzLnN0ZG91dC5jdXJzb3JUbygwKTtcbiAgcHJvY2Vzcy5zdGRvdXQud3JpdGUobWVzc2FnZSk7XG59XG5cbi8qKlxuICogUHJpbnRzIHRoZSB0aW1lIGRpZmZlcmVuY2UgYmV0d2VlbiB0d28gZGF0ZXMgaW4gZGF5cywgaG91cnMsIGFuZCBtaW51dGVzLlxuICpcbiAqIEBwYXJhbSB0aW1lMSBUaGUgZmlyc3QgZGF0ZSB0byBjb21wYXJlXG4gKiBAcGFyYW0gdGltZTIgVGhlIHNlY29uZCBkYXRlIHRvIGNvbXBhcmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpc3BsYXlUaW1lRGlmZih0aW1lMTogRGF0ZSwgdGltZTI6IERhdGUpOiB2b2lkIHtcbiAgY29uc3QgZGlmZiA9IE1hdGguYWJzKHRpbWUxLmdldFRpbWUoKSAtIHRpbWUyLmdldFRpbWUoKSk7XG5cbiAgY29uc3QgZGF5cyA9IE1hdGguZmxvb3IoZGlmZiAvICgxMDAwICogNjAgKiA2MCAqIDI0KSk7XG4gIGNvbnN0IGhvdXJzID0gTWF0aC5mbG9vcigoZGlmZiAlICgxMDAwICogNjAgKiA2MCAqIDI0KSkgLyAoMTAwMCAqIDYwICogNjApKTtcbiAgY29uc3QgbWludXRlcyA9IE1hdGguZmxvb3IoKGRpZmYgJSAoMTAwMCAqIDYwICogNjApKSAvICgxMDAwICogNjApKTtcblxuICBwcmludChgVXNpbmcgdGhlIGxhdGVzdCBzdWNjZXNzZnVsIHNjYW4gd2hpY2ggaXMgJHtkYXlzfSBkYXlzLCAke2hvdXJzfSBob3VycywgYW5kICR7bWludXRlc30gbWludXRlcyBvbGQuYCk7XG59XG5cbi8qKlxuICogV3JpdGVzIGEgbWlncmF0ZS5qc29uIGZpbGUgdG8gdGhlIG91dHB1dCBkaXJlY3RvcnkuXG4gKlxuICogQHBhcmFtIG91dHB1dFBhdGggVGhlIHBhdGggdG8gd3JpdGUgdGhlIG1pZ3JhdGUuanNvbiBmaWxlIHRvXG4gKiBAcGFyYW0gc3RhY2tOYW1lIFRoZSBuYW1lIG9mIHRoZSBzdGFja1xuICogQHBhcmFtIGdlbmVyYXRlZE91dHB1dCBUaGUgb3V0cHV0IG9mIHRoZSB0ZW1wbGF0ZSBnZW5lcmF0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdyaXRlTWlncmF0ZUpzb25GaWxlKG91dHB1dFBhdGg6IHN0cmluZyB8IHVuZGVmaW5lZCwgc3RhY2tOYW1lOiBzdHJpbmcsIG1pZ3JhdGVKc29uOiBNaWdyYXRlSnNvbkZvcm1hdCkge1xuICBjb25zdCBvdXRwdXRUb0pzb24gPSB7XG4gICAgJy8vJzogJ1RoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgYnkgY2RrIG1pZ3JhdGUuIEl0IHdpbGwgYmUgYXV0b21hdGljYWxseSBkZWxldGVkIGFmdGVyIHRoZSBmaXJzdCBzdWNjZXNzZnVsIGRlcGxveW1lbnQgb2YgdGhpcyBhcHAgdG8gdGhlIGVudmlyb25tZW50IG9mIHRoZSBvcmlnaW5hbCByZXNvdXJjZXMuJyxcbiAgICAnU291cmNlJzogbWlncmF0ZUpzb24uc291cmNlLFxuICAgICdSZXNvdXJjZXMnOiBtaWdyYXRlSnNvbi5yZXNvdXJjZXMsXG4gIH07XG4gIGZzLndyaXRlRmlsZVN5bmMoYCR7cGF0aC5qb2luKG91dHB1dFBhdGggPz8gcHJvY2Vzcy5jd2QoKSwgc3RhY2tOYW1lKX0vbWlncmF0ZS5qc29uYCwgSlNPTi5zdHJpbmdpZnkob3V0cHV0VG9Kc29uLCBudWxsLCAyKSk7XG59XG5cbi8qKlxuICogVGFrZXMgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBmcm9tLXNjYW4gZmxhZyBhbmQgcmV0dXJucyBhIEZyb21TY2FuIGVudW0gdmFsdWUuXG4gKlxuICogQHBhcmFtIHNjYW5UeXBlIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZnJvbS1zY2FuIGZsYWdcbiAqIEByZXR1cm5zIEEgRnJvbVNjYW4gZW51bSB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWlncmF0ZVNjYW5UeXBlKHNjYW5UeXBlOiBzdHJpbmcpIHtcbiAgc3dpdGNoIChzY2FuVHlwZSkge1xuICAgIGNhc2UgJ25ldyc6XG4gICAgICByZXR1cm4gRnJvbVNjYW4uTkVXO1xuICAgIGNhc2UgJ21vc3QtcmVjZW50JzpcbiAgICAgIHJldHVybiBGcm9tU2Nhbi5NT1NUX1JFQ0VOVDtcbiAgICBjYXNlICcnOlxuICAgICAgcmV0dXJuIEZyb21TY2FuLkRFRkFVTFQ7XG4gICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICByZXR1cm4gRnJvbVNjYW4uREVGQVVMVDtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHNjYW4gdHlwZTogJHtzY2FuVHlwZX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIFRha2VzIGEgZ2VuZXJhdGVkVGVtcGxhdGVPdXRwdXQgb2JqY3QgYW5kIHJldHVybnMgYSBib29sZWFuIHJlcHJlc2VudGluZyB3aGV0aGVyIHRoZXJlIGFyZSBhbnkgd2FybmluZ3Mgb24gYW55IHJlc2NvdXJjZXMuXG4gKlxuICogQHBhcmFtIGdlbmVyYXRlZFRlbXBsYXRlT3V0cHV0IEEgR2VuZXJhdGVUZW1wbGF0ZU91dHB1dCBvYmplY3RcbiAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgd2hldGhlciB0aGVyZSBhcmUgYW55IHdhcm5pbmdzIG9uIGFueSByZXNjb3VyY2VzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1RoZXJlQVdhcm5pbmcoZ2VuZXJhdGVkVGVtcGxhdGVPdXRwdXQ6IEdlbmVyYXRlVGVtcGxhdGVPdXRwdXQpIHtcbiAgaWYgKGdlbmVyYXRlZFRlbXBsYXRlT3V0cHV0LnJlc291cmNlcykge1xuICAgIGZvciAoY29uc3QgcmVzb3VyY2Ugb2YgZ2VuZXJhdGVkVGVtcGxhdGVPdXRwdXQucmVzb3VyY2VzKSB7XG4gICAgICBpZiAocmVzb3VyY2UuV2FybmluZ3MgJiYgcmVzb3VyY2UuV2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEJ1aWxkcyB0aGUgR2VuZXJhdGVUZW1wbGF0ZU91dHB1dCBvYmplY3QgZnJvbSB0aGUgRGVzY3JpYmVHZW5lcmF0ZWRUZW1wbGF0ZU91dHB1dCBhbmQgdGhlIHRlbXBsYXRlIGJvZHkuXG4gKlxuICogQHBhcmFtIGdlbmVyYXRlZFRlbXBsYXRlU3VtbWFyeSBUaGUgb3V0cHV0IG9mIHRoZSBkZXNjcmliZSBnZW5lcmF0ZWQgdGVtcGxhdGUgY2FsbFxuICogQHBhcmFtIHRlbXBsYXRlQm9keSBUaGUgYm9keSBvZiB0aGUgZ2VuZXJhdGVkIHRlbXBsYXRlXG4gKiBAcmV0dXJucyBBIEdlbmVyYXRlVGVtcGxhdGVPdXRwdXQgb2JqZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZEdlbmVydGVkVGVtcGxhdGVPdXRwdXQoZ2VuZXJhdGVkVGVtcGxhdGVTdW1tYXJ5OiBDbG91ZEZvcm1hdGlvbi5EZXNjcmliZUdlbmVyYXRlZFRlbXBsYXRlT3V0cHV0LFxuICB0ZW1wbGF0ZUJvZHk6IHN0cmluZywgc291cmNlOiBzdHJpbmcpOiBHZW5lcmF0ZVRlbXBsYXRlT3V0cHV0IHtcbiAgY29uc3QgcmVzb3VyY2VzOiBDbG91ZEZvcm1hdGlvbi5SZXNvdXJjZURldGFpbHMgfCB1bmRlZmluZWQgPSBnZW5lcmF0ZWRUZW1wbGF0ZVN1bW1hcnkuUmVzb3VyY2VzO1xuICBjb25zdCBtaWdyYXRlSnNvbjogTWlncmF0ZUpzb25Gb3JtYXQgPSB7XG4gICAgdGVtcGxhdGVCb2R5OiB0ZW1wbGF0ZUJvZHksXG4gICAgc291cmNlOiBzb3VyY2UsXG4gICAgcmVzb3VyY2VzOiBnZW5lcmF0ZWRUZW1wbGF0ZVN1bW1hcnkuUmVzb3VyY2VzIS5tYXAoKHIpID0+ICh7XG4gICAgICBSZXNvdXJjZVR5cGU6IHIuUmVzb3VyY2VUeXBlISxcbiAgICAgIExvZ2ljYWxSZXNvdXJjZUlkOiByLkxvZ2ljYWxSZXNvdXJjZUlkISxcbiAgICAgIFJlc291cmNlSWRlbnRpZmllcjogci5SZXNvdXJjZUlkZW50aWZpZXIhLFxuICAgIH0pKSxcbiAgfTtcbiAgY29uc3QgdGVtcGxhdGVJZCA9IGdlbmVyYXRlZFRlbXBsYXRlU3VtbWFyeS5HZW5lcmF0ZWRUZW1wbGF0ZUlkITtcbiAgcmV0dXJuIHtcbiAgICBtaWdyYXRlSnNvbjogbWlncmF0ZUpzb24sXG4gICAgcmVzb3VyY2VzOiByZXNvdXJjZXMsXG4gICAgdGVtcGxhdGVJZDogdGVtcGxhdGVJZCxcbiAgfTtcbn1cblxuLyoqXG4gKiBCdWlsZHMgYSBDbG91ZEZvcm1hdGlvbiBzZGsgY2xpZW50IGZvciBtYWtpbmcgcmVxdWVzdHMgd2l0aCB0aGUgQ0ZOIHRlbXBsYXRlIGdlbmVyYXRvci5cbiAqXG4gKiBAcGFyYW0gc2RrUHJvdmlkZXIgVGhlIHNkayBwcm92aWRlciBmb3IgbWFraW5nIENsb3VkRm9ybWF0aW9uIGNhbGxzXG4gKiBAcGFyYW0gZW52aXJvbm1lbnQgVGhlIGFjY291bnQgYW5kIHJlZ2lvbiB3aGVyZSB0aGUgc3RhY2sgaXMgZGVwbG95ZWRcbiAqIEByZXR1cm5zIEEgQ2xvdWRGb3JtYXRpb24gc2RrIGNsaWVudFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYnVpbGRDZm5DbGllbnQoc2RrUHJvdmlkZXI6IFNka1Byb3ZpZGVyLCBlbnZpcm9ubWVudDogRW52aXJvbm1lbnQpIHtcbiAgY29uc3QgY2xvdWRGb3JtYXRpb25DbGllbnQgPSAoYXdhaXQgc2RrUHJvdmlkZXIuZm9yRW52aXJvbm1lbnQoZW52aXJvbm1lbnQsIE1vZGUuRm9yUmVhZGluZykpLnNkay5jbG91ZEZvcm1hdGlvbigpO1xuXG4gIGNsb3VkRm9ybWF0aW9uQ2xpZW50LmNvbmZpZy5jdXN0b21Vc2VyQWdlbnQgPSAnY2RrLW1pZ3JhdGUnO1xuXG4gIHJldHVybiBjbG91ZEZvcm1hdGlvbkNsaWVudDtcbn1cblxuLyoqXG4gKiBBcHBlbmRzIGEgbGlzdCBvZiB3YXJuaW5ncyB0byBhIHJlYWRtZSBmaWxlLlxuICpcbiAqIEBwYXJhbSBmaWxlcGF0aCBUaGUgcGF0aCB0byB0aGUgcmVhZG1lIGZpbGVcbiAqIEBwYXJhbSByZXNvdXJjZXMgQSBsaXN0IG9mIHJlc291cmNlcyB0byBhcHBlbmQgd2FybmluZ3MgZm9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRXYXJuaW5nc1RvUmVhZG1lKGZpbGVwYXRoOiBzdHJpbmcsIHJlc291cmNlczogQ2xvdWRGb3JtYXRpb24uUmVzb3VyY2VEZXRhaWxzKSB7XG4gIGNvbnN0IHJlYWRtZSA9IGZzLnJlYWRGaWxlU3luYyhmaWxlcGF0aCwgJ3V0ZjgnKTtcbiAgY29uc3QgbGluZXMgPSByZWFkbWUuc3BsaXQoJ1xcbicpO1xuICBjb25zdCBpbmRleCA9IGxpbmVzLmZpbmRJbmRleCgobGluZSkgPT4gbGluZS50cmltKCkgPT09ICdFbmpveSEnKTtcbiAgbGV0IGxpbmVzVG9BZGQgPSBbJ1xcbiMjIFdhcm5pbmdzJ107XG4gIGxpbmVzVG9BZGQucHVzaCgnIyMjIFdyaXRlLW9ubHkgcHJvcGVydGllcycpO1xuICBsaW5lc1RvQWRkLnB1c2goXCJXcml0ZS1vbmx5IHByb3BlcnRpZXMgYXJlIHJlc291cmNlIHByb3BlcnR5IHZhbHVlcyB0aGF0IGNhbiBiZSB3cml0dGVuIHRvIGJ1dCBjYW4ndCBiZSByZWFkIGJ5IEFXUyBDbG91ZEZvcm1hdGlvbiBvciBDREsgTWlncmF0ZS4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSBbSWFDIGdlbmVyYXRvciBhbmQgd3JpdGUtb25seSBwcm9wZXJ0aWVzXShodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vQVdTQ2xvdWRGb3JtYXRpb24vbGF0ZXN0L1VzZXJHdWlkZS9nZW5lcmF0ZS1JYUMtd3JpdGUtb25seS1wcm9wZXJ0aWVzLmh0bWwpLlwiKTtcbiAgbGluZXNUb0FkZC5wdXNoKCdcXG4nKTtcbiAgbGluZXNUb0FkZC5wdXNoKCdXcml0ZS1vbmx5IHByb3BlcnRpZXMgZGlzY292ZXJlZCBkdXJpbmcgbWlncmF0aW9uIGFyZSBvcmdhbml6ZWQgaGVyZSBieSByZXNvdXJjZSBJRCBhbmQgY2F0ZWdvcml6ZWQgYnkgd3JpdGUtb25seSBwcm9wZXJ0eSB0eXBlLiBSZXNvbHZlIHdyaXRlLW9ubHkgcHJvcGVydGllcyBieSBwcm92aWRpbmcgcHJvcGVydHkgdmFsdWVzIGluIHlvdXIgQ0RLIGFwcC4gRm9yIGd1aWRhbmNlLCBzZWUgW1Jlc29sdmUgd3JpdGUtb25seSBwcm9wZXJ0aWVzXShodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vY2RrL3YyL2d1aWRlL21pZ3JhdGUuaHRtbCNtaWdyYXRlLXJlc291cmNlcy13cml0ZW9ubHkpLicpO1xuICBmb3IgKGNvbnN0IHJlc291cmNlIG9mIHJlc291cmNlcykge1xuICAgIGlmIChyZXNvdXJjZS5XYXJuaW5ncyAmJiByZXNvdXJjZS5XYXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICBsaW5lc1RvQWRkLnB1c2goYCMjIyAke3Jlc291cmNlLkxvZ2ljYWxSZXNvdXJjZUlkfWApO1xuICAgICAgZm9yIChjb25zdCB3YXJuaW5nIG9mIHJlc291cmNlLldhcm5pbmdzKSB7XG4gICAgICAgIGxpbmVzVG9BZGQucHVzaChgLSAqKiR7d2FybmluZy5UeXBlfSoqOiBgKTtcbiAgICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiB3YXJuaW5nLlByb3BlcnRpZXMhKSB7XG4gICAgICAgICAgbGluZXNUb0FkZC5wdXNoKGAgIC0gJHtwcm9wZXJ0eS5Qcm9wZXJ0eVBhdGh9OiAke3Byb3BlcnR5LkRlc2NyaXB0aW9ufWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGxpbmVzLnNwbGljZShpbmRleCwgMCwgLi4ubGluZXNUb0FkZCk7XG4gIGZzLndyaXRlRmlsZVN5bmMoZmlsZXBhdGgsIGxpbmVzLmpvaW4oJ1xcbicpKTtcbn1cblxuLyoqXG4gKiB0YWtlcyBhIGxpc3Qgb2YgcmVzb3VyY2VzIGFuZCByZXR1cm5zIGEgbGlzdCBvZiB1bmlxdWUgcmVzb3VyY2VzIGJhc2VkIG9uIHRoZSByZXNvdXJjZSB0eXBlIGFuZCBsb2dpY2FsIHJlc291cmNlIGlkLlxuICpcbiAqIEBwYXJhbSByZXNvdXJjZXMgQSBsaXN0IG9mIHJlc291cmNlcyB0byBkZWR1cGxpY2F0ZVxuICogQHJldHVybnMgQSBsaXN0IG9mIHVuaXF1ZSByZXNvdXJjZXNcbiAqL1xuZnVuY3Rpb24gZGVkdXBsaWNhdGVSZXNvdXJjZXMocmVzb3VyY2VzOiBDbG91ZEZvcm1hdGlvbi5SZXNvdXJjZURldGFpbHMpIHtcbiAgbGV0IHVuaXF1ZVJlc291cmNlczoge1trZXk6IHN0cmluZ106IENsb3VkRm9ybWF0aW9uLlJlc291cmNlRGV0YWlsfSA9IHt9O1xuXG4gIGZvciAoY29uc3QgcmVzb3VyY2Ugb2YgcmVzb3VyY2VzKSB7XG4gICAgY29uc3Qga2V5ID0gT2JqZWN0LmtleXMocmVzb3VyY2UuUmVzb3VyY2VJZGVudGlmaWVyISlbMF07XG5cbiAgICAvLyBDcmVhdGluZyBvdXIgdW5pcXVlIGlkZW50aWZpZXIgdXNpbmcgdGhlIHJlc291cmNlIHR5cGUsIHRoZSBrZXksIGFuZCB0aGUgdmFsdWUgb2YgdGhlIHJlc291cmNlIGlkZW50aWZpZXJcbiAgICAvLyBUaGUgcmVzb3VyY2UgaWRlbnRpZmllciBpcyBhIGNvbWJpbmF0aW9uIG9mIGEga2V5IHZhbHVlIHBhaXIgZGVmaW5lZCBieSBhIHJlc291cmNlJ3Mgc2NoZW1hLCBhbmQgdGhlIHJlc291cmNlIHR5cGUgb2YgdGhlIHJlc291cmNlLlxuICAgIGNvbnN0IHVuaXF1ZUlkZW50aWZlciA9IGAke3Jlc291cmNlLlJlc291cmNlVHlwZX06JHtrZXl9OiR7cmVzb3VyY2UuUmVzb3VyY2VJZGVudGlmaWVyIVtrZXldfWA7XG4gICAgdW5pcXVlUmVzb3VyY2VzW3VuaXF1ZUlkZW50aWZlcl0gPSByZXNvdXJjZTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QudmFsdWVzKHVuaXF1ZVJlc291cmNlcyk7XG59O1xuXG4vKipcbiAqIENsYXNzIGZvciBtYWtpbmcgQ2xvdWRGb3JtYXRpb24gdGVtcGxhdGUgZ2VuZXJhdG9yIGNhbGxzXG4gKi9cbmV4cG9ydCBjbGFzcyBDZm5UZW1wbGF0ZUdlbmVyYXRvclByb3ZpZGVyIHtcbiAgcHJpdmF0ZSBjZm46IENsb3VkRm9ybWF0aW9uO1xuICBjb25zdHJ1Y3RvcihjZm46IENsb3VkRm9ybWF0aW9uKSB7XG4gICAgdGhpcy5jZm4gPSBjZm47XG4gIH1cblxuICBhc3luYyBjaGVja0ZvclJlc291cmNlU2NhbihyZXNvdXJjZVNjYW5TdW1tYXJpZXM6IENsb3VkRm9ybWF0aW9uLlJlc291cmNlU2NhblN1bW1hcmllcyB8IHVuZGVmaW5lZCxcbiAgICBvcHRpb25zOiBHZW5lcmF0ZVRlbXBsYXRlT3B0aW9ucywgY2xpZW50UmVxdWVzdFRva2VuOiBzdHJpbmcpIHtcblxuICAgIGlmICghcmVzb3VyY2VTY2FuU3VtbWFyaWVzIHx8IHJlc291cmNlU2NhblN1bW1hcmllcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmIChvcHRpb25zLmZyb21TY2FuID09PSBGcm9tU2Nhbi5NT1NUX1JFQ0VOVCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHNjYW5zIGZvdW5kLiBQbGVhc2UgZWl0aGVyIHN0YXJ0IGEgbmV3IHNjYW4gd2l0aCB0aGUgYC0tZnJvbS1zY2FuYCBuZXcgb3IgZG8gbm90IHNwZWNpZnkgYSBgLS1mcm9tLXNjYW5gIG9wdGlvbi4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByaW50KCdObyBzY2FucyBmb3VuZC4gSW5pdGlhdGluZyBhIG5ldyByZXNvdXJjZSBzY2FuLicpO1xuICAgICAgICBhd2FpdCB0aGlzLnN0YXJ0UmVzb3VyY2VTY2FuKGNsaWVudFJlcXVlc3RUb2tlbik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhIHRva2VuaXplZCBsaXN0IG9mIHJlc291cmNlcyBhbmQgdGhlaXIgYXNzb2NpYXRlZCBzY2FuLiBJZiBhIHRva2VuIGlzIHByZXNlbnQgdGhlIGZ1bmN0aW9uXG4gICAqIHdpbGwgbG9vcCB0aHJvdWdoIGFsbCBwYWdlcyBhbmQgY29tYmluZSB0aGVtIGludG8gYSBzaW5nbGUgbGlzdCBvZiBTY2FubmVkUmVsYXRlZFJlc291cmNlc1xuICAgKlxuICAgKiBAcGFyYW0gc2NhbklkIHNjYW4gaWQgZm9yIHRoZSB0byBsaXN0IHJlc291cmNlcyBmb3JcbiAgICogQHBhcmFtIHJlc291cmNlcyBBIGxpc3Qgb2YgcmVzb3VyY2VzIHRvIGZpbmQgcmVsYXRlZCByZXNvdXJjZXMgZm9yXG4gICAqL1xuICBhc3luYyBnZXRSZXNvdXJjZVNjYW5SZWxhdGVkUmVzb3VyY2VzKHNjYW5JZDogc3RyaW5nLCByZXNvdXJjZXM6IENsb3VkRm9ybWF0aW9uLlNjYW5uZWRSZXNvdXJjZXMgKVxuICAgIDogUHJvbWlzZTxDbG91ZEZvcm1hdGlvbi5TY2FubmVkUmVzb3VyY2VJZGVudGlmaWVycz4ge1xuICAgIGxldCByZWxhdGVkUmVzb3VyY2VMaXN0ID0gcmVzb3VyY2VzO1xuXG4gICAgLy8gYnJlYWsgdGhlIGxpc3Qgb2YgcmVzb3VyY2VzIGludG8gY2h1bmtzIG9mIDEwMCB0byBhdm9pZCBoaXR0aW5nIHRoZSAxMDAgcmVzb3VyY2UgbGltaXRcbiAgICBmb3IgKGNvbnN0IGNodW5rIG9mIGNodW5rcyhyZXNvdXJjZXMsIDEwMCkpIHtcbiAgICAgIC8vIGdldCB0aGUgZmlyc3QgcGFnZSBvZiByZWxhdGVkIHJlc291cmNlc1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5jZm4ubGlzdFJlc291cmNlU2NhblJlbGF0ZWRSZXNvdXJjZXMoe1xuICAgICAgICBSZXNvdXJjZVNjYW5JZDogc2NhbklkLFxuICAgICAgICBSZXNvdXJjZXM6IGNodW5rLFxuICAgICAgfSkucHJvbWlzZSgpO1xuXG4gICAgICAvLyBhZGQgdGhlIGZpcnN0IHBhZ2UgdG8gdGhlIGxpc3RcbiAgICAgIHJlbGF0ZWRSZXNvdXJjZUxpc3QucHVzaCguLi4ocmVzLlJlbGF0ZWRSZXNvdXJjZXMgPz8gW10pKTtcbiAgICAgIGxldCBuZXh0VG9rZW4gPSByZXMuTmV4dFRva2VuO1xuXG4gICAgICAvLyBpZiB0aGVyZSBhcmUgbW9yZSBwYWdlcywgY3ljbGUgdGhyb3VnaCB0aGVtIGFuZCBhZGQgdGhlbSB0byB0aGUgbGlzdCBiZWZvcmUgbW92aW5nIG9uIHRvIHRoZSBuZXh0IGNodW5rXG4gICAgICB3aGlsZSAobmV4dFRva2VuKSB7XG4gICAgICAgIGNvbnN0IG5leHRSZWxhdGVkUmVzb3VyY2VzID0gYXdhaXQgdGhpcy5jZm4ubGlzdFJlc291cmNlU2NhblJlbGF0ZWRSZXNvdXJjZXMoe1xuICAgICAgICAgIFJlc291cmNlU2NhbklkOiBzY2FuSWQsXG4gICAgICAgICAgUmVzb3VyY2VzOiByZXNvdXJjZUlkZW50aWZpZXJzKHJlc291cmNlcyksXG4gICAgICAgICAgTmV4dFRva2VuOiBuZXh0VG9rZW4sXG4gICAgICAgIH0pLnByb21pc2UoKTtcbiAgICAgICAgbmV4dFRva2VuID0gbmV4dFJlbGF0ZWRSZXNvdXJjZXMuTmV4dFRva2VuO1xuICAgICAgICByZWxhdGVkUmVzb3VyY2VMaXN0LnB1c2goLi4uKG5leHRSZWxhdGVkUmVzb3VyY2VzLlJlbGF0ZWRSZXNvdXJjZXMgPz8gW10pKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZWxhdGVkUmVzb3VyY2VMaXN0ID0gZGVkdXBsaWNhdGVSZXNvdXJjZXMocmVsYXRlZFJlc291cmNlTGlzdCk7XG5cbiAgICAvLyBwcnVuZSB0aGUgbWFuYWdlZGJ5c3RhY2sgZmxhZyBvZmYgb2YgdGhlbSBhZ2Fpbi5cbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuTUlHUkFURV9JTlRFR19URVNUID8gcmVzb3VyY2VJZGVudGlmaWVycyhyZWxhdGVkUmVzb3VyY2VMaXN0KSA6IHJlc291cmNlSWRlbnRpZmllcnMoZXhjbHVkZU1hbmFnZWQocmVsYXRlZFJlc291cmNlTGlzdCkpIDtcbiAgfVxuXG4gIC8qKlxuICAgKiBLaWNrcyBvZmYgYSBzY2FuIG9mIGEgY3VzdG9tZXJzIGFjY291bnQsIHJldHVybmluZyB0aGUgc2NhbiBpZC4gQSBzY2FuIGNhbiB0YWtlXG4gICAqIDEwIG1pbnV0ZXMgb3IgbG9uZ2VyIHRvIGNvbXBsZXRlLiBIb3dldmVyIHRoaXMgd2lsbCByZXR1cm4gYSBzY2FuIGlkIGFzIHNvb24gYXNcbiAgICogdGhlIHNjYW4gaGFzIGJlZ3VuLlxuICAgKlxuICAgKiBAcmV0dXJucyBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHNjYW4gaWRcbiAgICovXG4gIGFzeW5jIHN0YXJ0UmVzb3VyY2VTY2FuKHJlcXVlc3RUb2tlbjogc3RyaW5nICkge1xuICAgIHJldHVybiAoYXdhaXQgdGhpcy5jZm4uc3RhcnRSZXNvdXJjZVNjYW4oe1xuICAgICAgQ2xpZW50UmVxdWVzdFRva2VuOiByZXF1ZXN0VG9rZW4sXG4gICAgfSkucHJvbWlzZSgpKS5SZXNvdXJjZVNjYW5JZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBtb3N0IHJlY2VudCBzY2FucyBhIGN1c3RvbWVyIGhhcyBjb21wbGV0ZWRcbiAgICpcbiAgICogQHJldHVybnMgYSBsaXN0IG9mIHJlc291cmNlIHNjYW4gc3VtbWFyaWVzXG4gICAqL1xuICBhc3luYyBsaXN0UmVzb3VyY2VTY2FucygpIHtcblxuICAgIHJldHVybiB0aGlzLmNmbi5saXN0UmVzb3VyY2VTY2FucygpLnByb21pc2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYSB0b2tlbml6ZWQgbGlzdCBvZiByZXNvdXJjZXMgZnJvbSBhIHJlc291cmNlIHNjYW4uIElmIGEgdG9rZW4gaXMgcHJlc2VudCwgdGhpcyBmdW5jdGlvblxuICAgKiB3aWxsIGxvb3AgdGhyb3VnaCBhbGwgcGFnZXMgYW5kIGNvbWJpbmUgdGhlbSBpbnRvIGEgc2luZ2xlIGxpc3Qgb2YgU2Nhbm5lZFJlc291cmNlcy5cbiAgICogQWRkaXRpb25hbGx5IHdpbGwgYXBwbHkgYW55IGZpbHRlcnMgcHJvdmlkZWQgYnkgdGhlIGN1c3RvbWVyLlxuICAgKlxuICAgKiBAcGFyYW0gc2NhbklkIHNjYW4gaWQgZm9yIHRoZSB0byBsaXN0IHJlc291cmNlcyBmb3JcbiAgICogQHBhcmFtIGZpbHRlcnMgYSBzdHJpbmcgb2YgZmlsdGVycyBpbiB0aGUgZm9ybWF0IG9mIGtleTE9dmFsdWUxLGtleTI9dmFsdWUyXG4gICAqIEByZXR1cm5zIGEgY29tYmluZWQgbGlzdCBvZiBhbGwgcmVzb3VyY2VzIGZyb20gdGhlIHNjYW5cbiAgICovXG4gIGFzeW5jIGxpc3RSZXNvdXJjZVNjYW5SZXNvdXJjZXMoc2NhbklkOiBzdHJpbmcsIGZpbHRlcnM6IHN0cmluZ1tdID0gW10gKVxuICAgIDogUHJvbWlzZTxDbG91ZEZvcm1hdGlvbi5TY2FubmVkUmVzb3VyY2VJZGVudGlmaWVycz4ge1xuXG4gICAgbGV0IHJlc291cmNlTGlzdDogQ2xvdWRGb3JtYXRpb24uU2Nhbm5lZFJlc291cmNlcyA9IFtdO1xuICAgIGxldCByZXNvdXJjZVNjYW5JbnB1dHM6IENsb3VkRm9ybWF0aW9uLkxpc3RSZXNvdXJjZVNjYW5SZXNvdXJjZXNJbnB1dDtcblxuICAgIGlmIChmaWx0ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIHByaW50KCdBcHBseWluZyBmaWx0ZXJzIHRvIHJlc291cmNlIHNjYW4uJyk7XG4gICAgICBmb3IgKGNvbnN0IGZpbHRlciBvZiBmaWx0ZXJzKSB7XG4gICAgICAgIGNvbnN0IGZpbHRlckxpc3QgPSBwYXJzZUZpbHRlcnMoZmlsdGVyKTtcbiAgICAgICAgcmVzb3VyY2VTY2FuSW5wdXRzID0ge1xuICAgICAgICAgIFJlc291cmNlU2NhbklkOiBzY2FuSWQsXG4gICAgICAgICAgUmVzb3VyY2VJZGVudGlmaWVyOiBmaWx0ZXJMaXN0W0ZpbHRlclR5cGUuUkVTT1VSQ0VfSURFTlRJRklFUl0sXG4gICAgICAgICAgUmVzb3VyY2VUeXBlUHJlZml4OiBmaWx0ZXJMaXN0W0ZpbHRlclR5cGUuUkVTT1VSQ0VfVFlQRV9QUkVGSVhdLFxuICAgICAgICAgIFRhZ0tleTogZmlsdGVyTGlzdFtGaWx0ZXJUeXBlLlRBR19LRVldLFxuICAgICAgICAgIFRhZ1ZhbHVlOiBmaWx0ZXJMaXN0W0ZpbHRlclR5cGUuVEFHX1ZBTFVFXSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzb3VyY2VzID0gYXdhaXQgdGhpcy5jZm4ubGlzdFJlc291cmNlU2NhblJlc291cmNlcyhyZXNvdXJjZVNjYW5JbnB1dHMpLnByb21pc2UoKTtcbiAgICAgICAgcmVzb3VyY2VMaXN0ID0gcmVzb3VyY2VMaXN0LmNvbmNhdChyZXNvdXJjZXMuUmVzb3VyY2VzID8/IFtdKTtcbiAgICAgICAgbGV0IG5leHRUb2tlbiA9IHJlc291cmNlcy5OZXh0VG9rZW47XG5cbiAgICAgICAgLy8gY3ljbGUgdGhyb3VnaCB0aGUgcGFnZXMgYWRkaW5nIGFsbCByZXNvdXJjZXMgdG8gdGhlIGxpc3QgdW50aWwgd2UgcnVuIG91dCBvZiBwYWdlc1xuICAgICAgICB3aGlsZSAobmV4dFRva2VuKSB7XG4gICAgICAgICAgcmVzb3VyY2VTY2FuSW5wdXRzLk5leHRUb2tlbiA9IG5leHRUb2tlbjtcbiAgICAgICAgICBjb25zdCBuZXh0UmVzb3VyY2VzID0gYXdhaXQgdGhpcy5jZm4ubGlzdFJlc291cmNlU2NhblJlc291cmNlcyhyZXNvdXJjZVNjYW5JbnB1dHMpLnByb21pc2UoKTtcbiAgICAgICAgICBuZXh0VG9rZW4gPSBuZXh0UmVzb3VyY2VzLk5leHRUb2tlbjtcbiAgICAgICAgICByZXNvdXJjZUxpc3QgPSByZXNvdXJjZUxpc3QhLmNvbmNhdChuZXh0UmVzb3VyY2VzLlJlc291cmNlcyA/PyBbXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcHJpbnQoJ05vIGZpbHRlcnMgcHJvdmlkZWQuIFJldHJpZXZpbmcgYWxsIHJlc291cmNlcyBmcm9tIHNjYW4uJyk7XG4gICAgICByZXNvdXJjZVNjYW5JbnB1dHMgPSB7XG4gICAgICAgIFJlc291cmNlU2NhbklkOiBzY2FuSWQsXG4gICAgICB9O1xuICAgICAgY29uc3QgcmVzb3VyY2VzID0gYXdhaXQgdGhpcy5jZm4ubGlzdFJlc291cmNlU2NhblJlc291cmNlcyhyZXNvdXJjZVNjYW5JbnB1dHMpLnByb21pc2UoKTtcbiAgICAgIHJlc291cmNlTGlzdCA9IHJlc291cmNlTGlzdCEuY29uY2F0KHJlc291cmNlcy5SZXNvdXJjZXMgPz8gW10pO1xuICAgICAgbGV0IG5leHRUb2tlbiA9IHJlc291cmNlcy5OZXh0VG9rZW47XG5cbiAgICAgIC8vIGN5Y2xlIHRocm91Z2ggdGhlIHBhZ2VzIGFkZGluZyBhbGwgcmVzb3VyY2VzIHRvIHRoZSBsaXN0IHVudGlsIHdlIHJ1biBvdXQgb2YgcGFnZXNcbiAgICAgIHdoaWxlIChuZXh0VG9rZW4pIHtcbiAgICAgICAgcmVzb3VyY2VTY2FuSW5wdXRzLk5leHRUb2tlbiA9IG5leHRUb2tlbjtcbiAgICAgICAgY29uc3QgbmV4dFJlc291cmNlcyA9IGF3YWl0IHRoaXMuY2ZuLmxpc3RSZXNvdXJjZVNjYW5SZXNvdXJjZXMocmVzb3VyY2VTY2FuSW5wdXRzKS5wcm9taXNlKCk7XG4gICAgICAgIG5leHRUb2tlbiA9IG5leHRSZXNvdXJjZXMuTmV4dFRva2VuO1xuICAgICAgICByZXNvdXJjZUxpc3QgPSByZXNvdXJjZUxpc3QhLmNvbmNhdChuZXh0UmVzb3VyY2VzLlJlc291cmNlcyA/PyBbXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyZXNvdXJjZUxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHJlc291cmNlcyBmb3VuZCB3aXRoIGZpbHRlcnMgJHtmaWx0ZXJzLmpvaW4oJyAnKX0uIFBsZWFzZSB0cnkgYWdhaW4gd2l0aCBkaWZmZXJlbnQgZmlsdGVycy5gKTtcbiAgICB9XG4gICAgcmVzb3VyY2VMaXN0ID0gZGVkdXBsaWNhdGVSZXNvdXJjZXMocmVzb3VyY2VMaXN0KTtcblxuICAgIHJldHVybiBwcm9jZXNzLmVudi5NSUdSQVRFX0lOVEVHX1RFU1QgPyByZXNvdXJjZUlkZW50aWZpZXJzKHJlc291cmNlTGlzdCkgOiByZXNvdXJjZUlkZW50aWZpZXJzKGV4Y2x1ZGVNYW5hZ2VkKHJlc291cmNlTGlzdCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBpbmZvcm1hdGlvbiBhYm91dCBhIHJlc291cmNlIHNjYW4uXG4gICAqXG4gICAqIEBwYXJhbSBzY2FuSWQgc2NhbiBpZCBmb3IgdGhlIHRvIGxpc3QgcmVzb3VyY2VzIGZvclxuICAgKiBAcmV0dXJucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgc2NhblxuICAgKi9cbiAgYXN5bmMgZGVzY3JpYmVSZXNvdXJjZVNjYW4oc2NhbklkOiBzdHJpbmcgKTpcbiAgUHJvbWlzZTxDbG91ZEZvcm1hdGlvbi5EZXNjcmliZVJlc291cmNlU2Nhbk91dHB1dD4ge1xuXG4gICAgcmV0dXJuIHRoaXMuY2ZuLmRlc2NyaWJlUmVzb3VyY2VTY2FuKHtcbiAgICAgIFJlc291cmNlU2NhbklkOiBzY2FuSWQsXG4gICAgfSkucHJvbWlzZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlc2NyaWJlcyB0aGUgY3VycmVudCBzdGF0dXMgb2YgdGhlIHRlbXBsYXRlIGJlaW5nIGdlbmVyYXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHRlbXBsYXRlSWQgQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB0ZW1wbGF0ZSBpZFxuICAgKiBAcmV0dXJucyBEZXNjcmliZUdlbmVyYXRlZFRlbXBsYXRlT3V0cHV0IGFuIG9iamVjdCBjb250YWluaW5nIHRoZSB0ZW1wbGF0ZSBzdGF0dXMgYW5kIHJlc3VsdHNcbiAgICovXG4gIGFzeW5jIGRlc2NyaWJlR2VuZXJhdGVkVGVtcGxhdGUodGVtcGxhdGVJZDogc3RyaW5nICk6XG4gIFByb21pc2U8Q2xvdWRGb3JtYXRpb24uRGVzY3JpYmVHZW5lcmF0ZWRUZW1wbGF0ZU91dHB1dD4ge1xuXG4gICAgY29uc3QgZ2VuZXJhdGVkVGVtcGxhdGUgPSBhd2FpdCB0aGlzLmNmbi5kZXNjcmliZUdlbmVyYXRlZFRlbXBsYXRlKHtcbiAgICAgIEdlbmVyYXRlZFRlbXBsYXRlTmFtZTogdGVtcGxhdGVJZCxcbiAgICB9KS5wcm9taXNlKCk7XG5cbiAgICBpZiAoZ2VuZXJhdGVkVGVtcGxhdGUuU3RhdHVzID09IFNjYW5TdGF0dXMuRkFJTEVEKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZ2VuZXJhdGVkVGVtcGxhdGUuU3RhdHVzUmVhc29uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2VuZXJhdGVkVGVtcGxhdGU7XG4gIH1cblxuICAvKipcbiAqIFJldHJpZXZlcyBhIGNvbXBsZXRlZCBnZW5lcmF0ZWQgY2xvdWRmb3JtYXRpb24gdGVtcGxhdGUgZnJvbSB0aGUgdGVtcGxhdGUgZ2VuZXJhdG9yLlxuICpcbiAqIEBwYXJhbSB0ZW1wbGF0ZUlkIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdGVtcGxhdGUgaWRcbiAqIEBwYXJhbSBjbG91ZEZvcm1hdGlvbiBUaGUgQ2xvdWRGb3JtYXRpb24gc2RrIGNsaWVudCB0byB1c2VcbiAqIEByZXR1cm5zIERlc2NyaWJlR2VuZXJhdGVkVGVtcGxhdGVPdXRwdXQgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHRlbXBsYXRlIHN0YXR1cyBhbmQgYm9keVxuICovXG4gIGFzeW5jIGdldEdlbmVyYXRlZFRlbXBsYXRlKHRlbXBsYXRlSWQ6IHN0cmluZyApOlxuICBQcm9taXNlPENsb3VkRm9ybWF0aW9uLkdldEdlbmVyYXRlZFRlbXBsYXRlT3V0cHV0PiB7XG5cbiAgICByZXR1cm4gdGhpcy5jZm4uZ2V0R2VuZXJhdGVkVGVtcGxhdGUoe1xuICAgICAgR2VuZXJhdGVkVGVtcGxhdGVOYW1lOiB0ZW1wbGF0ZUlkLFxuICAgIH0pLnByb21pc2UoKTtcbiAgfVxuXG4gIC8qKlxuICogS2lja3Mgb2ZmIGEgdGVtcGxhdGUgZ2VuZXJhdGlvbiBmb3IgYSBzZXQgb2YgcmVzb3VyY2VzLlxuICpcbiAqIEBwYXJhbSBzdGFja05hbWUgVGhlIG5hbWUgb2YgdGhlIHN0YWNrXG4gKiBAcGFyYW0gcmVzb3VyY2VzIEEgbGlzdCBvZiByZXNvdXJjZXMgdG8gZ2VuZXJhdGUgdGhlIHRlbXBsYXRlIGZyb21cbiAqIEByZXR1cm5zIENyZWF0ZUdlbmVyYXRlZFRlbXBsYXRlT3V0cHV0IGFuIG9iamVjdCBjb250YWluaW5nIHRoZSB0ZW1wbGF0ZSBhcm4gdG8gcXVlcnkgb24gbGF0ZXJcbiAqL1xuICBhc3luYyBjcmVhdGVHZW5lcmF0ZWRUZW1wbGF0ZShzdGFja05hbWU6IHN0cmluZywgcmVzb3VyY2VzOiBDbG91ZEZvcm1hdGlvbi5SZXNvdXJjZURlZmluaXRpb25zICkge1xuXG4gICAgY29uc3QgY3JlYXRlVGVtcGxhdGVPdXRwdXQgPSBhd2FpdCB0aGlzLmNmbi5jcmVhdGVHZW5lcmF0ZWRUZW1wbGF0ZSh7XG4gICAgICBSZXNvdXJjZXM6IHJlc291cmNlcyxcbiAgICAgIEdlbmVyYXRlZFRlbXBsYXRlTmFtZTogc3RhY2tOYW1lLFxuICAgIH0pLnByb21pc2UoKTtcblxuICAgIGlmIChjcmVhdGVUZW1wbGF0ZU91dHB1dC5HZW5lcmF0ZWRUZW1wbGF0ZUlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ3JlYXRlR2VuZXJhdGVkVGVtcGxhdGUgZmFpbGVkIHRvIHJldHJ1biBhbiBBcm4uJyk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVUZW1wbGF0ZU91dHB1dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGEgZ2VuZXJhdGVkIHRlbXBsYXRlIGZyb20gdGhlIHRlbXBsYXRlIGdlbmVyYXRvci5cbiAgICpcbiAgICogQHBhcmFtIHRlbXBsYXRlQXJuIFRoZSBhcm4gb2YgdGhlIHRlbXBsYXRlIHRvIGRlbGV0ZVxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSB0ZW1wbGF0ZSBoYXMgYmVlbiBkZWxldGVkXG4gICAqL1xuICBhc3luYyBkZWxldGVHZW5lcmF0ZWRUZW1wbGF0ZSh0ZW1wbGF0ZUFybjogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgYXdhaXQgdGhpcy5jZm4uZGVsZXRlR2VuZXJhdGVkVGVtcGxhdGUoe1xuICAgICAgR2VuZXJhdGVkVGVtcGxhdGVOYW1lOiB0ZW1wbGF0ZUFybixcbiAgICB9KS5wcm9taXNlKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgcG9zc2libGUgd2F5cyB0byBjaG9vc2UgYSBzY2FuIHRvIGdlbmVyYXRlIGEgQ0RLIGFwcGxpY2F0aW9uIGZyb21cbiAqL1xuZXhwb3J0IGVudW0gRnJvbVNjYW4ge1xuICAvKipcbiAgICogSW5pdGlhdGUgYSBuZXcgcmVzb3VyY2Ugc2NhbiB0byBidWlsZCB0aGUgQ0RLIGFwcGxpY2F0aW9uIGZyb20uXG4gICAqL1xuICBORVcsXG5cbiAgLyoqXG4gICAqIFVzZSB0aGUgbGFzdCBzdWNjZXNzZnVsIHNjYW4gdG8gYnVpbGQgdGhlIENESyBhcHBsaWNhdGlvbiBmcm9tLiBXaWxsIGZhaWwgaWYgbm8gc2NhbiBpcyBmb3VuZC5cbiAgICovXG4gIE1PU1RfUkVDRU5ULFxuXG4gIC8qKlxuICAgKiBTdGFydHMgYSBzY2FuIGlmIG5vbmUgZXhpc3RzLCBvdGhlcndpc2UgdXNlcyB0aGUgbW9zdCByZWNlbnQgc3VjY2Vzc2Z1bCBzY2FuIHRvIGJ1aWxkIHRoZSBDREsgYXBwbGljYXRpb24gZnJvbS5cbiAgICovXG4gIERFRkFVTFQsXG59XG5cbi8qKlxuICogSW50ZXJmYWNlIGZvciB0aGUgb3B0aW9ucyBvYmplY3QgcGFzc2VkIHRvIHRoZSBnZW5lcmF0ZVRlbXBsYXRlIGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHN0YWNrTmFtZSBUaGUgbmFtZSBvZiB0aGUgc3RhY2tcbiAqIEBwYXJhbSBmaWx0ZXJzIEEgbGlzdCBvZiBmaWx0ZXJzIHRvIGFwcGx5IHRvIHRoZSBzY2FuXG4gKiBAcGFyYW0gZnJvbVNjYW4gQW4gZW51bSB2YWx1ZSBzcGVjaWZ5aW5nIHdoZXRoZXIgYSBuZXcgc2NhbiBzaG91bGQgYmUgc3RhcnRlZCBvciB0aGUgbW9zdCByZWNlbnQgc3VjY2Vzc2Z1bCBzY2FuIHNob3VsZCBiZSB1c2VkXG4gKiBAcGFyYW0gc2RrUHJvdmlkZXIgVGhlIHNkayBwcm92aWRlciBmb3IgbWFraW5nIENsb3VkRm9ybWF0aW9uIGNhbGxzXG4gKiBAcGFyYW0gZW52aXJvbm1lbnQgVGhlIGFjY291bnQgYW5kIHJlZ2lvbiB3aGVyZSB0aGUgc3RhY2sgaXMgZGVwbG95ZWRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBHZW5lcmF0ZVRlbXBsYXRlT3B0aW9ucyB7XG4gIHN0YWNrTmFtZTogc3RyaW5nO1xuICBmaWx0ZXJzPzogc3RyaW5nW107XG4gIGZyb21TY2FuPzogRnJvbVNjYW47XG4gIHNka1Byb3ZpZGVyOiBTZGtQcm92aWRlcjtcbiAgZW52aXJvbm1lbnQ6IEVudmlyb25tZW50O1xufVxuXG4vKipcbiAqIEludGVyZmFjZSBmb3IgdGhlIG91dHB1dCBvZiB0aGUgZ2VuZXJhdGVUZW1wbGF0ZSBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSBtaWdyYXRlSnNvbiBUaGUgZ2VuZXJhdGVkIE1pZ3JhdGUuanNvbiBmaWxlXG4gKiBAcGFyYW0gcmVzb3VyY2VzIFRoZSBnZW5lcmF0ZWQgdGVtcGxhdGVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBHZW5lcmF0ZVRlbXBsYXRlT3V0cHV0IHtcbiAgbWlncmF0ZUpzb246IE1pZ3JhdGVKc29uRm9ybWF0O1xuICByZXNvdXJjZXM/OiBDbG91ZEZvcm1hdGlvbi5SZXNvdXJjZURldGFpbHM7XG4gIHRlbXBsYXRlSWQ/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogSW50ZXJmYWNlIGRlZmluaW5nIHRoZSBmb3JtYXQgb2YgdGhlIGdlbmVyYXRlZCBNaWdyYXRlLmpzb24gZmlsZVxuICpcbiAqIEBwYXJhbSBUZW1wbGF0ZUJvZHkgVGhlIGdlbmVyYXRlZCB0ZW1wbGF0ZVxuICogQHBhcmFtIFNvdXJjZSBUaGUgc291cmNlIG9mIHRoZSB0ZW1wbGF0ZVxuICogQHBhcmFtIFJlc291cmNlcyBBIGxpc3Qgb2YgcmVzb3VyY2VzIHRoYXQgd2VyZSB1c2VkIHRvIGdlbmVyYXRlIHRoZSB0ZW1wbGF0ZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIE1pZ3JhdGVKc29uRm9ybWF0IHtcbiAgdGVtcGxhdGVCb2R5OiBzdHJpbmc7XG4gIHNvdXJjZTogc3RyaW5nO1xuICByZXNvdXJjZXM/OiBHZW5lcmF0ZWRSZXNvdXJjZUltcG9ydElkZW50aWZpZXJbXTtcbn1cblxuLyoqXG4gKiBJbnRlcmZhY2UgcmVwcmVzZW50aW5nIHRoZSBmb3JtYXQgb2YgYSByZXNvdXJjZSBpZGVudGlmaWVyIHJlcXVpcmVkIGZvciByZXNvdXJjZSBpbXBvcnRcbiAqXG4gKiBAcGFyYW0gUmVzb3VyY2VUeXBlIFRoZSB0eXBlIG9mIHJlc291cmNlXG4gKiBAcGFyYW0gTG9naWNhbFJlc291cmNlSWQgVGhlIGxvZ2ljYWwgaWQgb2YgdGhlIHJlc291cmNlXG4gKiBAcGFyYW0gUmVzb3VyY2VJZGVudGlmaWVyIFRoZSByZXNvdXJjZSBpZGVudGlmaWVyIG9mIHRoZSByZXNvdXJjZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEdlbmVyYXRlZFJlc291cmNlSW1wb3J0SWRlbnRpZmllciB7XG4gIC8vIGNkayBkZXBsb3kgZXhwZWN0cyB0aGUgbWlncmF0ZS5qc29uIHJlc291cmNlIGlkZW50aWZpZXJzIHRvIGJlIFBhc2NhbENhc2UsIG5vdCBjYW1lbENhc2UuXG4gIFJlc291cmNlVHlwZTogc3RyaW5nO1xuICBMb2dpY2FsUmVzb3VyY2VJZDogc3RyaW5nO1xuICBSZXNvdXJjZUlkZW50aWZpZXI6IENsb3VkRm9ybWF0aW9uLlJlc291cmNlSWRlbnRpZmllclByb3BlcnRpZXM7XG59XG4iXX0=